
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Visualizer II - Interactive Music Theory Explorer</title>
    
    <!-- Music engraving fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Music&display=swap" rel="stylesheet">

    <!-- Alternative: Use Bravura font via CDN -->

        <!-- Bravura and Petaluma SMuFL fonts for music notation -->
        <style>
        @font-face {
            font-family: 'Bravura';
            src: url('https://cdn.jsdelivr.net/gh/steinbergmedia/bravura@latest/redist/otf/Bravura.otf') format('opentype');
            font-display: swap;
        }
        @font-face {
            font-family: 'Petaluma';
            src: url('https://cdn.jsdelivr.net/npm/@musescore/petaluma@1.0.0/fonts/PetalumaScript.otf') format('opentype');
            font-display: swap;
        }
        </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics-compat.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .circle-of-fifths {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto 30px;
        }
        .circle-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #333;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .circle-button:hover {
            background: #e0e0e0;
            transform: scale(1.1);
        }
        .circle-button.selected {
            background: #4CAF50;
            color: white;
        }
        .major-key {
            border-color: #2196F3;
        }
        .minor-key {
            border-color: #FF9800;
            font-size: 11px;
        }
        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .key-info, .instrument-panel {
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .key-info h3, .instrument-panel h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .scale-notes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }
        .note-chip {
            padding: 4px 8px;
            background: #42A5F5;
            color: white;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
        }
        .note-chip.root {
            background: #f44336;
        }
        .chord-toggle {
            display: flex;
            gap: 0;
            margin: 15px 0;
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }
        .chord-toggle button {
            flex: 1;
            padding: 6px 8px;
            border: none;
            background: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            transition: all 0.3s ease;
        }
        .chord-toggle button.active {
            background: #4CAF50;
            color: white;
        }
        .chord-toggle button:hover:not(.active) {
            background: #e0e0e0;
        }
        .chord-analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(65px, 1fr));
            gap: 8px;
            margin: 15px 0;
            max-width: 100%;
            overflow-x: auto;
        }
        
        .chord-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 6px 4px;
            background: #f9f9f9;
            min-width: 65px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .chord-column.selected {
            border-color: #ff6b35;
            background: #fff5f2;
        }
        
        .roman-numeral {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
            text-align: center;
            font-weight: normal;
        }
        
        .scale-degree-roman {
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
            text-align: center;
            font-weight: normal;
        }
        
        .function-roman {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
            text-align: center;
            font-weight: normal;
        }
        
        .chord-button {
            padding: 6px 8px;
            margin: 4px 0;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            font-size: 13px;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .chord-button.selected {
            background: #ff6b35;
            color: white;
            border-color: #e55a2b;
        }
        
        .note-members {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        .note-member {
            font-size: 11px;
            line-height: 1.3;
            margin: 1px 0;
            text-align: center;
            width: 100%;
        }
        
        .degree-subscript {
            font-size: 8px;
            vertical-align: sub;
            color: #888;
            margin-right: 2px;
        }
        
        /* Diminished passing chord styles */
        .diminished-mode .chord-analysis-grid {
            grid-template-rows: auto auto;
        }
        
        .diatonic-chord {
            grid-row: 1;
            opacity: 0.4;
            transition: opacity 0.3s ease;
        }
        
        .passing-chord {
            grid-row: 2;
            border: 2px dashed #999;
            background: #f0f0f0;
            margin-top: 10px;
        }
        .instrument-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        .instrument-btn {
            padding: 10px 15px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .instrument-btn:hover {
            background: #e0e0e0;
        }
        .instrument-btn.selected {
            background: #4CAF50;
            color: white;
        }
        .tuning-controls {
            background: #BBDEFB; color: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .tuning-controls h4 {
            margin: 0 0 15px 0;
            color: #333;
        }
        .string-tuning {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .string-tuning label {
            min-width: 60px;
            font-weight: bold;
        }
        .string-tuning select {
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .fretboard {
            background: transparent;
            border-radius: 8px;
            margin: 20px auto;
            overflow-x: auto;
            overflow-y: hidden; /* Prevent vertical overflow that might cause floating elements */
            position: relative;
            width: 95%;
            max-width: 1400px;
            height: 280px;
        }
        .fretboard-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-width: 800px;
        }
        
        /* CSS Grid fretboard layout */
        .fretboard-grid {
            display: grid;
            grid-template-columns: 60px repeat(var(--fret-count, 24), 1fr);
            grid-template-rows: repeat(var(--string-count, 4), 38px);
            gap: 0;
            width: 100%;
            min-width: 800px;
            position: relative;
            /* Remove white background to allow fret cell backgrounds to show */
        }
        
        .fret-cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Completely remove all borders to eliminate horizontal lines */
            border: none !important;
            background: white; /* Default white background */
            border-radius: 0; /* Sharp, clean corners */
        }
        
        /* Add vertical fret lines */
        .fret-cell::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #ccc;
            z-index: 1;
        }
        
        /* Don't show fret line on the string label column */
        .string-label::after {
            display: none;
        }
        
        /* Position notes on the string line instead of center of cell */
        .fret-cell .note-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
        }
        
        /* Slightly darker background for traditional fret positions */
        .fretboard-grid .fret-cell.fret-position {
            background: rgba(220, 220, 220, 0.75) !important; /* Slightly darker semi-transparent gray */
        }
        
        /* Even darker background for 12th fret (octave) */
        .fretboard-grid .fret-cell.fret-12 {
            background: rgba(190, 190, 190, 0.85) !important; /* Darker semi-transparent gray */
        }
        
        
        /* Remove brown background from fret marker positions - make them transparent */
        
        /* String labels on the left */
        .string-label {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
            font-size: 16px;
            background: #e8e8e8;
            border-right: 1px solid #d7d6d6;
        }
        
        /* Add visual string lines */
        .fret-cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(to right, #666, #999, #666);
            z-index: 1;
            border-radius: 1px;
        }
        
        /* Notes positioned on the string line */
        .note-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            border: 2px solid #333;
            z-index: 10; /* Ensure notes appear above fret lines */
            position: relative;
        }
        .note-dot.root {
            background: #ff6b35;
            border: 2px solid #e55a2b;
        }
        .note-dot.scale {
            background: #BBDEFB; color: #1a1a1a;
            border: 2px solid #90CAF9;
        }
        .note-dot.chord {
            background: #0D47A1;
            border: 2px solid #001970;
        }
        
        /* Fret markers below */
        .fret-markers {
            display: grid;
            grid-template-columns: 60px repeat(var(--fret-count, 24), 1fr);
            gap: 0;
            margin-top: 10px;
            padding: 0 10px;
            position: relative;
            /* Debug: temporarily make container visible */
            /* border: 1px solid red; */
        }
        .fret-marker {
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 25px;
            position: relative;
        }
        .fret-marker .fret-number {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        .fret-number {
            font-size: 13px;
            color: #333;
            font-weight: 600;
            line-height: 1;
        }
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
        }
        
        /* Chord Progression System CSS */
        .progression-controls {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #ccc;
        }

        .progression-controls h4 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .progression-setup {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .progression-setup select, .progression-setup input {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .create-progression-btn, .play-progression-btn {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease;
        }

        .create-progression-btn:hover, .play-progression-btn:hover {
            background: #45a049;
        }

        /* Enhanced Staff-Based Progression System CSS - Clean Multi-Row Layout */
        .staff-container {
            background: transparent;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px 20px 40px 20px;
            margin: 15px 0;
            display: none;
            font-family: 'Times New Roman', serif;
        }

        .staff-container.active {
            display: block;
        }

        .staff-wrapper {
            display: block; /* Change from grid */
            position: relative;
        }

        .staff-system {
            display: flex;
            align-items: flex-start;
            margin-bottom: 2rem;
            position: relative;
            page-break-inside: avoid;
        }

        .staff-system:last-child {
            margin-bottom: 0;
        }

        .staff-header {
            display: flex;
            align-items: center;
            gap: clamp(8px, 2vw, 15px);
            margin-right: 1rem;
            flex-shrink: 0;
            min-height: 3rem; /* Ensure consistent height even without treble clef */
        }

        .measures-row {
            display: flex;
            flex: 1;
            position: relative;
            min-height: 5rem;
            overflow: visible; /* Allow chord symbols to appear above */
        }

        .staff-svg {
            position: absolute;
            top: 1rem;
            left: 0;
            width: 100%;
            height: 3rem;
            z-index: 1;
        }

        .time-signature {
            font-size: clamp(1.2rem, 3.5vw, 1.8rem);
            line-height: 0.8;
            text-align: center;
            margin-left: 0.5rem;
            font-weight: bold;
            color: #000;
        }

        .measure-staff {
            flex: 1;
            min-width: clamp(80px, 15vw, 120px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            border-right: 1px solid #000;
            height: 5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            min-height: 44px; /* Minimum touch target */
            margin-top: 30px; /* Space for section markers */
            overflow: visible; /* Allow chord symbols to appear above */
        }

        .measure-staff:first-child {
            border-left: 2px solid #000;
        }

        .measure-staff:last-child {
            border-right: 2px solid #000;
        }

        .measure-staff:hover,
        .measure-staff:focus {
            background-color: rgba(76, 175, 80, 0.1);
        }

        .measure-staff.selected-measure {
            background-color: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
        }
        
        /* Section marker styles */
        .section-marker {
            position: absolute;
            left: 0;
            top: -25px;
            font-weight: bold;
            font-size: 12px;
            color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
            white-space: nowrap;
            z-index: 5;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* Custom Chord Creator Styles */
        .custom-chord-section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .custom-chord-toggle {
            width: 100%;
            padding: 10px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .custom-chord-toggle.active {
            background: #FF9800;
        }

        .custom-chord-controls {
            margin-top: 10px;
        }

        .custom-chord-status {
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .custom-chord-buttons {
            display: flex;
            gap: 10px;
        }

        .custom-chord-controls-bottom {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .custom-chord-controls-bottom .custom-chord-status {
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #666;
        }

        .play-chord-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .play-chord-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .play-chord-btn:hover:not(:disabled) {
            background: #45a049;
        }

        /* Custom chord selection styles */
        .note-dot.custom-root {
            background: #FF9800 !important;
            color: white !important;
            border: 3px solid #F57400 !important;
            font-weight: bold;
        }

        .note-dot.chord-root {
            background: #FF9800 !important;
            color: white !important;
            border: 2px solid #F57400 !important;
        }

        .note-dot.custom-selected {
            background: #0D47A1 !important; /* Match chord tone blue exactly */
            color: white !important;
            border: 2px solid #001970 !important; /* Match chord tone border */
        }

        .note-dot.clickable {
            cursor: pointer;
        }

        .note-dot.clickable:hover {
            background: #0D47A1 !important;
            border-color: #001970 !important;
        }

        /* Chord Analysis Window */
        .chord-analysis-window {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .chord-analysis-window h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        .current-notes {
            font-size: 18px;
            font-weight: bold;
            color: #2c5282;
            margin-bottom: 10px;
            min-height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .note-with-degree {
            display: inline-block;
            margin: 0 4px;
            color: #2c5282;
        }

        .degree-subscript {
            font-size: 12px;
            vertical-align: sub;
            color: #666;
        }

        .no-notes {
            color: #666;
            font-style: italic;
            font-weight: normal;
        }

        .chord-suggestions {
            border-top: 1px solid #dee2e6;
            padding-top: 10px;
            margin-top: 10px;
        }

        .suggestions-list {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        .chord-suggestion {
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #bbdefb;
            cursor: pointer;
        }

        .chord-suggestion:hover {
            background: #bbdefb;
        }
        
        .chord-suggestion.custom-chord {
            background: #1976d2;
            color: white;
            border: 2px solid #0d47a1;
            font-weight: bold;
        }
        
        .chord-suggestion.custom-chord:hover {
            background: #1e88e5;
            transform: translateY(-1px);
        }
        
        .chord-suggestion.custom-chord.perfect-match {
            background: #2e7d32;
            border: 2px solid #1b5e20;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .chord-suggestion.custom-chord.perfect-match:hover {
            background: #388e3c;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .chord-suggestion.clear-button {
            background: #f44336;
            color: white;
            border: 2px solid #d32f2f;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .chord-suggestion.clear-button:hover {
            background: #e53935;
            transform: translateY(-1px);
        }

        .custom-chord-buttons button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .add-chord-btn {
            background: #4CAF50;
            color: white;
        }

        .add-chord-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .clear-chord-btn {
            background: #FF5722;
            color: white;
        }

        .arpeggio-toggle-btn {
            background: #607D8B;
            color: white;
        }

        .arpeggio-toggle-btn:hover {
            background: #455A64;
        }

        /* Clickable note dots in custom chord mode */
        .note-dot.clickable {
            cursor: pointer;
            transition: transform 0.1s;
        }

        .note-dot.custom-selected {
            background-color: #FF9800;
            border: 2px solid #FF6F00;
        }

        .note-dot.custom-root {
            background-color: #FF5722;
            border: 2px solid #D84315;
            box-shadow: 0 0 8px rgba(255, 87, 34, 0.5);
        }


        .staff-container .chord-symbol {
            position: absolute;
            top: 0.5rem;
            font-size: clamp(1.1rem, 2.5vw, 1.3rem);
            font-weight: bold;
            color: #000;
            white-space: nowrap;
            font-family: 'Times New Roman', serif;
            text-align: center;
        }

        .staff-container .rhythm-symbols, .rhythm-symbols {
            position: absolute;
            top: -1.2rem;
            left: 0;
            width: 100%;
            text-align: center;
            font-family: 'Bravura', 'Petaluma', 'Noto Music', 'Arial', sans-serif;
            font-size: clamp(1.2rem, 2.7vw, 1.5rem);
            font-weight: normal;
            letter-spacing: 0.05em;
            line-height: 1.1;
            user-select: none;
            pointer-events: none;
        }

        /* Fine-tune notehead/stem alignment for Bravura */
        .rhythm-symbols span {
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.2em;
            /* Adjust baseline for better stem connection */
            transform: translateY(0.08em);
        }

        .staff-container .roman-numeral {
            position: absolute;
            bottom: -1.5rem;
            font-size: clamp(0.9rem, 2.2vw, 1.1rem);
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            font-family: 'Times New Roman', serif;
            line-height: 1.5;
            text-align: center;
        }

        /* Section Tabs */
        .section-tabs-container {
            display: flex;
            align-items: flex-end;
            gap: 4px;
            margin-bottom: 16px;
            padding: 8px 8px 0 8px;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            display: none; /* Hidden until progression is active */
            scrollbar-width: thin;
            scrollbar-color: #4CAF50 #e0e0e0;
        }

        .section-tabs-container::-webkit-scrollbar {
            height: 6px;
        }

        .section-tabs-container::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 3px;
        }

        .section-tabs-container::-webkit-scrollbar-track {
            background: #e0e0e0;
        }

        .section-tabs-container.active {
            display: flex;
        }

        .section-tabs {
            display: flex;
            gap: 4px;
            flex: 1;
        }

        .section-tab {
            position: relative;
            /* KEY: Dynamic sizing with flex */
            flex: 1 1 0;
            min-width: 60px;
            max-width: 200px;
            
            padding: 10px 32px 10px 16px;
            background: #e0e0e0;
            border: 1px solid #ccc;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-family: 'Times New Roman', serif;
            
            /* Responsive font sizing */
            font-size: clamp(11px, 1.2vw, 13px);
            font-weight: 500;
            
            /* Handle text overflow */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            
            transition: all 0.2s ease;
            text-align: left;
            user-select: none;
        }

        .section-tab:hover {
            background: #d0d0d0;
            transform: translateY(-1px);
        }

        .section-tab.active {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
            font-weight: 600;
            box-shadow: 0 -2px 8px rgba(76, 175, 80, 0.3);
            transform: translateY(0);
        }

        .section-tab.active:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .section-tab-name {
            font-weight: 500;
            font-size: inherit;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: text;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .section-tab-name:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .section-tab.active .section-tab-name:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .section-tab-name-input {
            font-family: 'Times New Roman', serif;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #4CAF50;
            border-radius: 3px;
            padding: 2px 4px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }

        .section-tab.active .section-tab-name-input {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
        }

        .section-tab.active .section-tab-name {
            font-weight: 600;
        }

        .section-tab-info {
            font-size: clamp(9px, 0.9vw, 10px);
            opacity: 0.7;
            margin-left: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .section-tab.active .section-tab-info {
            opacity: 0.9;
        }

        /* Dynamic sizing modes added by JavaScript */
        .section-tab.mode-compact {
            min-width: 50px;
            max-width: 80px;
            padding: 8px 28px 8px 10px;
        }

        .section-tab.mode-compact .section-tab-info {
            display: none;
        }

        .section-tab.mode-comfortable {
            min-width: 80px;
            max-width: 150px;
        }

        .section-tab.mode-spacious {
            min-width: 120px;
            max-width: 200px;
            font-size: 14px;
        }

        .section-tab-close {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            transition: all 0.2s;
            color: #666;
        }

        .section-tab:hover .section-tab-close {
            opacity: 1;
        }

        .section-tab.active .section-tab-close {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .section-tab-close:hover {
            background: rgba(255,0,0,0.7) !important;
            color: white;
            transform: translateY(-50%) scale(1.1);
        }

        .section-tab-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }

        .section-tab-menu.active {
            display: block;
        }

        .section-tab-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
        }

        .section-tab-menu button:hover {
            background: #f5f5f5;
        }

        .add-section-btn {
            /* Fixed size - don't grow or shrink */
            flex: 0 0 auto;
            width: 50px;
            
            padding: 10px;
            background: transparent;
            color: #4CAF50;
            border: 2px dashed #4CAF50;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .add-section-btn:hover {
            background: #E8F5E9;
            border-color: #45a049;
        }

        .section-edit-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            min-width: 300px;
            display: none;
        }

        .section-edit-modal.active {
            display: block;
        }

        .section-edit-modal h3 {
            margin-top: 0;
            margin-bottom: 16px;
        }

        .section-edit-modal label {
            display: block;
            margin-bottom: 12px;
        }

        .section-edit-modal input,
        .section-edit-modal select {
            width: 100%;
            padding: 8px;
            margin-top: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .section-edit-modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .section-edit-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .section-edit-modal-buttons .save-btn {
            background: #4CAF50;
            color: white;
        }

        .section-edit-modal-buttons .cancel-btn {
            background: #ddd;
        }

        .section-tab-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 160px;
            overflow: hidden;
        }

        .section-tab-menu .menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .section-tab-menu .menu-item:hover {
            background: #f5f5f5;
        }

        .section-tab-menu .menu-item-danger {
            color: #f44336;
        }

        .section-tab-menu .menu-item-danger:hover {
            background: #ffebee;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .section-tab {
                min-width: 50px;
                max-width: 100px;
                padding: 8px 24px 8px 8px;
                font-size: 11px;
            }
            
            .section-tab-info {
                display: none;
            }
            
            .add-section-btn {
                width: 40px;
                font-size: 16px;
            }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
        }

        .modal-overlay.active {
            display: block;
        }

        @keyframes beatPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .count-in-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(3rem, 8vw, 4.5rem);
            font-weight: bold;
            color: #ff4444;
            z-index: 20;
            display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        @keyframes countPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        /* Mobile-Specific Adaptations */
        @media (max-width: 768px) {
            .staff-system {
                margin-bottom: 1.5rem;
            }
            
            .staff-header {
                gap: 5px;
            }
            
            .measure-staff {
                min-width: 60px;
            }
            
            .staff-container {
                padding: 15px;
                margin: 10px 0;
            }
            
            .staff-container .roman-numeral, .staff-container .chord-symbol {
                font-size: 12px; /* Fixed size for readability */
            }
        }

        @media (max-width: 480px) {
            .measures-row {
                overflow-x: auto;
            }
            
            .staff-container {
                padding: 15px;
            }
        }

        @media (hover: none) {
            .measure-staff:active {
                background-color: rgba(76, 175, 80, 0.2);
            }
        }

        .progression-controls-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 15px;
        }

        /* Cadence Controls */
        .cadence-controls {
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border: 1px solid #4a90e2;
            border-radius: 8px;
        }

        .cadence-controls h5 {
            margin: 0 0 10px 0;
            color: #2c5282;
            font-size: 14px;
        }

        .cadence-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .cadence-btn {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .cadence-btn:hover {
            background: linear-gradient(135deg, #357abd 0%, #2c5282 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .cadence-btn:active {
            transform: translateY(0);
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .info-panel {
                grid-template-columns: 1fr;
            }
            .fretboard {
                width: 100%;
                max-width: none;
            }
            .fretboard-grid {
                grid-template-columns: 60px repeat(var(--fret-count, 24), 25px);
                grid-template-rows: repeat(var(--string-count, 4), 42px);
                min-width: calc(60px + var(--fret-count, 24) * 25px);
            }
            .fret-markers {
                grid-template-columns: 60px repeat(var(--fret-count, 24), 25px);
                min-width: calc(60px + var(--fret-count, 24) * 25px);
            }
            .note-dot {
                width: 22px;
                height: 22px;
                font-size: 10px;
            }
            .string-label {
                font-size: 14px;
            }
            .chord-analysis-grid {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            }
            .chord-button {
                font-size: 12px;
                padding: 5px 6px;
            }
            .note-member {
                font-size: 10px;
            }
            .degree-subscript {
                font-size: 7px;
            }
        }
        
        @media (max-width: 480px) {
            .fretboard {
                width: 100%;
                max-width: none;
            }
            .fretboard-grid {
                grid-template-columns: 50px repeat(var(--fret-count, 24), 20px);
                grid-template-rows: repeat(var(--string-count, 4), 38px);
                min-width: calc(50px + var(--fret-count, 24) * 20px);
            }
            .fret-markers {
                grid-template-columns: 50px repeat(var(--fret-count, 24), 20px);
                min-width: calc(50px + var(--fret-count, 24) * 20px);
            }
            .note-dot {
                width: 18px;
                height: 18px;
                font-size: 9px;
            }
            .string-label {
                font-size: 12px;
            }
        }

        /* Position Controls Styling */
        .position-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin: 10px 0;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .position-btn {
            padding: 8px 12px;
            background: white;
            border: 2px solid #333;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 40px;
            text-align: center;
        }

        .position-btn:hover {
            background: #e0e0e0;
        }

        .position-btn.active {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .position-btn:hover {
            background: linear-gradient(135deg, #ecf0f1 0%, #d5dbdb 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        .position-label {
            font-size: 12px;
            color: #666;
            margin-right: 15px;
            white-space: nowrap;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 15px;
            padding-left: 15px;
            border-left: 1px solid #ccc;
        }

        .zoom-btn {
            padding: 6px 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .zoom-btn:hover {
            background: #1976D2;
        }

        .fretboard.position-zoom {
            transition: all 0.4s ease;
        }

        .fretboard-grid.zoomed {
            transform-origin: left center;
        }

        /* True Zoom Implementation */
        .fretboard-zoom-container {
            overflow-x: auto;
            overflow-y: hidden; /* Change back to hidden to prevent elements from escaping */
            transition: all 0.4s ease;
        }

        /* Sleek zoom container with modern styling */
        .fretboard-zoom-container.zoomed {
            /* Allow horizontal scrolling when zoomed and add padding for dots */
            padding: 25px 15px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.08) 0%, rgba(41, 128, 185, 0.12) 100%);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }

        /* Enhanced zoom grid styling */
        .fretboard-grid.zoomed {
            background: linear-gradient(145deg, rgba(248, 249, 250, 0.95) 0%, rgba(241, 243, 244, 0.98) 100%);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            /* Remove all grid borders to eliminate horizontal lines */
            border: none;
            outline: none;
        }

        .fretboard-grid.zoomed {
            transform: scale(1.4); /* Reduced from 1.8x to 1.4x for better visibility */
            transform-origin: left center;
            margin: 25px 0; /* Increased margin to prevent dot clipping */
        }

        /* Make fretboard elements smaller when zoomed */
        .fretboard-grid.zoomed {
            /* Override the CSS custom property to make string rows closer together */
            grid-template-rows: repeat(var(--string-count, 6), 28px); /* Increased slightly to accommodate dots */
        }

        .fretboard-grid.zoomed .note-dot {
            /* Enhanced note dots for zoom view - subtle styling without distracting borders */
            width: 22px;
            height: 22px;
            font-size: 10px;
            line-height: 22px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }

        .fretboard-grid.zoomed .string-label {
            /* Hide string labels in zoom view */
            display: none;
        }

        /* Ensure white background for fret cells in zoom view */
        .fretboard-grid.zoomed .fret-cell {
            background: white; /* Changed back to white */
            border-radius: 0; /* Sharp, clean corners for zoom view */
            border: none !important; /* Remove all borders for clean look */
            border-top: none !important; /* Remove horizontal grid lines */
            border-bottom: none !important; /* Remove horizontal grid lines */
        }

        /* Comprehensive border removal for zoom view */
        .fretboard-grid.zoomed .fret-cell,
        .fretboard-grid.zoomed .fret-cell::before,
        .fretboard-grid.zoomed .fret-cell::after {
            border: none !important;
            outline: none !important;
            box-shadow: none;
        }

        /* Enhanced fret lines for zoom view */
        .fretboard-grid.zoomed .fret-cell::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, #bdc3c7 0%, #95a5a6 50%, #bdc3c7 100%);
            opacity: 0.9;
            box-shadow: 0 0 4px rgba(189, 195, 199, 0.3);
        }

        /* Don't add fret line to the first column (string labels) */
        .fretboard-grid.zoomed .string-label::after {
            display: none;
        }

        /* Ensure fret position backgrounds are preserved in zoom */
        .fretboard-grid.zoomed .fret-cell.fret-position {
            background: rgba(220, 220, 220, 0.75) !important; /* Slightly darker semi-transparent gray for fret positions 3,5,7,9,15,17,19 */
        }

        .fretboard-grid.zoomed .fret-cell.fret-12 {
            background: rgba(190, 190, 190, 0.85) !important; /* Darker semi-transparent gray for 12th fret */
        }

        /* Nut line styling - using class-based approach */
        .fret-cell.nut-line::after {
            background-color: #000 !important;
            width: 3px !important;
        }
        
        .fretboard-grid.zoomed .fret-cell.nut-line::after {
            background-color: #000 !important;
            width: 6px !important;
            border-radius: 0;
            box-shadow: none;
        }
        
        /* Arpeggio line styling */
        .arpeggio-line {
            pointer-events: none;
            z-index: 15; /* Above strings but below notes */
            stroke: #000 !important;
            stroke-width: 3 !important;
            fill: none;
            opacity: 1 !important;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
        }
        
        .arpeggio-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        @keyframes drawArpeggio {
            to {
                stroke-dashoffset: 0;
            }
        }

        .fret-cell.hidden-position,
        .fret-marker.hidden-position {
            display: none !important;
        }

        /* Prevent any accidentally floating green elements */
        [style*="90EE90"], [style*="#90EE90"] {
            position: static !important;
        }

        /* Header Bar Styles */
        .app-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            margin: -20px -20px 20px -20px;
            border-radius: 10px 10px 0 0;
        }

        .app-header .logo {
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .user-controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .progressions-dropdown {
            position: relative;
        }

        .dropdown-button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .dropdown-button:hover {
            background: rgba(255,255,255,0.3);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #333;
        }

        .dropdown-item:hover {
            background: #f5f5f5;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .category-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 12px;
            background: #e3f2fd;
            color: #1565c0;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }

        .user-role-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .user-role-badge.teacher {
            background: #ffd700;
            color: #333;
        }

        .user-role-badge.student {
            background: rgba(255,255,255,0.3);
            color: white;
        }

        .btn-logout {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-logout:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .modal h2 {
            margin-top: 0;
            color: #333;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            width: 100%;
            transition: transform 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .modal-footer {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 14px;
        }

        .modal-footer a {
            color: #667eea;
            cursor: pointer;
            text-decoration: none;
        }

        .modal-footer a:hover {
            text-decoration: underline;
        }

        .save-progression-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .btn-save-progression {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-save-progression:hover {
            background: #45a049;
        }

        .btn-share-progression {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-share-progression:hover {
            background: #0b7dda;
        }

        .hidden {
            display: none;
        }

        /* Browse Library Styles */
        .browse-modal {
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .browse-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .btn-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-close:hover {
            color: #333;
        }

        .browse-content {
            flex: 1;
            overflow-y: auto;
            padding-top: 20px;
        }

        .collection-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 8px 16px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: #e8e8e8;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .packs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        /* Song Library Styles */
        .songs-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .songs-filter-bar {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            align-items: center;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .filter-select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .filter-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .songs-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .song-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .song-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .song-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 0 0 5px 0;
        }

        .song-artist {
            font-size: 14px;
            color: #666;
            margin: 0 0 12px 0;
        }

        .song-details {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .song-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 12px;
            background: #e3f2fd;
            color: #1565c0;
        }

        .song-badge.genre { background: #f3e5f5; color: #6a1b9a; }
        .song-badge.key { background: #e8f5e9; color: #2e7d32; }
        .song-badge.tempo { background: #fff3e0; color: #e65100; }
        .song-badge.difficulty.beginner { background: #c8e6c9; color: #2e7d32; }
        .song-badge.difficulty.intermediate { background: #fff9c4; color: #f57f17; }
        .song-badge.difficulty.advanced { background: #ffcdd2; color: #c62828; }

        .pack-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .pack-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .pack-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .pack-card.locked::after {
            content: '🔒';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
        }

        .pack-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 10px;
        }

        .pack-name {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .pack-description {
            font-size: 13px;
            color: #666;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .pack-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .difficulty-badge, .time-badge, .progression-count {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 12px;
            background: #e3f2fd;
            color: #1565c0;
        }

        .difficulty-badge.beginner { background: #c8e6c9; color: #2e7d32; }
        .difficulty-badge.intermediate { background: #fff9c4; color: #f57f17; }
        .difficulty-badge.advanced { background: #ffcdd2; color: #c62828; }

        .pack-detail {
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .btn-back {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .btn-back:hover {
            background: #e8e8e8;
        }

        .pack-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .pack-header h3 {
            margin: 0 0 10px 0;
            font-size: 28px;
        }

        .pack-header p {
            margin: 0 0 15px 0;
            opacity: 0.9;
        }

        .progressions-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .progression-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .progression-item:hover {
            background: #f0f0f0;
            border-color: #667eea;
        }

        .progression-info h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 16px;
        }

        .progression-meta {
            font-size: 12px;
            color: #666;
        }

        .btn-load-progression {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .btn-load-progression:hover {
            background: #45a049;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .btn-browse-library {
            background: linear-gradient(135deg, #FF6B6B 0%, #FFE66D 100%);
            color: #333;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-browse-library:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 107, 107, 0.3);
        }

        /* Ensure position buttons stay in their container */
        .position-btn {
            position: relative !important;
            background: #f8f9fa !important;
            border: 1px solid #dee2e6 !important;
        }

        /* Complete green box prevention - hide any elements with green background */
        *[style*="90EE90"],
        *[style*="#90EE90"],
        *[style*="rgb(144, 238, 144)"] {
            background: transparent !important;
            display: none !important;
        }

        /* Allow green styling only on chord buttons */
        .chord-button[style*="90EE90"],
        .chord-button[style*="#90EE90"],
        .chord-button[style*="rgb(144, 238, 144)"] {
            background: #90EE90 !important;
            display: block !important;
        }

        /* Specifically prevent green in fretboard area */
        .fretboard *[style*="90EE90"],
        .fretboard *[style*="#90EE90"],
        .fretboard *[style*="rgb(144, 238, 144)"] {
            background: transparent !important;
            display: none !important;
        }

        .fret-cell.position-target {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.3));
            /* Removed border to avoid conflict with fret lines */
            border-radius: 0; /* Keep sharp corners */
            border: none !important; /* Remove all borders completely */
            box-shadow: 0 0 12px rgba(52, 152, 219, 0.3), inset 0 1px 3px rgba(255, 255, 255, 0.1);
        }

        .fret-cell.context-fret {
            background: rgba(44, 62, 80, 0.3);
            /* Removed border to avoid conflict with fret lines */
            border-radius: 0; /* Keep sharp corners */
            border: none !important; /* Remove all borders completely */
        }

        .fret-cell.context-fret .note-dot {
            opacity: 0.7;
            filter: grayscale(0.2) brightness(0.9);
        }

        .fret-marker.position-target {
            /* Removed green background to prevent floating green box */
            border-radius: 2px;
            font-weight: bold; /* Add bold text instead of background */
        }

        .fret-marker.context-fret {
            color: #999;
        }

        /* Mobile Position Controls */
        @media (max-width: 768px) {
            .position-controls {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .position-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                justify-content: center;
            }
            
            .position-btn {
                min-width: 35px;
                padding: 6px 8px;
                font-size: 12px;
            }
            
            .zoom-controls {
                margin-left: 0;
                padding-left: 0;
                border-left: none;
                border-top: 1px solid #ccc;
                padding-top: 10px;
                justify-content: center;
            }
            
            /* Mobile Layout Reordering: Chord Progression → Instruments → Fretboard */
            .info-panel {
                flex-direction: column;
            }
            
            .key-info {
                order: 1; /* Chord progression first */
            }
            
            .instrument-panel {
                order: 2; /* Instruments second */
            }
            
            .fretboard {
                order: 3; /* Fretboard last */
            }
            
            /* Make progression controls more prominent on mobile */
            .progression-controls {
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .progression-controls h4 {
                font-size: 18px;
                margin-bottom: 15px;
                color: #495057;
            }
        }
    </style>
</head>
<body>
    <header class="main-header" style="background:#222;color:#fff;padding:18px 0 12px 0;box-shadow:0 2px 8px rgba(0,0,0,0.08);margin-bottom:18px;">
        <div style="display:flex;align-items:center;justify-content:space-between;max-width:1100px;margin:0 auto;padding:0 24px;">
            <h1 style="margin:0;font-size:2.1rem;letter-spacing:1px;font-weight:700;">Chord Visualizer II</h1>
            <nav>
                <label for="genreDropdown" style="font-size:1.1rem;margin-right:8px;">Choose Genre:</label>
                <select id="genreDropdown" style="font-size:1.1rem;padding:6px 12px;border-radius:6px;border:1px solid #ccc;min-width:200px;">
                    <option value="">Choose genre...</option>
                </select>
            </nav>
        </div>
        <!-- Genre Modal -->
        <div id="genreModal" class="genre-modal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:10000;">
            <div class="modal-box" style="background:white;border-radius:12px;width:90%;max-width:700px;max-height:80vh;display:flex;flex-direction:column;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);">
                <div class="modal-header" style="padding:20px;border-bottom:2px solid #eee;display:flex;justify-content:space-between;align-items:center;">
                    <h2 id="modalGenre">Songs</h2>
                    <button class="modal-close" onclick="closeModal()" style="background:none;border:none;font-size:28px;cursor:pointer;color:#999;">&times;</button>
                </div>
                <div id="modalSongs" class="modal-songs" style="padding:20px;overflow-y:auto;"></div>
            </div>
        </div>
    </header>
        <!-- Song Category Modal System -->
        <div id="songCategoryModalOverlay" class="modal-overlay" style="display:none;z-index:2000;">
            <div class="modal" style="max-width:800px;width:95%;max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
                <div class="modal-header" style="padding:20px 30px;border-bottom:1px solid #eee;display:flex;justify-content:space-between;align-items:center;">
                    <div>
                        <h2 id="songCategoryModalTitle" style="font-size:24px;color:#333;margin:0;">Songs</h2>
                        <span class="genre-badge" id="songCategoryModalGenre" style="background:#4CAF50;color:white;padding:5px 12px;border-radius:20px;font-size:14px;font-weight:500;"></span>
                    </div>
                    <button class="modal-close" id="songCategoryModalClose" style="background:none;border:none;font-size:32px;color:#999;cursor:pointer;width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;">&times;</button>
                </div>
                <div class="modal-body" style="padding:20px 30px;overflow-y:auto;flex:1;">
                    <div id="songCategoryModalLoading" class="loading" style="display:none;text-align:center;padding:40px;color:#999;">
                        <div class="loading-spinner" style="border:3px solid #f3f3f3;border-top:3px solid #4CAF50;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto 20px;"></div>
                        <p>Loading songs...</p>
                    </div>
                    <div id="songCategoryModalEmpty" class="empty-state" style="display:none;text-align:center;padding:60px 20px;color:#999;">
                        <div class="icon" style="font-size:64px;margin-bottom:20px;">🎵</div>
                        <h3>No songs found</h3>
                        <p>There are no songs in this category yet.</p>
                    </div>
                    <div id="songCategoryModalList" class="song-list" style="display:grid;gap:15px;"></div>
                </div>
                <div class="modal-footer" style="padding:20px 30px;border-top:1px solid #eee;display:flex;justify-content:space-between;align-items:center;">
                    <span class="song-count" id="songCategoryModalCount" style="color:#666;font-size:14px;"></span>
                    <button class="btn btn-secondary" id="songCategoryModalCancel" style="padding:10px 24px;font-size:16px;background:#f5f5f5;color:#666;border:none;border-radius:6px;">Close</button>
                </div>
            </div>
        </div>
        <style>
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            .song-card-modal { background:#f9f9f9;border:2px solid #e0e0e0;border-radius:8px;padding:15px 20px;cursor:pointer;transition:all 0.2s;display:flex;justify-content:space-between;align-items:center; }
            .song-card-modal:hover { background:#fff;border-color:#4CAF50;transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.1); }
            .song-card-modal.selected { background:#e8f5e9;border-color:#4CAF50;border-width:2px; }
            .song-info-modal { flex:1; }
            .song-title-modal { font-size:18px;font-weight:600;color:#333;margin-bottom:5px; }
            .song-details-modal { display:flex;gap:15px;font-size:14px;color:#666; }
            .song-detail-modal { display:flex;align-items:center;gap:5px; }
            .song-actions-modal { display:flex;gap:10px; }
            .btn-modal { padding:8px 16px;border:none;border-radius:6px;font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s; }
            .btn-modal-primary { background:#4CAF50;color:white; }
            .btn-modal-primary:hover { background:#45a049;transform:translateY(-1px);box-shadow:0 2px 8px rgba(76,175,80,0.3); }
            .btn-modal-secondary { background:#f5f5f5;color:#666; }
            .btn-modal-secondary:hover { background:#e0e0e0; }
        </style>
    <!-- Authentication Modal -->
    <div class="modal-overlay" id="authModal">
        <div class="modal">
            <h2 id="authModalTitle">Welcome to Chord Visualizer II</h2>
            <div id="authModalContent">
                <div class="form-group">
                    <label for="authEmail">Email</label>
                    <input type="email" id="authEmail" placeholder="Enter your email" required>
                </div>
                <div class="form-group" id="roleSelectionGroup" style="display: none;">
                    <label for="userRole">I am a:</label>
                    <select id="userRole">
                        <option value="student">Student</option>
                        <option value="teacher">Teacher</option>
                    </select>
                </div>
                <div class="form-group" id="teacherCodeGroup" style="display: none;">
                    <label for="teacherCode">Teacher Code</label>
                    <input type="text" id="teacherCode" placeholder="Enter teacher code">
                    <small style="color: #666;">Contact your administrator for the teacher code</small>
                </div>
                <button class="btn-primary" id="authSubmitBtn">Sign In</button>
                <div class="modal-footer">
                    <span id="authSwitchText">Don't have an account? <a id="authSwitchLink">Create one</a></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Progression Modal -->
    <div class="modal-overlay" id="saveModal">
        <div class="modal">
            <h2>Save Progression</h2>
            <div class="form-group">
                <label for="progressionName">Progression Name</label>
                <input type="text" id="progressionName" placeholder="e.g., Beatles Progressions">
            </div>
            <div class="form-group">
                <label for="progressionCategories">Categories (comma-separated)</label>
                <input type="text" id="progressionCategories" placeholder="e.g., Rock, Beatles, I-IV-V">
            </div>
            <button class="btn-primary" id="saveProgressionBtn">Save</button>
            <button class="btn-secondary" onclick="closeSaveModal()">Cancel</button>
        </div>
    </div>

    <!-- Share Progression Modal -->
    <div class="modal-overlay" id="shareModal">
        <div class="modal">
            <h2>Share Progression</h2>
            <div class="form-group">
                <label>Share with Students (enter email addresses)</label>
                <input type="text" id="shareEmails" placeholder="student1@email.com, student2@email.com">
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="makePublic"> Make Public
                </label>
            </div>
            <div id="publicLinkContainer" style="display: none; margin-top: 10px;">
                <label>Public Link:</label>
                <input type="text" id="publicLink" readonly style="margin-top: 5px;">
                <button class="btn-secondary" onclick="copyPublicLink()">Copy Link</button>
            </div>
            <button class="btn-primary" id="shareProgressionBtn">Share</button>
            <button class="btn-secondary" onclick="closeShareModal()">Cancel</button>
        </div>
    </div>

    <!-- Section Edit Modal -->
    <div class="modal-overlay" id="sectionEditModal">
        <div class="modal">
            <h2>Edit Section</h2>
            <div class="form-group">
                <label for="sectionName">Section Name</label>
                <input type="text" id="sectionName" placeholder="e.g., Verse, Chorus, Bridge">
            </div>
            <div class="form-group">
                <label for="sectionBars">Number of Bars</label>
                <input type="number" id="sectionBars" min="1" max="64" value="4">
            </div>
            <div class="form-group">
                <label for="sectionKey">Key</label>
                <select id="sectionKey">
                    <option value="C">C Major</option>
                    <option value="G">G Major</option>
                    <option value="D">D Major</option>
                    <option value="A">A Major</option>
                    <option value="E">E Major</option>
                    <option value="B">B Major</option>
                    <option value="F♯/G♭">F♯/G♭ Major</option>
                    <option value="F">F Major</option>
                    <option value="B♭">B♭ Major</option>
                    <option value="E♭">E♭ Major</option>
                    <option value="A♭">A♭ Major</option>
                    <option value="D♭">D♭ Major</option>
                    <option value="Am">A Minor</option>
                    <option value="Em">E Minor</option>
                    <option value="Bm">B Minor</option>
                    <option value="F♯m">F♯ Minor</option>
                    <option value="C♯m">C♯ Minor</option>
                    <option value="G♯m">G♯ Minor</option>
                    <option value="D♯m/E♭m">D♯/E♭ Minor</option>
                    <option value="Dm">D Minor</option>
                    <option value="Gm">G Minor</option>
                    <option value="Cm">C Minor</option>
                    <option value="Fm">F Minor</option>
                    <option value="B♭m">B♭ Minor</option>
                </select>
            </div>
            <div class="form-group">
                <label for="sectionTimeSignature">Time Signature</label>
                <select id="sectionTimeSignature">
                    <option value="4/4">4/4</option>
                    <option value="3/4">3/4</option>
                    <option value="2/4">2/4</option>
                    <option value="6/8">6/8</option>
                    <option value="9/8">9/8</option>
                    <option value="12/8">12/8</option>
                    <option value="5/4">5/4</option>
                    <option value="7/8">7/8</option>
                </select>
            </div>
            <button class="btn-primary" onclick="saveSectionEdit()">Save</button>
            <button class="btn-secondary" onclick="closeSectionEditModal()">Cancel</button>
        </div>
    </div>

    <!-- Browse Library Modal -->
    <div class="modal-overlay" id="browseLibraryModal">
        <div class="modal browse-modal">
            <div class="browse-header">
                <h2>📚 Browse Progression Library</h2>
                <button class="btn-close" onclick="closeBrowseLibrary()">✕</button>
            </div>
            
            <div class="browse-content">
                <!-- Collection Tabs -->
                <div class="collection-tabs" id="collectionTabs">
                    <button class="tab-btn active" data-collection="packs">Lesson Packs</button>
                    <button class="tab-btn" data-collection="songs">Song Library</button>
                </div>
                
                <!-- Packs Grid -->
                <div class="packs-grid" id="packsGrid">
                    <div class="loading">Loading...</div>
                </div>
                
                <!-- Songs Grid -->
                <div class="songs-grid" id="songsGrid" style="display: none;">
                    <div class="songs-filter-bar">
                        <input type="text" id="songSearchInput" placeholder="🔍 Search songs..." class="search-input">
                        <select id="genreFilter" class="filter-select">
                            <option value="all">All Genres</option>
                        </select>
                        <select id="difficultyFilter" class="filter-select">
                            <option value="all">All Difficulties</option>
                            <option value="Beginner">Beginner</option>
                            <option value="Intermediate">Intermediate</option>
                            <option value="Advanced">Advanced</option>
                        </select>
                        <select id="keyFilter" class="filter-select">
                            <option value="all">All Keys</option>
                        </select>
                    </div>
                    <div class="songs-list" id="songsList">
                        <div class="loading">Loading songs...</div>
                    </div>
                </div>
                
                <!-- Pack Detail View -->
                <div class="pack-detail" id="packDetail" style="display: none;">
                    <button class="btn-back" onclick="showPacksGrid()">← Back to Packs</button>
                    <div class="pack-header">
                        <h3 id="packTitle"></h3>
                        <p id="packDescription"></p>
                        <div class="pack-meta">
                            <span class="difficulty-badge" id="packDifficulty"></span>
                            <span class="time-badge" id="packTime"></span>
                        </div>
                    </div>
                    <div class="progressions-list" id="progressionsList"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Header Bar -->
        <div class="app-header" id="appHeader" style="display: none;">
            <div class="logo">
                🎵 Chord Visualizer II
            </div>
            <div class="user-controls">
                <button class="btn-browse-library" onclick="showBrowseLibrary()">📚 Browse Library</button>
                <div class="progressions-dropdown">
                    <button class="dropdown-button" onclick="toggleProgressionsDropdown()">
                        My Progressions ▼
                    </button>
                    <div class="dropdown-content" id="progressionsDropdown">
                        <div class="dropdown-item" style="justify-content: center; color: #999;">
                            No saved progressions yet
                        </div>
                    </div>
                </div>
                <div class="user-info">
                    <span id="userName">Guest</span>
                    <span class="user-role-badge" id="userRoleBadge">Student</span>
                </div>
                <button class="btn-logout" onclick="logout()">Logout</button>
            </div>
        </div>

        <h1>Chord Visualizer II</h1>
        
        <!-- Circle of Fifths -->
        <div class="circle-of-fifths" id="circleOfFifths"></div>
        
        <!-- Info Panel -->
        <div class="info-panel">
            <div class="key-info">
                <h3>Key Information</h3>
                <div id="keyInfo">Select a key to see information</div>
                
                <!-- Musical Staff -->
                <div class="staff-container" id="staffContainer">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div>
                            <h4 style="margin: 0;">Chord Progression Staff</h4>
                            <div id="currentSongTitle" style="font-size: 13px; color: #666; margin-top: 4px;"></div>
                        </div>
                        <div class="playback-mode-controls" style="display: flex; gap: 15px; font-size: 13px;">
                            <label style="cursor: pointer; display: flex; align-items: center; gap: 4px;">
                                <input type="radio" name="playbackMode" id="playCurrentSection" checked>
                                Section
                            </label>
                            <label style="cursor: pointer; display: flex; align-items: center; gap: 4px;">
                                <input type="radio" name="playbackMode" id="playAllSections">
                                Song
                            </label>
                        </div>
                    </div>
                    
                    <!-- Section Tabs -->
                    <div class="section-tabs-container" id="sectionTabsContainer">
                        <div class="section-tabs" id="sectionTabs">
                            <!-- Tabs will be generated here -->
                        </div>
                        <button class="add-section-btn" id="addSectionBtn" onclick="addNewSection()" title="Add new section">+</button>
                    </div>
                    
                    <div class="staff-wrapper" id="staffWrapper">
                        <!-- Systems will be generated here -->
                    </div>
                    <div class="count-in-display" id="countInDisplay">4</div>
                </div>
            </div>
            <div class="instrument-panel">
                <h3>Instruments</h3>
                <div class="instrument-buttons" id="instrumentButtons"></div>
                
                <!-- Interactive Tuning Controls -->
                <div class="tuning-controls" id="tuningControls">
                    <h4>Tuning</h4>
                    <div id="stringTunings"></div>
                </div>

                <!-- Chord Progression Controls -->
                <div class="progression-controls" id="progressionControls">
                    <h4>Chord Progression Composer</h4>
                    

                    
                    <div class="progression-setup">
                        <label>
                            Key: 
                            <select id="progressionKey">
                                <option value="C">C Major</option>
                                <option value="G">G Major</option>
                                <option value="D">D Major</option>
                                <option value="A">A Major</option>
                                <option value="E">E Major</option>
                                <option value="B">B Major</option>
                                <option value="F♯/G♭">F♯/G♭ Major</option>
                                <option value="F">F Major</option>
                                <option value="B♭">B♭ Major</option>
                                <option value="E♭">E♭ Major</option>
                                <option value="A♭">A♭ Major</option>
                                <option value="D♭">D♭ Major</option>
                                <option value="Am">A Minor</option>
                                <option value="Em">E Minor</option>
                                <option value="Bm">B Minor</option>
                                <option value="F♯m">F♯ Minor</option>
                                <option value="C♯m">C♯ Minor</option>
                                <option value="G♯m">G♯ Minor</option>
                                <option value="D♯m/E♭m">D♯/E♭ Minor</option>
                                <option value="Dm">D Minor</option>
                                <option value="Gm">G Minor</option>
                                <option value="Cm">C Minor</option>
                                <option value="Fm">F Minor</option>
                                <option value="B♭m">B♭ Minor</option>
                            </select>
                        </label>
                        
                        <label>
                            Time Signature: 
                            <select id="timeSignatureNumerator" onchange="updateTimeSignature()">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4" selected>4</option>
                                <option value="5">5</option>
                                <option value="6">6</option>
                                <option value="7">7</option>
                                <option value="8">8</option>
                                <option value="9">9</option>
                                <option value="10">10</option>
                                <option value="11">11</option>
                                <option value="12">12</option>
                                <option value="13">13</option>
                                <option value="14">14</option>
                                <option value="15">15</option>
                                <option value="16">16</option>
                                <option value="17">17</option>
                                <option value="18">18</option>
                                <option value="19">19</option>
                                <option value="20">20</option>
                                <option value="21">21</option>
                                <option value="22">22</option>
                                <option value="23">23</option>
                                <option value="24">24</option>
                            </select>
                            /
                            <select id="timeSignatureDenominator" onchange="updateTimeSignature()">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="4" selected>4</option>
                                <option value="8">8</option>
                                <option value="12">12</option>
                                <option value="16">16</option>
                            </select>
                            <input type="hidden" id="timeSignature" value="4/4">
                        </label>
                        
                        <label>
                            Subdivision: 
                            <select id="measureSubdivision" onchange="updateMeasureSubdivision()">
                                <option value="whole" selected>Whole note</option>
                                <option value="half">Half note</option>
                                <option value="dotted-half">Dotted half</option>
                                <option value="quarter">Quarter note</option>
                                <option value="dotted-quarter">Dotted quarter</option>
                                <option value="eighth">Eighth note</option>
                                <option value="dotted-eighth">Dotted eighth</option>
                            </select>
                        </label>
                        
                        <label>
                            Measures: 
                            <select id="measureCount">
                                <option value="2">2</option>
                                <option value="4" selected>4</option>
                                <option value="8">8</option>
                                <option value="12">12</option>
                                <option value="16">16</option>
                            </select>
                        </label>
                        
                        <label>
                            Tempo: 
                            <input type="number" id="tempo" value="120" min="60" max="200" step="5">
                            <span>BPM</span>
                        </label>
                    </div>
                    
                    <div class="progression-controls-row">
                        <button class="create-progression-btn" onclick="createProgression()">Create Progression</button>
                        <button class="play-progression-btn" onclick="playProgression()" disabled>Play</button>
                        <button class="create-progression-btn" onclick="clearProgression()">Clear</button>
                    </div>

                    <!-- Save/Share Controls (shown when logged in) -->
                    <div class="save-progression-controls hidden" id="saveShareControls">
                        <button class="btn-save-progression" onclick="showSaveModal()">💾 Save Progression</button>
                        <button class="btn-share-progression" onclick="showShareModal()">📤 Share</button>
                    </div>
                    
                    <!-- Cadence Controls -->
                    <div class="cadence-controls" id="cadenceControls" style="display: none;">
                        <h5>Suggested Cadences</h5>
                        <div class="cadence-buttons" id="cadenceButtons">
                            <!-- Cadence buttons will be generated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #ff6b35; border: 2px solid #e55a2b;"></div>
                <span>Key Center</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #FF9800; border: 2px solid #F57400;"></div>
                <span>Chord Root</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #0D47A1; border: 2px solid #001970;"></div>
                <span>Chord Tones</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #B3D9FF; border: 2px solid #90C4E8;"></div>
                <span>Scale Notes</span>
            </div>
        </div>
        
        <!-- Position Controls -->
        <div class="position-controls" id="positionControls" style="display: none;">
            <span class="position-label">Fretboard Positions:</span>
            <div class="position-buttons" id="positionButtons">
                <!-- Position buttons will be generated here -->
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="resetZoom()">Show All</button>
            </div>
        </div>
        
        <!-- Fretboard -->
        <div class="fretboard">
            <div class="fretboard-zoom-container" id="fretboardZoomContainer">
                <div id="fretboard"></div>
            </div>
            
            <!-- Custom Chord Controls Below Fretboard -->
            <div class="custom-chord-controls-bottom">
                <div class="custom-chord-status" id="customChordStatus">
                    <small>Click notes to build chord • Selected measure will auto-populate if progression is active</small>
                </div>
                <div class="custom-chord-buttons">
                    <button class="play-chord-btn" id="playCustomChordBtn" onclick="playCustomChord()" disabled>Hear Chord</button>
                    <button class="add-chord-btn" id="addCustomChordBtn" onclick="addCustomChordToProgression()" disabled>Add to Progression</button>
                    <button class="clear-chord-btn" onclick="clearCustomChord()">Clear</button>
                    <button class="arpeggio-toggle-btn" id="arpeggioToggleBtn" onclick="toggleArpeggioLines()">Hide Arpeggio</button>
                </div>
            </div>
        </div>
        
        <!-- Chord Analysis Window (moved outside fretboard container) -->
        <div class="chord-analysis-window" id="chordAnalysisWindow">
            <h4>Chord Analysis</h4>
            <div class="current-notes" id="currentNotes">
                <span class="no-notes">Click notes to build chord</span>
            </div>
            <div class="chord-suggestions" id="chordSuggestions" style="display: none;">
                <strong>Possible chords:</strong>
                <div class="suggestions-list" id="suggestionsList"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== FIREBASE CONFIGURATION AND AUTHENTICATION =====
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCeSRoepr9w5isE_UatuR7SAzMUBnbWyCY",
            authDomain: "chord-visualizer-ii.firebaseapp.com",
            projectId: "chord-visualizer-ii",
            storageBucket: "chord-visualizer-ii.firebasestorage.app",
            messagingSenderId: "780005067787",
            appId: "1:780005067787:web:b1fa14ba7916ce582c0b0e",
            measurementId: "G-7SWM0DJNE4"
        };

        // Initialize Firebase
        let firebaseApp, auth, db, analytics;
        let currentUser = null;
        let isAuthMode = 'signin'; // 'signin' or 'signup'

        async function initializeFirebase() {
            try {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                // Only initialize analytics if supported
                const isAnalyticsSupported = await firebase.analytics.isSupported();
                if (isAnalyticsSupported) {
                    analytics = firebase.analytics();
                    console.log('Firebase Analytics initialized');
                } else {
                    console.log('Firebase Analytics not supported in this environment');
                }
                
                console.log('Firebase initialized successfully');
            } catch (error) {
                console.error('Firebase initialization error:', error);
            }
        }
        
        initializeFirebase();

        // Helper function to safely log analytics events
        function logAnalytics(eventName, eventParams = {}) {
            if (analytics) {
                try {
                    analytics.logEvent(eventName, eventParams);
                } catch (error) {
                    console.warn('Analytics event failed:', eventName, error);
                }
            }
        }

        // Teacher code (change this to a secure code)
        const TEACHER_CODE = "MUSIC2025";

        // Authentication State Observer
        // TEMPORARILY DISABLED FOR TESTING - Allow app to function without auth
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                loadUserProfile(user.uid);
            } else {
                currentUser = null;
                // showAuthModal(); // DISABLED - Don't block UI
                console.log('Auth disabled for testing');
            }
        });

        // Show/Hide Authentication Modal
        function showAuthModal() {
            document.getElementById('authModal').classList.add('show');
            const appHeader = document.getElementById('appHeader');
            const saveShare = document.getElementById('saveShareControls');
            if (appHeader) appHeader.style.display = 'none';
            if (saveShare) saveShare.classList.add('hidden');
        }

        function hideAuthModal() {
            document.getElementById('authModal').classList.remove('show');
        }

        // Switch between Sign In and Sign Up
        const authSwitchLink = document.getElementById('authSwitchLink');
        if (authSwitchLink) {
            authSwitchLink.addEventListener('click', () => {
                isAuthMode = isAuthMode === 'signin' ? 'signup' : 'signin';
                updateAuthModal();
            });
        }

        function updateAuthModal() {
            const title = document.getElementById('authModalTitle');
            const submitBtn = document.getElementById('authSubmitBtn');
            const switchText = document.getElementById('authSwitchText');
            const switchLink = document.getElementById('authSwitchLink');
            const roleGroup = document.getElementById('roleSelectionGroup');
            
            if (isAuthMode === 'signup') {
                title.textContent = 'Create Account';
                submitBtn.textContent = 'Sign Up';
                switchText.innerHTML = 'Already have an account? ';
                switchLink.textContent = 'Sign in';
                roleGroup.style.display = 'block';
            } else {
                title.textContent = 'Welcome Back';
                submitBtn.textContent = 'Sign In';
                switchText.innerHTML = "Don't have an account? ";
                switchLink.textContent = 'Create one';
                roleGroup.style.display = 'none';
            }
        }

        // Show teacher code input when teacher is selected
        const userRoleSelect = document.getElementById('userRole');
        if (userRoleSelect) {
            userRoleSelect.addEventListener('change', (e) => {
                const teacherCodeGroup = document.getElementById('teacherCodeGroup');
                if (teacherCodeGroup) {
                    teacherCodeGroup.style.display = e.target.value === 'teacher' ? 'block' : 'none';
                }
            });
        }

        // Handle Authentication Submit
        const authSubmitBtn = document.getElementById('authSubmitBtn');
        if (authSubmitBtn) {
            authSubmitBtn.addEventListener('click', async () => {
                const email = document.getElementById('authEmail').value.trim();
                
                if (!email) {
                    alert('Please enter your email');
                    return;
                }

                try {
                    if (isAuthMode === 'signup') {
                        // Create new account
                        const role = document.getElementById('userRole').value;
                        
                        // Verify teacher code if teacher role selected
                        if (role === 'teacher') {
                            const teacherCode = document.getElementById('teacherCode').value.trim();
                            if (teacherCode !== TEACHER_CODE) {
                                alert('Invalid teacher code. Please contact your administrator.');
                                return;
                            }
                        }
                        
                        // Create user with email link (passwordless)
                        const actionCodeSettings = {
                            url: window.location.href,
                            handleCodeInApp: true,
                        };
                        
                        await auth.sendSignInLinkToEmail(email, actionCodeSettings);
                        window.localStorage.setItem('emailForSignIn', email);
                        window.localStorage.setItem('pendingRole', role);
                        
                        alert('Sign-in link sent! Please check your email to complete registration.');
                    } else {
                        // Sign in existing user
                        const actionCodeSettings = {
                            url: window.location.href,
                            handleCodeInApp: true,
                        };
                        
                        await auth.sendSignInLinkToEmail(email, actionCodeSettings);
                        window.localStorage.setItem('emailForSignIn', email);
                        
                        alert('Sign-in link sent! Please check your email.');
                    }
                } catch (error) {
                    console.error('Authentication error:', error);
                    alert('Error: ' + error.message);
                }
            });
        }

        // Handle email link sign-in
        if (auth.isSignInWithEmailLink(window.location.href)) {
            let email = window.localStorage.getItem('emailForSignIn');
            if (!email) {
                email = window.prompt('Please provide your email for confirmation');
            }
            
            if (email) {
                auth.signInWithEmailLink(email, window.location.href)
                    .then(async (result) => {
                        window.localStorage.removeItem('emailForSignIn');
                        const pendingRole = window.localStorage.getItem('pendingRole');
                        
                        // Create user profile if new user
                        const userDoc = await db.collection('users').doc(result.user.uid).get();
                        if (!userDoc.exists) {
                            await db.collection('users').doc(result.user.uid).set({
                                email: email,
                                username: email.split('@')[0],
                                role: pendingRole || 'student',
                                createdAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        window.localStorage.removeItem('pendingRole');
                        
                        // Clear the URL parameters and reload to clean state
                        window.history.replaceState({}, document.title, window.location.pathname);
                        window.location.reload();
                    })
                    .catch((error) => {
                        console.error('Sign-in error:', error);
                        alert('Error signing in: ' + error.message + '. Please try the link again.');
                    });
            }
        }

        // Load User Profile
        async function loadUserProfile(userId) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    document.getElementById('userName').textContent = userData.username || userData.email.split('@')[0];
                    document.getElementById('userRoleBadge').textContent = userData.role || 'student';
                    document.getElementById('userRoleBadge').className = `user-role-badge ${userData.role || 'student'}`;
                    
                    // Show header and save/share controls
                    document.getElementById('appHeader').style.display = 'flex';
                    document.getElementById('saveShareControls').classList.remove('hidden');
                    hideAuthModal();
                    
                    // Load user's progressions
                    loadUserProgressions(userId);
                    
                    // Track login analytics
                    logAnalytics('login', { method: 'email' });
                }
            } catch (error) {
                console.error('Error loading user profile:', error);
            }
        }

        // Logout
        async function logout() {
            try {
                await auth.signOut();
                document.getElementById('appHeader').style.display = 'none';
                document.getElementById('saveShareControls').classList.add('hidden');
                showAuthModal();
            } catch (error) {
                console.error('Logout error:', error);
                alert('Error logging out: ' + error.message);
            }
        }

        // ===== PROGRESSION SAVE/LOAD/SHARE FUNCTIONS =====
        
        // Show Save Modal
        function showSaveModal() {
            if (!currentUser) {
                alert('Please sign in to save progressions');
                return;
            }
            
            if (progressionMeasures.length === 0) {
                alert('Create a progression first before saving');
                return;
            }
            
            document.getElementById('saveModal').classList.add('show');
        }

        function closeSaveModal() {
            document.getElementById('saveModal').classList.remove('show');
            document.getElementById('progressionName').value = '';
            document.getElementById('progressionCategories').value = '';
        }

        // Save Progression
        document.getElementById('saveProgressionBtn').addEventListener('click', async () => {
            const name = document.getElementById('progressionName').value.trim();
            const categoriesInput = document.getElementById('progressionCategories').value.trim();
            
            if (!name) {
                alert('Please enter a progression name');
                return;
            }
            
            console.log('Attempting to save progression...');
            console.log('Current user:', currentUser);
            console.log('Progression measures:', progressionMeasures);
            console.log('Selected key:', selectedKey);
            console.log('Selected scale:', selectedScale);
            
            const categories = categoriesInput ? categoriesInput.split(',').map(c => c.trim()) : [];
            
            try {
                // Save current section state before saving
                currentSong.sections[currentSong.currentSectionIndex].measures = progressionMeasures;
                
                const progressionData = {
                    name: name,
                    key: selectedKey,
                    scale: selectedScale,
                    timeSignature: '4/4', // Can be made dynamic later
                    tempo: parseInt(document.getElementById('tempo').value) || 120,
                    
                    // NEW: Save entire song structure
                    song: {
                        title: currentSong.title,
                        sections: currentSong.sections.map(section => ({
                            id: section.id,
                            name: section.name,
                            bars: section.bars,
                            key: section.key,
                            timeSignature: section.timeSignature,
                            repeat: section.repeat || false,
                            measures: section.measures.map(measure => ({
                                symbol: measure.chord ? measure.chord.symbol : null,
                                notes: measure.chord ? measure.chord.notes : null,
                                localKey: measure.localKey,
                                timeSignature: measure.timeSignature
                            }))
                        }))
                    },
                    
                    // Keep legacy format for backwards compatibility
                    measures: progressionMeasures.map(measure => ({
                        symbol: measure.chord ? measure.chord.symbol : null,
                        notes: measure.chord ? measure.chord.notes : null,
                        localKey: measure.localKey,
                        timeSignature: measure.timeSignature
                    })),
                    
                    ownerId: currentUser.uid,
                    sharedWith: [],
                    isPublic: false,
                    publicLink: null,
                    categories: categories,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastModified: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                console.log('Progression data to save:', progressionData);
                
                const docRef = await db.collection('progressions').add(progressionData);
                console.log('Progression saved with ID:', docRef.id);
                
                alert('Progression saved successfully!');
                closeSaveModal();
                await loadUserProgressions(currentUser.uid);
                
                // Track save analytics
                logAnalytics('save_progression', { 
                    progression_name: name,
                    category_count: categories.length 
                });
            } catch (error) {
                console.error('Error saving progression:', error);
                alert('Error saving progression: ' + error.message);
            }
        });

        // Load User Progressions
        async function loadUserProgressions(userId) {
            console.log('loadUserProgressions called for userId:', userId);
            try {
                // Load own progressions
                const ownProgressions = await db.collection('progressions')
                    .where('ownerId', '==', userId)
                    .orderBy('lastModified', 'desc')
                    .get();
                
                console.log('Own progressions count:', ownProgressions.size);
                
                // Load shared progressions
                const sharedProgressions = await db.collection('progressions')
                    .where('sharedWith', 'array-contains', userId)
                    .orderBy('lastModified', 'desc')
                    .get();
                
                console.log('Shared progressions count:', sharedProgressions.size);
                
                const dropdown = document.getElementById('progressionsDropdown');
                dropdown.innerHTML = '';
                
                let hasProgressions = false;
                
                if (!ownProgressions.empty) {
                    hasProgressions = true;
                    dropdown.innerHTML += '<div style="padding: 8px 16px; font-weight: bold; background: #f5f5f5;">My Progressions</div>';
                    ownProgressions.forEach(doc => {
                        const data = doc.data();
                        console.log('Adding progression to dropdown:', doc.id, data.name);
                        dropdown.innerHTML += createProgressionItem(doc.id, data, true);
                    });
                }
                
                if (!sharedProgressions.empty) {
                    hasProgressions = true;
                    dropdown.innerHTML += '<div style="padding: 8px 16px; font-weight: bold; background: #f5f5f5; border-top: 1px solid #ddd;">Shared with Me</div>';
                    sharedProgressions.forEach(doc => {
                        const data = doc.data();
                        dropdown.innerHTML += createProgressionItem(doc.id, data, false);
                    });
                }
                
                if (!hasProgressions) {
                    dropdown.innerHTML = '<div class="dropdown-item" style="justify-content: center; color: #999;">No saved progressions yet</div>';
                }
            } catch (error) {
                console.error('Error loading progressions:', error);
            }
        }

        function createProgressionItem(id, data, isOwner) {
            const categories = data.categories && data.categories.length > 0 
                ? data.categories.map(c => `<span class="category-badge">${c}</span>`).join(' ')
                : '';
            
            return `
                <div class="dropdown-item" onclick="loadProgression('${id}')">
                    <div>
                        <div style="font-weight: 500;">${data.name}</div>
                        <div style="font-size: 11px; color: #999;">${data.key} ${data.scale}</div>
                        ${categories}
                    </div>
                    ${isOwner ? '<span style="font-size: 11px; color: #999;">👤</span>' : '<span style="font-size: 11px; color: #999;">📤</span>'}
                </div>
            `;
        }

        // Load Progression
        async function loadProgression(progressionId) {
            console.log('loadProgression called with ID:', progressionId);
            try {
                const doc = await db.collection('progressions').doc(progressionId).get();
                console.log('Document exists:', doc.exists);
                
                if (doc.exists) {
                    const data = doc.data();
                    console.log('Loaded progression data:', data);
                    
                    // Set both scale and key first (before calling update functions)
                    selectedScale = data.scale || 'major';
                    selectedKey = data.key;
                    
                    // Now update the UI with both values set
                    console.log('Calling selectScale with:', selectedScale);
                    selectScale(selectedScale); // This updates the scale UI
                    console.log('Calling selectKey with:', selectedKey, 'force: true');
                    selectKey(selectedKey, true); // This updates the key UI and fretboard
                    console.log('Key and scale set, Circle of Fifths should be highlighted');
                    
                    // Also update progression key variable and dropdown explicitly
                    progressionKey = data.key;
                    const progressionKeySelect = document.getElementById('progressionKey');
                    if (progressionKeySelect) {
                        progressionKeySelect.value = data.key;
                        console.log('Set progression dropdown to:', data.key);
                    }
                    
                    // Set tempo
                    document.getElementById('tempo').value = data.tempo || 120;
                    console.log('Set tempo:', data.tempo);
                    
                    // Load song structure (NEW format) or fallback to legacy measures
                    if (data.song && data.song.sections) {
                        // NEW: Load multi-section song
                        currentSong = {
                            title: data.song.title || data.name,
                            artist: data.song.artist || data.artist || 'Unknown Artist',
                            sections: data.song.sections.map(section => ({
                                id: section.id,
                                name: section.name,
                                bars: section.bars,
                                key: section.key,
                                timeSignature: section.timeSignature,
                                repeat: section.repeat || false,
                                measures: section.measures.map(m => {
                                    if (m.symbol) {
                                        return {
                                            chord: { symbol: m.symbol, notes: m.notes },
                                            localKey: m.localKey || section.key,
                                            timeSignature: m.timeSignature || section.timeSignature
                                        };
                                    } else {
                                        return {
                                            chord: null,
                                            localKey: m.localKey || section.key,
                                            timeSignature: m.timeSignature || section.timeSignature
                                        };
                                    }
                                })
                            })),
                            currentSectionIndex: 0
                        };
                        console.log('Loaded multi-section song:', currentSong);
                    } else {
                        // Legacy: Single section from old measures format
                        currentSong = {
                            title: data.name,
                            artist: data.artist || 'Unknown Artist',
                            sections: [{
                                id: 'section-1',
                                name: 'Main',
                                bars: data.measures.length,
                                key: data.key,
                                timeSignature: data.timeSignature || '4/4',
                                repeat: false,
                                measures: data.measures.map(m => {
                                    if (m.symbol) {
                                        return {
                                            chord: { symbol: m.symbol, notes: m.notes },
                                            localKey: m.localKey || data.key,
                                            timeSignature: m.timeSignature || data.timeSignature || '4/4'
                                        };
                                    } else {
                                        return {
                                            chord: null,
                                            localKey: m.localKey || data.key,
                                            timeSignature: m.timeSignature || data.timeSignature || '4/4'
                                        };
                                    }
                                })
                            }],
                            currentSectionIndex: 0
                        };
                        console.log('Loaded legacy single-section:', currentSong);
                    }
                    
                    // Sync compatibility layer
                    syncProgressionMeasures();
                    console.log('Synced progressionMeasures:', progressionMeasures);
                    
                    // Activate progression mode
                    progressionActive = true;
                    selectedMeasureIndex = 0;
                    
                    // Show staff container
                    const staffContainer = document.getElementById('staffContainer');
                    staffContainer.classList.add('active');
                    
                    // Update song title display
                    updateSongTitleDisplay();
                    
                    // Show and render section tabs
                    renderSectionTabs();
                    
                    // Generate the staff UI if it doesn't exist
                    console.log('Generating staff measures...');
                    generateStaffMeasures(progressionMeasures.length, data.timeSignature || '4/4');
                    
                    console.log('Updating progression chart...');
                    updateProgressionChart();
                    
                    console.log('Closing dropdown...');
                    toggleProgressionsDropdown(); // Close dropdown
                    
                    // Track load analytics
                    logAnalytics('load_progression', { progression_id: progressionId });
                } else {
                    console.error('Progression document does not exist');
                    alert('Progression not found');
                }
            } catch (error) {
                console.error('Error loading progression:', error);
                alert('Error loading progression: ' + error.message);
            }
        }

        // Toggle Progressions Dropdown
        function toggleProgressionsDropdown() {
            const dropdown = document.getElementById('progressionsDropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        window.addEventListener('click', (e) => {
            if (!e.target.matches('.dropdown-button') && !e.target.closest('.progressions-dropdown')) {
                document.getElementById('progressionsDropdown').classList.remove('show');
            }
        });

        // Show Share Modal
        function showShareModal() {
            if (!currentUser) {
                alert('Please sign in to share progressions');
                return;
            }
            
            if (progressionMeasures.length === 0) {
                alert('Create a progression first before sharing');
                return;
            }
            
            document.getElementById('shareModal').classList.add('show');
        }

        function closeShareModal() {
            document.getElementById('shareModal').classList.remove('show');
            document.getElementById('shareEmails').value = '';
            document.getElementById('makePublic').checked = false;
            document.getElementById('publicLinkContainer').style.display = 'none';
        }

        // Handle Make Public checkbox
        document.getElementById('makePublic').addEventListener('change', (e) => {
            document.getElementById('publicLinkContainer').style.display = e.target.checked ? 'block' : 'none';
        });

        // Share Progression
        document.getElementById('shareProgressionBtn').addEventListener('click', async () => {
            // First save the progression if not already saved
            const name = prompt('Enter a name for this progression:');
            if (!name) return;
            
            try {
                const isPublic = document.getElementById('makePublic').checked;
                const publicLink = isPublic ? generatePublicLink() : null;
                
                const progressionData = {
                    name: name,
                    key: selectedKey,
                    scale: selectedScale,
                    timeSignature: '4/4',
                    tempo: parseInt(document.getElementById('tempo').value) || 120,
                    measures: progressionMeasures.map(chord => ({
                        symbol: chord ? chord.symbol : null,
                        notes: chord ? chord.notes : null
                    })),
                    ownerId: currentUser.uid,
                    sharedWith: [],
                    isPublic: isPublic,
                    publicLink: publicLink,
                    categories: [],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastModified: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Save progression
                const docRef = await db.collection('progressions').add(progressionData);
                
                // Handle email sharing
                const emailsInput = document.getElementById('shareEmails').value.trim();
                if (emailsInput) {
                    const emails = emailsInput.split(',').map(e => e.trim());
                    
                    // Find users by email and add to sharedWith array
                    const usersSnapshot = await db.collection('users').where('email', 'in', emails).get();
                    const userIds = usersSnapshot.docs.map(doc => doc.id);
                    
                    if (userIds.length > 0) {
                        await docRef.update({
                            sharedWith: firebase.firestore.FieldValue.arrayUnion(...userIds)
                        });
                    }
                }
                
                // Show public link if applicable
                if (isPublic) {
                    const fullLink = `${window.location.origin}${window.location.pathname}?shared=${publicLink}`;
                    document.getElementById('publicLink').value = fullLink;
                }
                
                alert('Progression shared successfully!');
                loadUserProgressions(currentUser.uid);
                
                // Track share analytics
                logAnalytics('share_progression', { 
                    is_public: isPublic,
                    recipient_count: emailsInput ? emailsInput.split(',').length : 0
                });
            } catch (error) {
                console.error('Error sharing progression:', error);
                alert('Error sharing progression: ' + error.message);
            }
        });

        function generatePublicLink() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }

        function copyPublicLink() {
            const linkInput = document.getElementById('publicLink');
            linkInput.select();
            document.execCommand('copy');
            alert('Link copied to clipboard!');
        }

        // Check for shared progression in URL
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const sharedLink = urlParams.get('shared');
            
            if (sharedLink) {
                loadSharedProgression(sharedLink);
            }
        });

        async function loadSharedProgression(publicLink) {
            try {
                const snapshot = await db.collection('progressions')
                    .where('publicLink', '==', publicLink)
                    .where('isPublic', '==', true)
                    .limit(1)
                    .get();
                
                if (!snapshot.empty) {
                    const data = snapshot.docs[0].data();
                    
                    // Set key and scale
                    selectedKey = data.key;
                    selectedScale = data.scale;
                    updateKeyInfo();
                    
                    // Set tempo
                    document.getElementById('tempo').value = data.tempo || 120;
                    
                    // Load measures (handle both old format and new format with localKey)
                    progressionMeasures = data.measures.map(m => {
                        if (m.symbol || (m.chord && m.chord.symbol)) {
                            return {
                                chord: m.chord || { symbol: m.symbol, notes: m.notes },
                                localKey: m.localKey || data.key,
                                timeSignature: m.timeSignature || data.timeSignature || '4/4'
                            };
                        } else {
                            return {
                                chord: null,
                                localKey: m.localKey || data.key,
                                timeSignature: m.timeSignature || data.timeSignature || '4/4'
                            };
                        }
                    });
                    
                    // Activate progression mode
                    progressionActive = true;
                    selectedMeasureIndex = 0;
                    
                    // Show staff container
                    const staffContainer = document.getElementById('staffContainer');
                    staffContainer.classList.add('active');
                    
                    // Generate the staff UI if it doesn't exist
                    generateStaffMeasures(progressionMeasures.length, data.timeSignature || '4/4');
                    
                    updateProgressionChart();
                    
                    // Update the circle of fifths to highlight the selected key
                    selectKey(selectedKey);
                }
            } catch (error) {
                console.error('Error loading shared progression:', error);
            }
        }

        // ===== BROWSE LIBRARY SYSTEM =====
        
        // Initialize library with sample data (run once)
        async function initializeLibrary() {
            try {
                // Check if library is already initialized
                const libCheck = await db.collection('collections').limit(1).get();
                if (!libCheck.empty) {
                    console.log('Library already initialized');
                    return;
                }
                
                console.log('Initializing library...');
                
                // Create Foundational Forms collection
                const foundationalRef = await db.collection('collections').add({
                    name: "Foundational Forms",
                    description: "Essential progressions for learning music theory",
                    order: 1,
                    tier: "free",
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Create Blues Essentials pack
                const bluesPackRef = await db.collection('packs').add({
                    collectionId: foundationalRef.id,
                    name: "Blues Essentials",
                    description: "Core blues progressions every musician should know",
                    icon: "🎸",
                    difficulty: "beginner",
                    estimatedTime: "15 min",
                    tier: "free",
                    order: 1,
                    progressionCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Create Jazz Standards pack
                const jazzPackRef = await db.collection('packs').add({
                    collectionId: foundationalRef.id,
                    name: "Jazz Standards",
                    description: "Classic jazz progressions including ii-V-I and Rhythm Changes",
                    icon: "🎺",
                    difficulty: "intermediate",
                    estimatedTime: "25 min",
                    tier: "student",
                    order: 2,
                    progressionCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Create Pop/Rock pack
                const popPackRef = await db.collection('packs').add({
                    collectionId: foundationalRef.id,
                    name: "Pop/Rock Standards",
                    description: "Popular progressions from I-V-vi-IV to I-IV-V",
                    icon: "🎤",
                    difficulty: "beginner",
                    estimatedTime: "10 min",
                    tier: "free",
                    order: 3,
                    progressionCount: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Add sample progressions
                await addSampleProgressions(bluesPackRef.id, 'blues');
                await addSampleProgressions(jazzPackRef.id, 'jazz');
                await addSampleProgressions(popPackRef.id, 'pop');
                
                console.log('Library initialized successfully!');
                alert('Library initialized! Refresh the page to see the packs.');
            } catch (error) {
                console.error('Error initializing library:', error);
                alert('Error initializing library: ' + error.message);
            }
        }
        
        async function addSampleProgressions(packId, type = 'blues') {
            if (type === 'blues') {
                // 12-Bar Blues in C
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "12-Bar Blues",
                    key: "C",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 120,
                    measures: [
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'F7', notes: ['F', 'A', 'C', 'Eb'] },
                        { symbol: 'F7', notes: ['F', 'A', 'C', 'Eb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] },
                        { symbol: 'F7', notes: ['F', 'A', 'C', 'Eb'] },
                        { symbol: 'C7', notes: ['C', 'E', 'G', 'Bb'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] }
                    ],
                    romanNumerals: "I7-I7-I7-I7 | IV7-IV7-I7-I7 | V7-IV7-I7-V7",
                    description: "The most essential blues progression. Master this first!",
                    learningObjectives: ["Understand 12-bar form", "Practice I-IV-V movement", "Learn dominant 7th chords"],
                    tier: "free",
                    order: 1,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Minor Blues
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "Minor Blues",
                    key: "Am",
                    scale: "minor",
                    timeSignature: "4/4",
                    tempo: 110,
                    measures: [
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'] },
                        { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'E7', notes: ['E', 'G#', 'B', 'D'] },
                        { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'E7', notes: ['E', 'G#', 'B', 'D'] }
                    ],
                    romanNumerals: "i7-i7-i7-i7 | iv7-iv7-i7-i7 | V7-iv7-i7-V7",
                    description: "Blues with a darker, more emotional minor sound. Notice the major V7!",
                    learningObjectives: ["Minor blues form", "Harmonic minor sound", "i-iv-V progression"],
                    tier: "free",
                    order: 2,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update pack progression count
                await db.collection('packs').doc(packId).update({
                    progressionCount: firebase.firestore.FieldValue.increment(2)
                });
            } else if (type === 'jazz') {
                // Rhythm Changes A section
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "Rhythm Changes (A Section)",
                    key: "Bb",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 180,
                    measures: [
                        { symbol: 'Bbmaj7', notes: ['Bb', 'D', 'F', 'A'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] },
                        { symbol: 'Cm7', notes: ['C', 'Eb', 'G', 'Bb'] },
                        { symbol: 'F7', notes: ['F', 'A', 'C', 'Eb'] },
                        { symbol: 'Bbmaj7', notes: ['Bb', 'D', 'F', 'A'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] },
                        { symbol: 'Cm7', notes: ['C', 'Eb', 'G', 'Bb'] },
                        { symbol: 'F7', notes: ['F', 'A', 'C', 'Eb'] }
                    ],
                    romanNumerals: "Imaj7-VI7-ii7-V7 | Imaj7-VI7-ii7-V7",
                    description: "Based on 'I Got Rhythm'. The foundation of bebop! Notice the VI7 (secondary dominant).",
                    learningObjectives: ["Rhythm changes form", "Secondary dominants", "Fast tempo jazz"],
                    tier: "student",
                    order: 1,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // ii-V-I
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "ii-V-I (The Jazz Cadence)",
                    key: "C",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 140,
                    measures: [
                        { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] },
                        { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'] },
                        { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'] }
                    ],
                    romanNumerals: "ii7-V7-Imaj7-Imaj7",
                    description: "The most important progression in jazz! Every jazz musician must know this.",
                    learningObjectives: ["Master the ii-V-I", "Voice leading", "Jazz harmony fundamentals"],
                    tier: "student",
                    order: 2,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // I-vi-ii-V (Ice Cream Changes)
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "I-vi-ii-V (Ice Cream Changes)",
                    key: "C",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 100,
                    measures: [
                        { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'] },
                        { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'] },
                        { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'] },
                        { symbol: 'G7', notes: ['G', 'B', 'D', 'F'] }
                    ],
                    romanNumerals: "Imaj7-vi7-ii7-V7",
                    description: "Smooth descending bassline. Used in 'Heart and Soul', 'Blue Moon', many standards.",
                    learningObjectives: ["Circle of fifths progression", "Smooth voice leading", "Standard jazz form"],
                    tier: "student",
                    order: 3,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                await db.collection('packs').doc(packId).update({
                    progressionCount: firebase.firestore.FieldValue.increment(3)
                });
            } else if (type === 'pop') {
                // I-V-vi-IV (Axis of Awesome)
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "I-V-vi-IV (Axis of Awesome)",
                    key: "C",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 100,
                    measures: [
                        { symbol: 'C', notes: ['C', 'E', 'G'] },
                        { symbol: 'G', notes: ['G', 'B', 'D'] },
                        { symbol: 'Am', notes: ['A', 'C', 'E'] },
                        { symbol: 'F', notes: ['F', 'A', 'C'] }
                    ],
                    romanNumerals: "I-V-vi-IV",
                    description: "Used in hundreds of pop songs! Let It Be, Don't Stop Believin', With or Without You",
                    learningObjectives: ["Learn the most popular pop progression", "Understand diatonic harmony"],
                    tier: "free",
                    order: 1,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // I-IV-V (Classic Rock)
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "I-IV-V (Classic Rock)",
                    key: "A",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 120,
                    measures: [
                        { symbol: 'A', notes: ['A', 'C#', 'E'] },
                        { symbol: 'D', notes: ['D', 'F#', 'A'] },
                        { symbol: 'E', notes: ['E', 'G#', 'B'] },
                        { symbol: 'A', notes: ['A', 'C#', 'E'] }
                    ],
                    romanNumerals: "I-IV-V-I",
                    description: "Rock & roll's foundation! La Bamba, Wild Thing, Twist and Shout.",
                    learningObjectives: ["Basic three-chord rock", "Power chord movement", "I-IV-V relationships"],
                    tier: "free",
                    order: 2,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // vi-IV-I-V (Sensitive)
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "vi-IV-I-V (Sensitive Progression)",
                    key: "G",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 80,
                    measures: [
                        { symbol: 'Em', notes: ['E', 'G', 'B'] },
                        { symbol: 'C', notes: ['C', 'E', 'G'] },
                        { symbol: 'G', notes: ['G', 'B', 'D'] },
                        { symbol: 'D', notes: ['D', 'F#', 'A'] }
                    ],
                    romanNumerals: "vi-IV-I-V",
                    description: "Emotional and introspective. Used in Zombie, Grenade, Let Her Go.",
                    learningObjectives: ["Minor start for emotional effect", "Rotation of I-V-vi-IV"],
                    tier: "free",
                    order: 3,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Pachelbel's Canon
                await db.collection('library_progressions').add({
                    packId: packId,
                    name: "Pachelbel's Canon",
                    key: "D",
                    scale: "major",
                    timeSignature: "4/4",
                    tempo: 70,
                    measures: [
                        { symbol: 'D', notes: ['D', 'F#', 'A'] },
                        { symbol: 'A', notes: ['A', 'C#', 'E'] },
                        { symbol: 'Bm', notes: ['B', 'D', 'F#'] },
                        { symbol: 'F#m', notes: ['F#', 'A', 'C#'] },
                        { symbol: 'G', notes: ['G', 'B', 'D'] },
                        { symbol: 'D', notes: ['D', 'F#', 'A'] },
                        { symbol: 'G', notes: ['G', 'B', 'D'] },
                        { symbol: 'A', notes: ['A', 'C#', 'E'] }
                    ],
                    romanNumerals: "I-V-vi-iii-IV-I-IV-V",
                    description: "The famous Baroque progression. Descending bassline: D-C#-B-A-G-F#-G-A.",
                    learningObjectives: ["Stepwise bass motion", "Classical harmony", "Extended 8-bar form"],
                    tier: "free",
                    order: 4,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                await db.collection('packs').doc(packId).update({
                    progressionCount: firebase.firestore.FieldValue.increment(4)
                });
            }
        }
        
        // Browse Library Functions
        function showBrowseLibrary() {
            document.getElementById('browseLibraryModal').classList.add('show');
            
            // Setup tab switching
            const tabs = document.querySelectorAll('.tab-btn');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    const collection = tab.dataset.collection;
                    if (collection === 'packs') {
                        document.getElementById('packsGrid').style.display = 'grid';
                        document.getElementById('songsGrid').style.display = 'none';
                        loadCollections('all');
                    } else if (collection === 'songs') {
                        document.getElementById('packsGrid').style.display = 'none';
                        document.getElementById('songsGrid').style.display = 'flex';
                        loadSongs();
                    }
                });
            });
            
            // Load packs by default
            loadCollections('all');
        }
        
        function closeBrowseLibrary() {
            document.getElementById('browseLibraryModal').classList.remove('show');
        }
        
        async function loadCollections(filter = 'all') {
            const packsGrid = document.getElementById('packsGrid');
            packsGrid.innerHTML = '<div class="loading">Loading packs...</div>';
            
            try {
                let query = db.collection('packs').orderBy('order');
                
                if (filter !== 'all') {
                    const collections = await db.collection('collections')
                        .where('name', '==', getCollectionName(filter))
                        .get();
                    
                    if (!collections.empty) {
                        const collectionId = collections.docs[0].id;
                        query = query.where('collectionId', '==', collectionId);
                    }
                }
                
                const packs = await query.get();
                
                if (packs.empty) {
                    packsGrid.innerHTML = `
                        <div class="loading">
                            No packs found yet<br><br>
                            <button class="btn-primary" onclick="initializeLibrary()">Initialize Sample Library</button>
                        </div>
                    `;
                    return;
                }
                
                packsGrid.innerHTML = '';
                packs.forEach(doc => {
                    const pack = doc.data();
                    const isLocked = shouldLockPack(pack.tier);
                    
                    const card = document.createElement('div');
                    card.className = `pack-card ${isLocked ? 'locked' : ''}`;
                    card.innerHTML = `
                        <div class="pack-icon">${pack.icon || '📁'}</div>
                        <div class="pack-name">${pack.name}</div>
                        <div class="pack-description">${pack.description}</div>
                        <div class="pack-meta">
                            <span class="difficulty-badge ${pack.difficulty}">${pack.difficulty}</span>
                            <span class="time-badge">⏱️ ${pack.estimatedTime}</span>
                            <span class="progression-count">📝 ${pack.progressionCount || 0} progressions</span>
                        </div>
                    `;
                    
                    if (!isLocked) {
                        card.onclick = () => showPackDetail(doc.id, pack);
                    } else {
                        card.onclick = () => alert('Upgrade to Student tier ($3.99/mo) to unlock this pack!');
                    }
                    
                    packsGrid.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading packs:', error);
                packsGrid.innerHTML = '<div class="loading">Error loading packs: ' + error.message + '</div>';
            }
        }
        
        function shouldLockPack(packTier) {
            if (!currentUser) return packTier !== 'free';
            
            // For now, everyone gets free access (implement subscription tiers later)
            return false;
        }
        
        function getCollectionName(filter) {
            const names = {
                foundational: "Foundational Forms",
                genre: "By Genre",
                artist: "By Artist",
                era: "By Era"
            };
            return names[filter] || "";
        }
        
        async function showPackDetail(packId, packData) {
            document.getElementById('packsGrid').style.display = 'none';
            const detailView = document.getElementById('packDetail');
            detailView.style.display = 'block';
            
            // Update pack header
            document.getElementById('packTitle').textContent = packData.name;
            document.getElementById('packDescription').textContent = packData.description;
            document.getElementById('packDifficulty').textContent = packData.difficulty;
            document.getElementById('packDifficulty').className = `difficulty-badge ${packData.difficulty}`;
            document.getElementById('packTime').textContent = `⏱️ ${packData.estimatedTime}`;
            
            // Load progressions for this pack
            const progressionsList = document.getElementById('progressionsList');
            progressionsList.innerHTML = '<div class="loading">Loading progressions...</div>';
            
            try {
                const progressions = await db.collection('library_progressions')
                    .where('packId', '==', packId)
                    .orderBy('order')
                    .get();
                
                if (progressions.empty) {
                    progressionsList.innerHTML = '<div class="loading">No progressions in this pack yet</div>';
                    return;
                }
                
                progressionsList.innerHTML = '';
                progressions.forEach(doc => {
                    const prog = doc.data();
                    const item = document.createElement('div');
                    item.className = 'progression-item';
                    item.innerHTML = `
                        <div class="progression-info">
                            <h4>${prog.name}</h4>
                            <div class="progression-meta">
                                ${prog.key} ${prog.scale} • ${prog.measures.length} measures • ${prog.tempo} BPM
                                ${prog.description ? `<br>${prog.description}` : ''}
                            </div>
                        </div>
                        <button class="btn-load-progression" onclick="loadLibraryProgression('${doc.id}')">Load</button>
                    `;
                    progressionsList.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading progressions:', error);
                progressionsList.innerHTML = '<div class="loading">Error loading progressions: ' + error.message + '</div>';
            }
        }
        
        function showPacksGrid() {
            document.getElementById('packDetail').style.display = 'none';
            document.getElementById('packsGrid').style.display = 'grid';
        }
        
        // Song Library Functions
        let allSongs = [];
        
        async function loadSongs() {
            const songsList = document.getElementById('songsList');
            songsList.innerHTML = '<div class="loading">Loading songs...</div>';

            // Always load from curated-library-rhythmic.json (flat array)
            try {
                const response = await fetch('library-builder/output/curated-library-rhythmic.json');
                if (!response.ok) throw new Error('Failed to load song library');
                const json = await response.json();
                allSongs = (Array.isArray(json) ? json : []).map((song, idx) => ({ id: song.id || idx, ...song }));
                window._allSongsRaw = allSongs; // for category filtering
                console.log('Loaded', allSongs.length, 'songs from curated-library-rhythmic.json');
                console.log('First 5 songs:', allSongs.slice(0, 5));
                populateFilters();
                setupFilterListeners();
                filterSongs();
            } catch (error) {
                console.error('Error loading song library:', error);
                songsList.innerHTML = '<div class="loading">Error loading song library: ' + error.message + '</div>';
            }
            return;

            // Otherwise, use Firebase as before
            try {
                const songsQuery = await db.collection('library_songs').get();
                allSongs = songsQuery.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                })).sort((a, b) => {
                    const artistCompare = (a.artist || '').localeCompare(b.artist || '');
                    if (artistCompare !== 0) return artistCompare;
                    return (a.title || '').localeCompare(b.title || '');
                });
                console.log('Loaded', allSongs.length, 'songs from Firebase');
                populateFilters();
                setupFilterListeners();
                filterSongs();
            } catch (error) {
                console.error('Error loading songs:', error);
                songsList.innerHTML = '<div class="loading">Error loading songs: ' + error.message + '</div>';
            }
        }
        
        function populateFilters() {
            // Populate genre filter
            const genres = [...new Set(allSongs.map(s => s.genre).filter(g => g && g !== 'Unknown'))].sort();
            const genreFilter = document.getElementById('genreFilter');
            genres.forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                genreFilter.appendChild(option);
            });
            
            // Populate key filter
            const keys = [...new Set(allSongs.map(s => s.key).filter(k => k))].sort();
            const keyFilter = document.getElementById('keyFilter');
            keys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                keyFilter.appendChild(option);
            });
        }
        
        function setupFilterListeners() {
            document.getElementById('songSearchInput').addEventListener('input', filterSongs);
            document.getElementById('genreFilter').addEventListener('change', filterSongs);
            document.getElementById('difficultyFilter').addEventListener('change', filterSongs);
            document.getElementById('keyFilter').addEventListener('change', filterSongs);
        }
        
        function filterSongs() {
            const searchTerm = document.getElementById('songSearchInput').value.toLowerCase();
            const selectedGenre = document.getElementById('genreFilter').value;
            const selectedDifficulty = document.getElementById('difficultyFilter').value;
            const selectedKey = document.getElementById('keyFilter').value;
            
            const filtered = allSongs.filter(song => {
                const matchesSearch = !searchTerm || 
                    song.title?.toLowerCase().includes(searchTerm) ||
                    song.artist?.toLowerCase().includes(searchTerm);
                    
                const matchesGenre = selectedGenre === 'all' || song.genre === selectedGenre;
                const matchesDifficulty = selectedDifficulty === 'all' || song.difficulty === selectedDifficulty;
                const matchesKey = selectedKey === 'all' || song.key === selectedKey;
                
                return matchesSearch && matchesGenre && matchesDifficulty && matchesKey;
            });
            
            renderSongs(filtered);
        }
        
        function renderSongs(songs) {
            const songsList = document.getElementById('songsList');
            
            if (songs.length === 0) {
                songsList.innerHTML = '<div class="loading">No songs match your filters</div>';
                return;
            }
            console.log('Rendering', songs.length, 'songs:', songs.slice(0, 5));
            songsList.innerHTML = '';
            songs.forEach(song => {
                const card = document.createElement('div');
                card.className = 'song-card';
                card.innerHTML = `
                    <h3 class="song-title">${song.title}</h3>
                    <p class="song-artist">${song.artist}</p>
                    <div class="song-details">
                        ${song.genre && song.genre !== 'Unknown' ? `<span class="song-badge genre">${song.genre}</span>` : ''}
                        ${song.key ? `<span class="song-badge key">Key: ${song.key}</span>` : ''}
                        ${song.tempo ? `<span class="song-badge tempo">${song.tempo} BPM</span>` : ''}
                        ${song.difficulty ? `<span class="song-badge difficulty ${song.difficulty.toLowerCase()}">${song.difficulty}</span>` : ''}
                    </div>
                `;
                card.onclick = () => loadSongIntoVisualizer(song);
                songsList.appendChild(card);
            });
        }
        
        // Normalize key notation from ASCII to Unicode
        function normalizeKey(key) {
            if (!key) return 'C';
            
            console.log('🔑 normalizeKey - Input:', key, 'Type:', typeof key);
            
            // Handle already normalized keys
            if (key.includes('♯') || key.includes('♭')) {
                console.log('🔑 normalizeKey - Already normalized:', key);
                return key;
            }
            
            // Mapping table for ASCII to Unicode conversion
            const keyMap = {
                // Major keys with sharps
                'F#': 'F♯/G♭',
                'C#': 'C♯',
                'G#': 'G♯',
                'D#': 'D♯',
                'A#': 'A♯',
                'E#': 'E♯',
                'B#': 'B♯',
                
                // Major keys with flats
                'Bb': 'B♭',
                'Eb': 'E♭',
                'Ab': 'A♭',
                'Db': 'D♭',
                'Gb': 'G♭',
                'Cb': 'C♭',
                'Fb': 'F♭',
                
                // Minor keys with sharps
                'F#m': 'F♯m',
                'C#m': 'C♯m',
                'G#m': 'G♯m',
                'D#m': 'D♯m/E♭m',
                'A#m': 'A♯m',
                'E#m': 'E♯m',
                'B#m': 'B♯m',
                
                // Minor keys with flats
                'Bbm': 'B♭m',
                'Ebm': 'E♭m',
                'Abm': 'A♭m',
                'Dbm': 'D♭m',
                'Gbm': 'G♭m',
                'Cbm': 'C♭m',
                'Fbm': 'F♭m',
                
                // Natural keys (no accidentals)
                'C': 'C',
                'D': 'D',
                'E': 'E',
                'F': 'F',
                'G': 'G',
                'A': 'A',
                'B': 'B',
                'Am': 'Am',
                'Bm': 'Bm',
                'Cm': 'Cm',
                'Dm': 'Dm',
                'Em': 'Em',
                'Fm': 'Fm',
                'Gm': 'Gm'
            };
            
            const normalized = keyMap[key] || key;
            console.log('🔑 normalizeKey - Mapped:', key, '→', normalized);
            
            // Verify the normalized key exists in musicalKeys
            if (!musicalKeys[normalized]) {
                console.warn('⚠️ normalizeKey - Normalized key not found in musicalKeys:', normalized);
                console.log('🔑 Available keys:', Object.keys(musicalKeys));
                // Default to C if key not found
                return 'C';
            }
            
            return normalized;
        }
        
        // Update time signature from dropdowns
        function updateTimeSignature() {
            const numerator = document.getElementById('timeSignatureNumerator').value;
            const denominator = document.getElementById('timeSignatureDenominator').value;
            const timeSignature = `${numerator}/${denominator}`;
            document.getElementById('timeSignature').value = timeSignature;
            console.log('⏱️  Time signature updated to:', timeSignature);
        }
        
        // Update subdivision for current measure (manual user change)
        function updateMeasureSubdivision() {
            if (!progressionActive || selectedMeasureIndex === null) return;
            
            const subdivision = document.getElementById('measureSubdivision').value;
            console.log(`🎵 User manually changed subdivision to: ${subdivision}`);
            
            // Just store the user's choice - we'll handle it when they add the next chord
            // This allows workflow: half note chord → change to quarter → add quarter chord → add quarter chord
        }
        
        // Calculate remaining duration in measure and auto-set subdivision dropdown
        function calculateRemainingDuration(measureIndex) {
            console.log(`🔍 calculateRemainingDuration called for measure ${measureIndex}`);
            const measure = progressionMeasures[measureIndex];
            if (!measure) {
                console.log('⚠️ No measure found, returning "whole"');
                return 'whole';
            }
            
            const timeSignature = measure.timeSignature || '4/4';
            const [numerator, denominator] = timeSignature.split('/').map(Number);
            const beatsPerMeasure = (numerator / denominator) * 4; // Normalize to quarter notes
            console.log(`⏱️  Time: ${timeSignature}, Beats per measure: ${beatsPerMeasure}`);
            
            const subdivisionDurations = {
                'whole': 4,
                'half': 2,
                'dotted-half': 3,
                'quarter': 1,
                'dotted-quarter': 1.5,
                'eighth': 0.5,
                'dotted-eighth': 0.75
            };
            
            // Calculate used beats
            let usedBeats = 0;
            if (measure.chords && measure.chords.length > 0) {
                console.log(`📊 Analyzing ${measure.chords.length} chord slots:`);
                measure.chords.forEach((slot, i) => {
                    if (slot.chord) {
                        const beats = subdivisionDurations[slot.duration] || 0;
                        console.log(`   Slot ${i}: ${slot.chord.symbol} (${slot.duration}) = ${beats} beats`);
                        usedBeats += beats;
                    }
                });
            } else {
                console.log('📊 No chords in measure yet');
            }
            
            const remainingBeats = beatsPerMeasure - usedBeats;
            console.log(`📊 Measure ${measureIndex}: ${usedBeats}/${beatsPerMeasure} beats used, ${remainingBeats} remaining`);
            
            // Find best subdivision for remaining beats
            const options = [
                { name: 'whole', beats: 4 },
                { name: 'dotted-half', beats: 3 },
                { name: 'half', beats: 2 },
                { name: 'dotted-quarter', beats: 1.5 },
                { name: 'quarter', beats: 1 },
                { name: 'dotted-eighth', beats: 0.75 },
                { name: 'eighth', beats: 0.5 }
            ];
            
            // Find exact match first
            for (const opt of options) {
                if (opt.beats === remainingBeats) {
                    console.log(`✅ Exact match found: ${opt.name} (${opt.beats} beats)`);
                    return opt.name;
                }
            }
            
            // Find largest subdivision that fits
            for (const opt of options) {
                if (opt.beats <= remainingBeats) {
                    console.log(`✅ Best fit found: ${opt.name} (${opt.beats} beats fits in ${remainingBeats})`);
                    return opt.name;
                }
            }
            
            console.log('⚠️ Fallback to eighth note');
            return 'eighth'; // Smallest fallback
        }
        
        // Generate section tabs from song sections
        function generateSectionTabs(sections) {
            const sectionTabsContainer = document.getElementById('sectionTabsContainer');
            const sectionTabs = document.getElementById('sectionTabs');
            sectionTabs.innerHTML = '';
            
            if (!sections || sections.length === 0) {
                sectionTabsContainer.classList.remove('active');
                return;
            }
            
            let measureOffset = 0;
            sections.forEach((section, index) => {
                const tab = document.createElement('button');
                tab.className = 'section-tab' + (index === 0 ? ' active' : '');
                tab.textContent = `${section.name} (${section.bars || section.measures?.length || 0})`;
                tab.onclick = () => jumpToSection(index, measureOffset);
                sectionTabs.appendChild(tab);
                
                measureOffset += section.measures?.length || 0;
            });
            
            sectionTabsContainer.classList.add('active');
            console.log('📑 Generated', sections.length, 'section tabs');
        }
        
        // Jump to a specific section
        function jumpToSection(sectionIndex, measureIndex) {
            // Update active tab
            document.querySelectorAll('.section-tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === sectionIndex);
            });
            
            // Scroll to measure
            selectedMeasureIndex = measureIndex;
            const measureEl = document.getElementById(`staff-measure-${measureIndex}`);
            if (measureEl) {
                measureEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                updateProgressionChart();
            }
            
            console.log('🎯 Jumped to section', sectionIndex, 'at measure', measureIndex);
        }
        
        function loadSongIntoVisualizer(song) {
            console.log('========================================');
            console.log('📖 LOADING SONG INTO VISUALIZER');
            console.log('========================================');
            console.log('📖 Song:', song.title, 'by', song.artist);
            console.log('📖 Song key from JSON:', song.key);
            console.log('📖 Song sections:', song.sections ? song.sections.length : 'NONE');
            song.sections?.forEach((section, idx) => {
                console.log(`📖 Section ${idx}:`, section.name, 'bars:', section.bars, 'measures:', section.measures?.length);
            });
            if (song.sections?.[0]?.measures) {
                console.log('📖 First measure data:', JSON.stringify(song.sections[0].measures[0], null, 2));
            }
            // Force progressionActive and tab rendering
            progressionActive = true;
            // Set currentSong and render tabs
            currentSong = song;
            renderSectionTabs();
            updateSongTitleDisplay();
            
            // Close the browse modal
            closeBrowseLibrary();
            
            // Set key and scale with normalization
            const rawKey = song.key || 'C';
            selectedKey = normalizeKey(rawKey);
            console.log('📖 Normalized key:', rawKey, '→', selectedKey);
            
            selectedScale = 'major'; // Most songs are in major, could enhance this later
            selectScale(selectedScale);
            selectKey(selectedKey, true);
            
            progressionKey = selectedKey;
            const progressionKeySelect = document.getElementById('progressionKey');
            if (progressionKeySelect) {
                progressionKeySelect.value = selectedKey;
            }
            
            // Set tempo
            document.getElementById('tempo').value = song.tempo || 120;
            
            // Set time signature dropdowns
            const [numerator, denominator] = (song.timeSignature || '4/4').split('/');
            const numSelect = document.getElementById('timeSignatureNumerator');
            const denomSelect = document.getElementById('timeSignatureDenominator');
            if (numSelect && denomSelect) {
                numSelect.value = numerator;
                denomSelect.value = denominator;
                document.getElementById('timeSignature').value = song.timeSignature || '4/4';
                console.log('⏱️  Set time signature to:', song.timeSignature);
            }
            
            // Create currentSong object with sections
            currentSong = {
                title: song.title || 'Untitled',
                artist: song.artist || 'Unknown Artist',
                sections: song.sections.map(section => {
                    console.log('📖 Processing section:', section.name, 'measures:', section.measures?.length);
                    return {
                        id: section.id || `section-${Math.random().toString(36).substr(2, 9)}`,
                        name: section.name,
                        bars: section.measures.length,
                        key: section.key || song.key,
                        timeSignature: section.timeSignature || song.timeSignature || '4/4',
                        repeat: section.repeat || false,
                        measures: section.measures.map((m, mIdx) => {
                            console.log(`📖 Processing measure ${mIdx}:`, JSON.stringify(m, null, 2));
                            
                            // Handle subdivided format (chords array with durations)
                            if (m.chords && Array.isArray(m.chords)) {
                                console.log(`📖 Measure ${mIdx} has subdivided chords:`, m.chords.length, 'chords');
                                const transformedChords = m.chords.map((chordSlot, slotIdx) => {
                                    console.log(`  📖 Processing chord slot ${slotIdx}:`, chordSlot);
                                    const chordSymbol = chordSlot.symbol;
                                    if (!chordSymbol) {
                                        console.warn(`⚠️ No symbol in chord slot ${slotIdx} of measure ${mIdx}`);
                                        return null;
                                    }
                                    const rootNote = extractRootNote(chordSymbol);
                                    if (!rootNote) {
                                        console.warn(`⚠️ Could not extract root from ${chordSymbol}`);
                                        return null;
                                    }
                                    const chordNotes = parseChordSymbol(chordSymbol, rootNote);
                                    console.log(`  🎵 Transformed: ${chordSymbol} → root: ${rootNote}, notes:`, chordNotes);
                                    return {
                                        chord: {
                                            symbol: chordSymbol,
                                            root: rootNote,
                                            notes: chordNotes || [],
                                            isCustom: false
                                        },
                                        duration: chordSlot.duration || 'whole',
                                        romanNumeral: '' // Will be calculated later
                                    };
                                }).filter(slot => slot !== null);
                                
                                console.log(`  ✅ Measure ${mIdx} transformed chords:`, transformedChords.length, 'chords');
                                return {
                                    chord: null, // Legacy field
                                    chords: transformedChords,
                                    localKey: m.localKey || section.key || song.key,
                                    timeSignature: m.timeSignature || section.timeSignature || song.timeSignature || '4/4'
                                };
                            }
                            
                            // Handle traditional format (single chord per measure)
                            if (!m.chord || !m.chord.symbol) {
                                // No chord in this measure
                                return {
                                    chord: null,
                                    localKey: m.localKey || section.key || song.key,
                                    timeSignature: m.timeSignature || section.timeSignature || song.timeSignature || '4/4'
                                };
                            }
                            
                            const chordSymbol = m.chord.symbol;
                            const rootNote = extractRootNote(chordSymbol);
                            
                            // Generate notes if not present
                            let chordNotes = m.chord.notes;
                            if (!chordNotes || chordNotes.length === 0) {
                                chordNotes = parseChordSymbol(chordSymbol, rootNote);
                                console.log('🎵 Generated notes for chord:', chordSymbol, '→', chordNotes);
                            }
                            
                            // Ensure we have valid notes
                            if (!chordNotes || chordNotes.length === 0) {
                                console.error('❌ Failed to generate notes for chord:', chordSymbol);
                                chordNotes = [rootNote]; // Fallback to just root note
                            }
                            
                            const parsedChord = {
                                symbol: chordSymbol,
                                root: rootNote,
                                notes: chordNotes,
                                isCustom: false
                            };
                            
                            console.log('🎵 Parsed traditional chord:', chordSymbol, '→ root:', rootNote, 'notes:', parsedChord.notes);
                            
                            return {
                                chord: parsedChord,
                                localKey: m.localKey || section.key || song.key,
                                timeSignature: m.timeSignature || section.timeSignature || song.timeSignature || '4/4'
                            };
                        })
                    };
                }),
                currentSectionIndex: 0
            };
            
            // Enable progression mode to show section tabs
            progressionActive = true;
            
            // Sync to progressionMeasures (first section only)
            syncProgressionMeasures();
            
            // Show staff container
            const staffContainer = document.getElementById('staffContainer');
            staffContainer.classList.add('active');
            
            // Update song title display
            updateSongTitleDisplay();
            
            // Show and render section tabs
            renderSectionTabs();
            
            // Generate staff UI for first section only
            const firstSection = currentSong.sections[0];
            const timeSignature = firstSection.timeSignature || song.timeSignature || '4/4';
            const repeatCount = firstSection.repeat || 1;
            const totalBars = firstSection.bars * repeatCount;
            console.log('🎼 Generating staff for first section with', firstSection.bars, 'measures x', repeatCount, 'repeats =', totalBars, 'total bars, time signature:', timeSignature);
            generateStaffMeasures(totalBars, timeSignature);
            
            console.log('✅ Song loaded successfully!');
            console.log('🎯 Current state - Key:', selectedKey, 'Scale:', selectedScale);
            console.log('🎯 Current song sections:', currentSong.sections.length);
            console.log('🎯 First section measures:', currentSong.sections[0].measures.length);
            console.log('🎯 First measure:', JSON.stringify(currentSong.sections[0].measures[0], null, 2));
            
            // DEBUG: Check if measures have chords
            console.log('🔍 CHORD CHECK - First measure has chords array:', !!currentSong.sections[0].measures[0].chords);
            if (currentSong.sections[0].measures[0].chords) {
                console.log('🔍 First measure chords count:', currentSong.sections[0].measures[0].chords.length);
                console.log('🔍 First chord in array:', JSON.stringify(currentSong.sections[0].measures[0].chords[0], null, 2));
            }
            
            // CRITICAL: Use setTimeout to ensure DOM is ready before updating chart
            setTimeout(() => {
                console.log('🎨 Calling updateProgressionChart (after DOM ready)...');
                console.log('📊 progressionMeasures:', progressionMeasures.length, 'measures');
                console.log('📊 First measure data:', JSON.stringify(progressionMeasures[0], null, 2));
                console.log('📊 First progressionMeasure has chords:', !!progressionMeasures[0]?.chords);
                if (progressionMeasures[0]?.chords) {
                    console.log('📊 First progressionMeasure chords count:', progressionMeasures[0].chords.length);
                }
                
                updateProgressionChart();
                
                // Auto-select first chord and display it
                if (currentSong.sections[0].measures[0]) {
                    const firstMeasure = currentSong.sections[0].measures[0];
                    console.log('🎸 First measure:', firstMeasure);
                    
                    if (firstMeasure.chord) {
                        selectedChord = firstMeasure.chord;
                        selectedMeasureIndex = 0;
                        console.log('🎸 Auto-selected first chord:', selectedChord.symbol);
                        console.log('🎸 Chord notes:', selectedChord.notes);
                        
                        // Update fretboard to show the chord
                        updateFretboard();
                    } else {
                        console.log('⚠️ First measure has no chord');
                        updateFretboard();
                    }
                } else {
                    console.log('⚠️ No first measure found');
                    updateFretboard();
                }
            }, 200); // Give DOM time to settle
        }
        
        async function loadLibraryProgression(progressionId) {
            try {
                console.log('Loading library progression:', progressionId);
                const doc = await db.collection('library_progressions').doc(progressionId).get();
                
                if (!doc.exists) {
                    alert('Progression not found');
                    return;
                }
                
                const data = doc.data();
                console.log('Library progression data:', data);
                
                // Set both scale and key first (before calling update functions)
                selectedScale = data.scale || 'major';
                selectedKey = data.key;
                
                // Now update the UI with both values set
                console.log('Calling selectScale with:', selectedScale);
                selectScale(selectedScale); // This updates the scale UI
                console.log('Calling selectKey with:', selectedKey, 'force: true');
                selectKey(selectedKey, true); // This updates the key UI and fretboard
                console.log('Key and scale set, Circle of Fifths should be highlighted');
                
                // Also update progression key variable and dropdown explicitly
                progressionKey = data.key;
                const progressionKeySelect = document.getElementById('progressionKey');
                if (progressionKeySelect) {
                    progressionKeySelect.value = data.key;
                    console.log('Set progression dropdown to:', data.key);
                }
                
                // Set tempo
                document.getElementById('tempo').value = data.tempo || 120;
                
                // Load measures (handle both old format and new format with localKey)
                progressionMeasures = (data.measures || []).map(m => {
                    if (m.symbol || (m.chord && m.chord.symbol)) {
                        return {
                            chord: m.chord || { symbol: m.symbol, notes: m.notes },
                            localKey: m.localKey || data.key,
                            timeSignature: m.timeSignature || data.timeSignature || '4/4'
                        };
                    } else {
                        return {
                            chord: null,
                            localKey: m.localKey || data.key,
                            timeSignature: m.timeSignature || data.timeSignature || '4/4'
                        };
                    }
                });
                
                // Activate progression mode
                progressionActive = true;
                selectedMeasureIndex = 0;
                
                // Show staff container
                const staffContainer = document.getElementById('staffContainer');
                staffContainer.classList.add('active');
                
                // Generate staff UI
                const measureCount = progressionMeasures.length;
                const timeSignature = data.timeSignature || '4/4';
                console.log('Generating staff with', measureCount, 'measures');
                generateStaffMeasures(measureCount, timeSignature);
                
                // Update UI
                console.log('Updating progression chart');
                updateProgressionChart();
                
                // Close modal
                closeBrowseLibrary();
                
                console.log('Library progression loaded successfully');
            } catch (error) {
                console.error('Error loading library progression:', error);
                alert('Error loading progression: ' + error.message);
            }
        }
        
        // Add tab switching event listeners
        window.addEventListener('load', () => {
            const tabs = document.querySelectorAll('.tab-btn');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    loadCollections(tab.dataset.collection);
                });
            });
        });

        // ===== ORIGINAL JAVASCRIPT CONTINUES BELOW =====
        
        // Musical symbols using Unicode and font-specific characters
        const MUSIC_SYMBOLS = {
            TREBLE_CLEF: '\uD834\uDD1E', // 𝄞
            SHARP: '\u266F', // ♯
            FLAT: '\u266D', // ♭
            NATURAL: '\u266E', // ♮
            QUARTER_NOTE: '\u2669', // ♩
            EIGHTH_NOTE: '\u266A', // ♪
            DOUBLE_BAR: '\uD834\uDD01', // 𝄁
        };

        // Key signature mappings
        const KEY_SIGNATURES = {
            'C': { sharps: [], flats: [], display: '' },
            'G': { sharps: ['F'], flats: [], display: '♯' },
            'D': { sharps: ['F', 'C'], flats: [], display: '♯♯' },
            'A': { sharps: ['F', 'C', 'G'], flats: [], display: '♯♯♯' },
            'E': { sharps: ['F', 'C', 'G', 'D'], flats: [], display: '♯♯♯♯' },
            'B': { sharps: ['F', 'C', 'G', 'D', 'A'], flats: [], display: '♯♯♯♯♯' },
            'F♯/G♭': { sharps: ['F', 'C', 'G', 'D', 'A', 'E'], flats: [], display: '♯♯♯♯♯♯' },
            'F': { sharps: [], flats: ['B'], display: '♭' },
            'B♭': { sharps: [], flats: ['B', 'E'], display: '♭♭' },
            'E♭': { sharps: [], flats: ['B', 'E', 'A'], display: '♭♭♭' },
            'A♭': { sharps: [], flats: ['B', 'E', 'A', 'D'], display: '♭♭♭♭' },
            'D♭': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G'], display: '♭♭♭♭♭' },
            
            // Minor keys
            'Am': { sharps: [], flats: [], display: '' },
            'Em': { sharps: ['F'], flats: [], display: '♯' },
            'Bm': { sharps: ['F', 'C'], flats: [], display: '♯♯' },
            'F♯m': { sharps: ['F', 'C', 'G'], flats: [], display: '♯♯♯' },
            'C♯m': { sharps: ['F', 'C', 'G', 'D'], flats: [], display: '♯♯♯♯' },
            'G♯m': { sharps: ['F', 'C', 'G', 'D', 'A'], flats: [], display: '♯♯♯♯♯' },
            'D♯m/E♭m': { sharps: ['F', 'C', 'G', 'D', 'A', 'E'], flats: [], display: '♯♯♯♯♯♯' },
            'Dm': { sharps: [], flats: ['B'], display: '♭' },
            'Gm': { sharps: [], flats: ['B', 'E'], display: '♭♭' },
            'Cm': { sharps: [], flats: ['B', 'E', 'A'], display: '♭♭♭' },
            'Fm': { sharps: [], flats: ['B', 'E', 'A', 'D'], display: '♭♭♭♭' },
            'B♭m': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G'], display: '♭♭♭♭♭' }
        };

        // Get current key data (handles both predefined keys and generated scales)
        function getCurrentKeyData() {
            console.log('getCurrentKeyData called with selectedKey:', selectedKey, 'selectedScale:', selectedScale);
            
            // Handle chromatic scale
            if (selectedScale === 'chromatic' || !selectedKey) {
                return {
                    scale: ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'],
                    signature: 'All 12 notes',
                    triads: [],
                    sevenths: []
                };
            }
            
            // Check if we're using original key data or need to generate scale data
            console.log('🎵 getCurrentKeyData - selectedKey:', selectedKey, 'selectedScale:', selectedScale);
            console.log('🎵 getCurrentKeyData - Key includes m?', selectedKey.includes('m'));
            console.log('🎵 getCurrentKeyData - Scale:', selectedScale);
            
            if ((selectedScale === 'major' && !selectedKey.includes('m')) || 
                (selectedScale === 'minor' && selectedKey.includes('m'))) {
                // Use original key data for standard major/minor
                console.log('🎵 getCurrentKeyData - Using predefined key data for:', selectedKey);
                const keyData = musicalKeys[selectedKey];
                console.log('🎵 getCurrentKeyData - Key lookup result:', selectedKey, '→', keyData ? '✓ FOUND' : '✗ NOT FOUND');
                
                if (!keyData) {
                    console.error('❌ Key data not found for:', selectedKey);
                    console.log('📋 Available keys:', Object.keys(musicalKeys));
                    console.log('💡 Falling back to generated scale data');
                    // If no predefined key data, generate it
                    return getCurrentScaleData();
                }
                
                console.log('✅ Using key data:', keyData.scale, 'Signature:', keyData.signature);
                return keyData;
            } else {
                // Generate scale data for other scales
                console.log('🎵 getCurrentKeyData - Generating scale data for non-standard scale');
                return getCurrentScaleData();
            }
        }

        // Musical data with proper sharp and flat symbols
        const musicalKeys = {
            'C': { 
                scale: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
                signature: 'No sharps or flats',
                triads: [
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['1', '3', '5'] },
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['2', '4', '6'] },
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['3', '5', '7'] },
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['4', '6', '1'] },
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['5', '7', '2'] },
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['6', '1', '3'] },
                    { symbol: 'B°', notes: ['B', 'D', 'F'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'G7', notes: ['G', 'B', 'D', 'F'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Bm7♭5', notes: ['B', 'D', 'F', 'A'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'G': { 
                scale: ['G', 'A', 'B', 'C', 'D', 'E', 'F♯'],
                signature: '1 sharp (F♯)',
                triads: [
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['1', '3', '5'] },
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['2', '4', '6'] },
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['4', '6', '1'] },
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['5', '7', '2'] },
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['6', '1', '3'] },
                    { symbol: 'F♯°', notes: ['F♯', 'A', 'C'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'D7', notes: ['D', 'F♯', 'A', 'C'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'F♯m7♭5', notes: ['F♯', 'A', 'C', 'E'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'D': { 
                scale: ['D', 'E', 'F♯', 'G', 'A', 'B', 'C♯'],
                signature: '2 sharps (F♯, C♯)',
                triads: [
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['1', '3', '5'] },
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['2', '4', '6'] },
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['4', '6', '1'] },
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['5', '7', '2'] },
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['6', '1', '3'] },
                    { symbol: 'C♯°', notes: ['C♯', 'E', 'G'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'A7', notes: ['A', 'C♯', 'E', 'G'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'C♯m7♭5', notes: ['C♯', 'E', 'G', 'B'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'A': { 
                scale: ['A', 'B', 'C♯', 'D', 'E', 'F♯', 'G♯'],
                signature: '3 sharps (F♯, C♯, G♯)',
                triads: [
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['1', '3', '5'] },
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['2', '4', '6'] },
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['4', '6', '1'] },
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['5', '7', '2'] },
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['6', '1', '3'] },
                    { symbol: 'G♯°', notes: ['G♯', 'B', 'D'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'E7', notes: ['E', 'G♯', 'B', 'D'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'G♯m7♭5', notes: ['G♯', 'B', 'D', 'F♯'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'E': { 
                scale: ['E', 'F♯', 'G♯', 'A', 'B', 'C♯', 'D♯'],
                signature: '4 sharps (F♯, C♯, G♯, D♯)',
                triads: [
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['1', '3', '5'] },
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['2', '4', '6'] },
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['4', '6', '1'] },
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['5', '7', '2'] },
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['6', '1', '3'] },
                    { symbol: 'D♯°', notes: ['D♯', 'F♯', 'A'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'B7', notes: ['B', 'D♯', 'F♯', 'A'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'D♯m7♭5', notes: ['D♯', 'F♯', 'A', 'C♯'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'B': { 
                scale: ['B', 'C♯', 'D♯', 'E', 'F♯', 'G♯', 'A♯'],
                signature: '5 sharps (F♯, C♯, G♯, D♯, A♯)',
                triads: [
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['1', '3', '5'] },
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['2', '4', '6'] },
                    { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['4', '6', '1'] },
                    { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['5', '7', '2'] },
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['6', '1', '3'] },
                    { symbol: 'A♯°', notes: ['A♯', 'C♯', 'E'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'F♯7', notes: ['F♯', 'A♯', 'C♯', 'E'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'A♯m7♭5', notes: ['A♯', 'C♯', 'E', 'G♯'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'F♯/G♭': { 
                scale: ['F♯', 'G♯', 'A♯', 'B', 'C♯', 'D♯', 'E♯'],
                signature: '6 sharps/6 flats',
                triads: [
                    { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['1', '3', '5'] },
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['2', '4', '6'] },
                    { symbol: 'A♯m', notes: ['A♯', 'C♯', 'E♯'], degrees: ['3', '5', '7'] },
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['4', '6', '1'] },
                    { symbol: 'C♯', notes: ['C♯', 'E♯', 'G♯'], degrees: ['5', '7', '2'] },
                    { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['6', '1', '3'] },
                    { symbol: 'E♯°', notes: ['E♯', 'G♯', 'B'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'F♯maj7', notes: ['F♯', 'A♯', 'C♯', 'E♯'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'A♯m7', notes: ['A♯', 'C♯', 'E♯', 'G♯'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'C♯7', notes: ['C♯', 'E♯', 'G♯', 'B'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'E♯m7♭5', notes: ['E♯', 'G♯', 'B', 'D♯'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'D♭': { 
                scale: ['D♭', 'E♭', 'F', 'G♭', 'A♭', 'B♭', 'C'],
                signature: '5 flats (B♭, E♭, A♭, D♭, G♭)',
                triads: [
                    { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['1', '3', '5'] },
                    { symbol: 'E♭m', notes: ['E♭', 'G♭', 'B♭'], degrees: ['2', '4', '6'] },
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['3', '5', '7'] },
                    { symbol: 'G♭', notes: ['G♭', 'B♭', 'D♭'], degrees: ['4', '6', '1'] },
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['5', '7', '2'] },
                    { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['6', '1', '3'] },
                    { symbol: 'C°', notes: ['C', 'E♭', 'G♭'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'E♭m7', notes: ['E♭', 'G♭', 'B♭', 'D♭'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'G♭maj7', notes: ['G♭', 'B♭', 'D♭', 'F'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'A♭7', notes: ['A♭', 'C', 'E♭', 'G♭'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Cm7♭5', notes: ['C', 'E♭', 'G♭', 'B♭'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'A♭': { 
                scale: ['A♭', 'B♭', 'C', 'D♭', 'E♭', 'F', 'G'],
                signature: '4 flats (B♭, E♭, A♭, D♭)',
                triads: [
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['1', '3', '5'] },
                    { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['2', '4', '6'] },
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['3', '5', '7'] },
                    { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['4', '6', '1'] },
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['5', '7', '2'] },
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['6', '1', '3'] },
                    { symbol: 'G°', notes: ['G', 'B♭', 'D♭'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'E♭7', notes: ['E♭', 'G', 'B♭', 'D♭'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Gm7♭5', notes: ['G', 'B♭', 'D♭', 'F'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'E♭': { 
                scale: ['E♭', 'F', 'G', 'A♭', 'B♭', 'C', 'D'],
                signature: '3 flats (B♭, E♭, A♭)',
                triads: [
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['1', '3', '5'] },
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['2', '4', '6'] },
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['3', '5', '7'] },
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['4', '6', '1'] },
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['5', '7', '2'] },
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['6', '1', '3'] },
                    { symbol: 'D°', notes: ['D', 'F', 'A♭'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'B♭7', notes: ['B♭', 'D', 'F', 'A♭'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Dm7♭5', notes: ['D', 'F', 'A♭', 'C'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'B♭': { 
                scale: ['B♭', 'C', 'D', 'E♭', 'F', 'G', 'A'],
                signature: '2 flats (B♭, E♭)',
                triads: [
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['1', '3', '5'] },
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['2', '4', '6'] },
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['3', '5', '7'] },
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['4', '6', '1'] },
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['5', '7', '2'] },
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['6', '1', '3'] },
                    { symbol: 'A°', notes: ['A', 'C', 'E♭'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'F7', notes: ['F', 'A', 'C', 'E♭'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Am7♭5', notes: ['A', 'C', 'E♭', 'G'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            'F': { 
                scale: ['F', 'G', 'A', 'B♭', 'C', 'D', 'E'],
                signature: '1 flat (B♭)',
                triads: [
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['1', '3', '5'] },
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['2', '4', '6'] },
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['3', '5', '7'] },
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['4', '6', '1'] },
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['5', '7', '2'] },
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['6', '1', '3'] },
                    { symbol: 'E°', notes: ['E', 'G', 'B♭'], degrees: ['7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['1', '3', '5', '7'] },
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['2', '4', '6', '1'] },
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['3', '5', '7', '2'] },
                    { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['4', '6', '1', '3'] },
                    { symbol: 'C7', notes: ['C', 'E', 'G', 'B♭'], degrees: ['5', '7', '2', '4'] },
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['6', '1', '3', '5'] },
                    { symbol: 'Em7♭5', notes: ['E', 'G', 'B♭', 'D'], degrees: ['7', '2', '4', '6'] }
                ]
            },
            
            // Minor keys
            'Am': { 
                scale: ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
                signature: 'No sharps or flats',
                triads: [
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'B°', notes: ['B', 'D', 'F'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Bm7♭5', notes: ['B', 'D', 'F', 'A'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'G7', notes: ['G', 'B', 'D', 'F'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Em': { 
                scale: ['E', 'F♯', 'G', 'A', 'B', 'C', 'D'],
                signature: '1 sharp (F♯)',
                triads: [
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'F♯°', notes: ['F♯', 'A', 'C'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'F♯m7♭5', notes: ['F♯', 'A', 'C', 'E'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'D7', notes: ['D', 'F♯', 'A', 'C'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Bm': { 
                scale: ['B', 'C♯', 'D', 'E', 'F♯', 'G', 'A'],
                signature: '2 sharps (F♯, C♯)',
                triads: [
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'C♯°', notes: ['C♯', 'E', 'G'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'C♯m7♭5', notes: ['C♯', 'E', 'G', 'B'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'A7', notes: ['A', 'C♯', 'E', 'G'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'F♯m': { 
                scale: ['F♯', 'G♯', 'A', 'B', 'C♯', 'D', 'E'],
                signature: '3 sharps (F♯, C♯, G♯)',
                triads: [
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'G♯°', notes: ['G♯', 'B', 'D'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'G♯m7♭5', notes: ['G♯', 'B', 'D', 'F♯'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'E7', notes: ['E', 'G♯', 'B', 'D'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'C♯m': { 
                scale: ['C♯', 'D♯', 'E', 'F♯', 'G♯', 'A', 'B'],
                signature: '4 sharps (F♯, C♯, G♯, D♯)',
                triads: [
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'D♯°', notes: ['D♯', 'F♯', 'A'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'D♯m7♭5', notes: ['D♯', 'F♯', 'A', 'C♯'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'B7', notes: ['B', 'D♯', 'F♯', 'A'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'G♯m': { 
                scale: ['G♯', 'A♯', 'B', 'C♯', 'D♯', 'E', 'F♯'],
                signature: '5 sharps (F♯, C♯, G♯, D♯, A♯)',
                triads: [
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'A♯°', notes: ['A♯', 'C♯', 'E'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'A♯m7♭5', notes: ['A♯', 'C♯', 'E', 'G♯'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'F♯7', notes: ['F♯', 'A♯', 'C♯', 'E'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'D♯m/E♭m': { 
                scale: ['D♯', 'E♯', 'F♯', 'G♯', 'A♯', 'B', 'C♯'],
                signature: '6 sharps/6 flats',
                triads: [
                    { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'E♯°', notes: ['E♯', 'G♯', 'B'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'A♯m', notes: ['A♯', 'C♯', 'E♯'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'C♯', notes: ['C♯', 'E♯', 'G♯'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'E♯m7♭5', notes: ['E♯', 'G♯', 'B', 'D♯'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'F♯maj7', notes: ['F♯', 'A♯', 'C♯', 'E♯'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'A♯m7', notes: ['A♯', 'C♯', 'E♯', 'G♯'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'C♯7', notes: ['C♯', 'E♯', 'G♯', 'B'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'B♭m': { 
                scale: ['B♭', 'C', 'D♭', 'E♭', 'F', 'G♭', 'A♭'],
                signature: '5 flats (B♭, E♭, A♭, D♭, G♭)',
                triads: [
                    { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'C°', notes: ['C', 'E♭', 'G♭'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'E♭m', notes: ['E♭', 'G♭', 'B♭'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'G♭', notes: ['G♭', 'B♭', 'D♭'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Cm7♭5', notes: ['C', 'E♭', 'G♭', 'B♭'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'E♭m7', notes: ['E♭', 'G♭', 'B♭', 'D♭'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'G♭maj7', notes: ['G♭', 'B♭', 'D♭', 'F'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'A♭7', notes: ['A♭', 'C', 'E♭', 'G♭'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Fm': { 
                scale: ['F', 'G', 'A♭', 'B♭', 'C', 'D♭', 'E♭'],
                signature: '4 flats (B♭, E♭, A♭, D♭)',
                triads: [
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'G°', notes: ['G', 'B♭', 'D♭'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Gm7♭5', notes: ['G', 'B♭', 'D♭', 'F'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'E♭7', notes: ['E♭', 'G', 'B♭', 'D♭'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Cm': { 
                scale: ['C', 'D', 'E♭', 'F', 'G', 'A♭', 'B♭'],
                signature: '3 flats (B♭, E♭, A♭)',
                triads: [
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'D°', notes: ['D', 'F', 'A♭'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Dm7♭5', notes: ['D', 'F', 'A♭', 'C'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'B♭7', notes: ['B♭', 'D', 'F', 'A♭'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Gm': { 
                scale: ['G', 'A', 'B♭', 'C', 'D', 'E♭', 'F'],
                signature: '2 flats (B♭, E♭)',
                triads: [
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'A°', notes: ['A', 'C', 'E♭'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Am7♭5', notes: ['A', 'C', 'E♭', 'G'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'F7', notes: ['F', 'A', 'C', 'E♭'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            },
            'Dm': { 
                scale: ['D', 'E', 'F', 'G', 'A', 'B♭', 'C'],
                signature: '1 flat (B♭)',
                triads: [
                    { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['1', '♭3', '5'] },
                    { symbol: 'E°', notes: ['E', 'G', 'B♭'], degrees: ['2', '4', '♭6'] },
                    { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['♭3', '5', '♭7'] },
                    { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['4', '♭6', '1'] },
                    { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['5', '♭7', '2'] },
                    { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['♭6', '1', '♭3'] },
                    { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['♭7', '2', '4'] }
                ],
                sevenths: [
                    { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['1', '♭3', '5', '♭7'] },
                    { symbol: 'Em7♭5', notes: ['E', 'G', 'B♭', 'D'], degrees: ['2', '4', '♭6', '1'] },
                    { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['♭3', '5', '♭7', '2'] },
                    { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['4', '♭6', '1', '♭3'] },
                    { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['5', '♭7', '2', '4'] },
                    { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['♭6', '1', '♭3', '5'] },
                    { symbol: 'C7', notes: ['C', 'E', 'G', 'B♭'], degrees: ['♭7', '2', '4', '♭6'] }
                ]
            }
        };

        // Key signature mappings for proper enharmonic spelling
        const keySignatures = {
            'C': { sharps: [], flats: [] },
            'G': { sharps: ['F'], flats: [] },
            'D': { sharps: ['F', 'C'], flats: [] },
            'A': { sharps: ['F', 'C', 'G'], flats: [] },
            'E': { sharps: ['F', 'C', 'G', 'D'], flats: [] },
            'B': { sharps: ['F', 'C', 'G', 'D', 'A'], flats: [] },
            'F♯/G♭': { sharps: ['F', 'C', 'G', 'D', 'A', 'E'], flats: [] },
            'F': { sharps: [], flats: ['B'] },
            'B♭': { sharps: [], flats: ['B', 'E'] },
            'E♭': { sharps: [], flats: ['B', 'E', 'A'] },
            'A♭': { sharps: [], flats: ['B', 'E', 'A', 'D'] },
            'D♭': { sharps: [], flats: ['B', 'E', 'A', 'D', 'G'] }
        };

        // All possible notes for tuning selection
        const allNotes = ['C', 'C♯/D♭', 'D', 'D♯/E♭', 'E', 'F', 'F♯/G♭', 'G', 'G♯/A♭', 'A', 'A♯/B♭', 'B'];

        // Add all remaining major keys to musicalKeys
        musicalKeys['G'] = { 
            scale: ['G', 'A', 'B', 'C', 'D', 'E', 'F♯'],
            signature: '1 sharp (F♯)',
            triads: [
                { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['1', '3', '5'] },
                { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['2', '4', '6'] },
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['3', '5', '7'] },
                { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['4', '6', '1'] },
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['5', '7', '2'] },
                { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['6', '1', '3'] },
                { symbol: 'F♯°', notes: ['F♯', 'A', 'C'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'D7', notes: ['D', 'F♯', 'A', 'C'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'F♯m7♭5', notes: ['F♯', 'A', 'C', 'E'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['D'] = { 
            scale: ['D', 'E', 'F♯', 'G', 'A', 'B', 'C♯'],
            signature: '2 sharps (F♯, C♯)',
            triads: [
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['1', '3', '5'] },
                { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['2', '4', '6'] },
                { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['3', '5', '7'] },
                { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['4', '6', '1'] },
                { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['5', '7', '2'] },
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['6', '1', '3'] },
                { symbol: 'C♯°', notes: ['C♯', 'E', 'G'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'A7', notes: ['A', 'C♯', 'E', 'G'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'C♯m7♭5', notes: ['C♯', 'E', 'G', 'B'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['F'] = { 
            scale: ['F', 'G', 'A', 'B♭', 'C', 'D', 'E'],
            signature: '1 flat (B♭)',
            triads: [
                { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['1', '3', '5'] },
                { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['2', '4', '6'] },
                { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['3', '5', '7'] },
                { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['4', '6', '1'] },
                { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['5', '7', '2'] },
                { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['6', '1', '3'] },
                { symbol: 'E°', notes: ['E', 'G', 'B♭'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'C7', notes: ['C', 'E', 'G', 'B♭'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'Em7♭5', notes: ['E', 'G', 'B♭', 'D'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        // Add all remaining major keys
        musicalKeys['A'] = { 
            scale: ['A', 'B', 'C♯', 'D', 'E', 'F♯', 'G♯'],
            signature: '3 sharps (F♯, C♯, G♯)',
            triads: [
                { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['1', '3', '5'] },
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['2', '4', '6'] },
                { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['3', '5', '7'] },
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['4', '6', '1'] },
                { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['5', '7', '2'] },
                { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['6', '1', '3'] },
                { symbol: 'G♯°', notes: ['G♯', 'B', 'D'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'E7', notes: ['E', 'G♯', 'B', 'D'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'G♯m7♭5', notes: ['G♯', 'B', 'D', 'F♯'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['E'] = { 
            scale: ['E', 'F♯', 'G♯', 'A', 'B', 'C♯', 'D♯'],
            signature: '4 sharps (F♯, C♯, G♯, D♯)',
            triads: [
                { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['1', '3', '5'] },
                { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['2', '4', '6'] },
                { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['3', '5', '7'] },
                { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['4', '6', '1'] },
                { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['5', '7', '2'] },
                { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['6', '1', '3'] },
                { symbol: 'D♯°', notes: ['D♯', 'F♯', 'A'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'B7', notes: ['B', 'D♯', 'F♯', 'A'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'D♯m7♭5', notes: ['D♯', 'F♯', 'A', 'C♯'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['B'] = { 
            scale: ['B', 'C♯', 'D♯', 'E', 'F♯', 'G♯', 'A♯'],
            signature: '5 sharps (F♯, C♯, G♯, D♯, A♯)',
            triads: [
                { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['1', '3', '5'] },
                { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['2', '4', '6'] },
                { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['3', '5', '7'] },
                { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['4', '6', '1'] },
                { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['5', '7', '2'] },
                { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['6', '1', '3'] },
                { symbol: 'A♯°', notes: ['A♯', 'C♯', 'E'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Emaj7', notes: ['E', 'G♯', 'B', 'D♯'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'F♯7', notes: ['F♯', 'A♯', 'C♯', 'E'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'A♯m7♭5', notes: ['A♯', 'C♯', 'E', 'G♯'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['B♭'] = { 
            scale: ['B♭', 'C', 'D', 'E♭', 'F', 'G', 'A'],
            signature: '2 flats (B♭, E♭)',
            triads: [
                { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['1', '3', '5'] },
                { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['2', '4', '6'] },
                { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['3', '5', '7'] },
                { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['4', '6', '1'] },
                { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['5', '7', '2'] },
                { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['6', '1', '3'] },
                { symbol: 'A°', notes: ['A', 'C', 'E♭'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'F7', notes: ['F', 'A', 'C', 'E♭'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'Am7♭5', notes: ['A', 'C', 'E♭', 'G'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        // Add Em and Dm minor keys
        musicalKeys['Em'] = { 
            scale: ['E', 'F♯', 'G', 'A', 'B', 'C', 'D'],
            signature: '1 sharp (F♯)',
            triads: [
                { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['1', '♭3', '5'] },
                { symbol: 'F♯°', notes: ['F♯', 'A', 'C'], degrees: ['2', '4', '♭6'] },
                { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['♭3', '5', '♭7'] },
                { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['4', '♭6', '1'] },
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['5', '♭7', '2'] },
                { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['♭6', '1', '♭3'] },
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['1', '♭3', '5', '♭7'] },
                { symbol: 'F♯m7♭5', notes: ['F♯', 'A', 'C', 'E'], degrees: ['2', '4', '♭6', '1'] },
                { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['♭3', '5', '♭7', '2'] },
                { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['4', '♭6', '1', '♭3'] },
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['5', '♭7', '2', '4'] },
                { symbol: 'Cmaj7', notes: ['C', 'E', 'G', 'B'], degrees: ['♭6', '1', '♭3', '5'] },
                { symbol: 'D7', notes: ['D', 'F♯', 'A', 'C'], degrees: ['♭7', '2', '4', '♭6'] }
            ]
        };

        musicalKeys['Dm'] = { 
            scale: ['D', 'E', 'F', 'G', 'A', 'B♭', 'C'],
            signature: '1 flat (B♭)',
            triads: [
                { symbol: 'Dm', notes: ['D', 'F', 'A'], degrees: ['1', '♭3', '5'] },
                { symbol: 'E°', notes: ['E', 'G', 'B♭'], degrees: ['2', '4', '♭6'] },
                { symbol: 'F', notes: ['F', 'A', 'C'], degrees: ['♭3', '5', '♭7'] },
                { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['4', '♭6', '1'] },
                { symbol: 'Am', notes: ['A', 'C', 'E'], degrees: ['5', '♭7', '2'] },
                { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['♭6', '1', '♭3'] },
                { symbol: 'C', notes: ['C', 'E', 'G'], degrees: ['♭7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Dm7', notes: ['D', 'F', 'A', 'C'], degrees: ['1', '♭3', '5', '♭7'] },
                { symbol: 'Em7♭5', notes: ['E', 'G', 'B♭', 'D'], degrees: ['2', '4', '♭6', '1'] },
                { symbol: 'Fmaj7', notes: ['F', 'A', 'C', 'E'], degrees: ['♭3', '5', '♭7', '2'] },
                { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['4', '♭6', '1', '♭3'] },
                { symbol: 'Am7', notes: ['A', 'C', 'E', 'G'], degrees: ['5', '♭7', '2', '4'] },
                { symbol: 'B♭maj7', notes: ['B♭', 'D', 'F', 'A'], degrees: ['♭6', '1', '♭3', '5'] },
                { symbol: 'C7', notes: ['C', 'E', 'G', 'B♭'], degrees: ['♭7', '2', '4', '♭6'] }
            ]
        };

        // Add remaining missing keys
        musicalKeys['F♯/G♭'] = { 
            scale: ['F♯', 'G♯', 'A♯', 'B', 'C♯', 'D♯', 'E♯'],
            signature: '6 sharps (F♯, C♯, G♯, D♯, A♯, E♯)',
            triads: [
                { symbol: 'F♯', notes: ['F♯', 'A♯', 'C♯'], degrees: ['1', '3', '5'] },
                { symbol: 'G♯m', notes: ['G♯', 'B', 'D♯'], degrees: ['2', '4', '6'] },
                { symbol: 'A♯m', notes: ['A♯', 'C♯', 'E♯'], degrees: ['3', '5', '7'] },
                { symbol: 'B', notes: ['B', 'D♯', 'F♯'], degrees: ['4', '6', '1'] },
                { symbol: 'C♯', notes: ['C♯', 'E♯', 'G♯'], degrees: ['5', '7', '2'] },
                { symbol: 'D♯m', notes: ['D♯', 'F♯', 'A♯'], degrees: ['6', '1', '3'] },
                { symbol: 'E♯°', notes: ['E♯', 'G♯', 'B'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'F♯maj7', notes: ['F♯', 'A♯', 'C♯', 'E♯'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'G♯m7', notes: ['G♯', 'B', 'D♯', 'F♯'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'A♯m7', notes: ['A♯', 'C♯', 'E♯', 'G♯'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'Bmaj7', notes: ['B', 'D♯', 'F♯', 'A♯'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'C♯7', notes: ['C♯', 'E♯', 'G♯', 'B'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'D♯m7', notes: ['D♯', 'F♯', 'A♯', 'C♯'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'E♯m7♭5', notes: ['E♯', 'G♯', 'B', 'D♯'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['D♭'] = { 
            scale: ['D♭', 'E♭', 'F', 'G♭', 'A♭', 'B♭', 'C'],
            signature: '5 flats (B♭, E♭, A♭, D♭, G♭)',
            triads: [
                { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['1', '3', '5'] },
                { symbol: 'E♭m', notes: ['E♭', 'G♭', 'B♭'], degrees: ['2', '4', '6'] },
                { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['3', '5', '7'] },
                { symbol: 'G♭', notes: ['G♭', 'B♭', 'D♭'], degrees: ['4', '6', '1'] },
                { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['5', '7', '2'] },
                { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['6', '1', '3'] },
                { symbol: 'C°', notes: ['C', 'E♭', 'G♭'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'E♭m7', notes: ['E♭', 'G♭', 'B♭', 'D♭'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'G♭maj7', notes: ['G♭', 'B♭', 'D♭', 'F'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'A♭7', notes: ['A♭', 'C', 'E♭', 'G♭'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'Cm7♭5', notes: ['C', 'E♭', 'G♭', 'B♭'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['A♭'] = { 
            scale: ['A♭', 'B♭', 'C', 'D♭', 'E♭', 'F', 'G'],
            signature: '4 flats (B♭, E♭, A♭, D♭)',
            triads: [
                { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['1', '3', '5'] },
                { symbol: 'B♭m', notes: ['B♭', 'D♭', 'F'], degrees: ['2', '4', '6'] },
                { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['3', '5', '7'] },
                { symbol: 'D♭', notes: ['D♭', 'F', 'A♭'], degrees: ['4', '6', '1'] },
                { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['5', '7', '2'] },
                { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['6', '1', '3'] },
                { symbol: 'G°', notes: ['G', 'B♭', 'D♭'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'B♭m7', notes: ['B♭', 'D♭', 'F', 'A♭'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'D♭maj7', notes: ['D♭', 'F', 'A♭', 'C'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'E♭7', notes: ['E♭', 'G', 'B♭', 'D♭'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'Gm7♭5', notes: ['G', 'B♭', 'D♭', 'F'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        musicalKeys['E♭'] = { 
            scale: ['E♭', 'F', 'G', 'A♭', 'B♭', 'C', 'D'],
            signature: '3 flats (B♭, E♭, A♭)',
            triads: [
                { symbol: 'E♭', notes: ['E♭', 'G', 'B♭'], degrees: ['1', '3', '5'] },
                { symbol: 'Fm', notes: ['F', 'A♭', 'C'], degrees: ['2', '4', '6'] },
                { symbol: 'Gm', notes: ['G', 'B♭', 'D'], degrees: ['3', '5', '7'] },
                { symbol: 'A♭', notes: ['A♭', 'C', 'E♭'], degrees: ['4', '6', '1'] },
                { symbol: 'B♭', notes: ['B♭', 'D', 'F'], degrees: ['5', '7', '2'] },
                { symbol: 'Cm', notes: ['C', 'E♭', 'G'], degrees: ['6', '1', '3'] },
                { symbol: 'D°', notes: ['D', 'F', 'A♭'], degrees: ['7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'E♭maj7', notes: ['E♭', 'G', 'B♭', 'D'], degrees: ['1', '3', '5', '7'] },
                { symbol: 'Fm7', notes: ['F', 'A♭', 'C', 'E♭'], degrees: ['2', '4', '6', '1'] },
                { symbol: 'Gm7', notes: ['G', 'B♭', 'D', 'F'], degrees: ['3', '5', '7', '2'] },
                { symbol: 'A♭maj7', notes: ['A♭', 'C', 'E♭', 'G'], degrees: ['4', '6', '1', '3'] },
                { symbol: 'B♭7', notes: ['B♭', 'D', 'F', 'A♭'], degrees: ['5', '7', '2', '4'] },
                { symbol: 'Cm7', notes: ['C', 'E♭', 'G', 'B♭'], degrees: ['6', '1', '3', '5'] },
                { symbol: 'Dm7♭5', notes: ['D', 'F', 'A♭', 'C'], degrees: ['7', '2', '4', '6'] }
            ]
        };

        // Add missing minor keys
        musicalKeys['Bm'] = { 
            scale: ['B', 'C♯', 'D', 'E', 'F♯', 'G', 'A'],
            signature: '2 sharps (F♯, C♯)',
            triads: [
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['1', '♭3', '5'] },
                { symbol: 'C♯°', notes: ['C♯', 'E', 'G'], degrees: ['2', '4', '♭6'] },
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭3', '5', '♭7'] },
                { symbol: 'Em', notes: ['E', 'G', 'B'], degrees: ['4', '♭6', '1'] },
                { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['5', '♭7', '2'] },
                { symbol: 'G', notes: ['G', 'B', 'D'], degrees: ['♭6', '1', '♭3'] },
                { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['♭7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['1', '♭3', '5', '♭7'] },
                { symbol: 'C♯m7♭5', notes: ['C♯', 'E', 'G', 'B'], degrees: ['2', '4', '♭6', '1'] },
                { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['♭3', '5', '♭7', '2'] },
                { symbol: 'Em7', notes: ['E', 'G', 'B', 'D'], degrees: ['4', '♭6', '1', '♭3'] },
                { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['5', '♭7', '2', '4'] },
                { symbol: 'Gmaj7', notes: ['G', 'B', 'D', 'F♯'], degrees: ['♭6', '1', '♭3', '5'] },
                { symbol: 'A7', notes: ['A', 'C♯', 'E', 'G'], degrees: ['♭7', '2', '4', '♭6'] }
            ]
        };

        musicalKeys['F♯m'] = { 
            scale: ['F♯', 'G♯', 'A', 'B', 'C♯', 'D', 'E'],
            signature: '3 sharps (F♯, C♯, G♯)',
            triads: [
                { symbol: 'F♯m', notes: ['F♯', 'A', 'C♯'], degrees: ['1', '♭3', '5'] },
                { symbol: 'G♯°', notes: ['G♯', 'B', 'D'], degrees: ['2', '4', '♭6'] },
                { symbol: 'A', notes: ['A', 'C♯', 'E'], degrees: ['♭3', '5', '♭7'] },
                { symbol: 'Bm', notes: ['B', 'D', 'F♯'], degrees: ['4', '♭6', '1'] },
                { symbol: 'C♯m', notes: ['C♯', 'E', 'G♯'], degrees: ['5', '♭7', '2'] },
                { symbol: 'D', notes: ['D', 'F♯', 'A'], degrees: ['♭6', '1', '♭3'] },
                { symbol: 'E', notes: ['E', 'G♯', 'B'], degrees: ['♭7', '2', '4'] }
            ],
            sevenths: [
                { symbol: 'F♯m7', notes: ['F♯', 'A', 'C♯', 'E'], degrees: ['1', '♭3', '5', '♭7'] },
                { symbol: 'G♯m7♭5', notes: ['G♯', 'B', 'D', 'F♯'], degrees: ['2', '4', '♭6', '1'] },
                { symbol: 'Amaj7', notes: ['A', 'C♯', 'E', 'G♯'], degrees: ['♭3', '5', '♭7', '2'] },
                { symbol: 'Bm7', notes: ['B', 'D', 'F♯', 'A'], degrees: ['4', '♭6', '1', '♭3'] },
                { symbol: 'C♯m7', notes: ['C♯', 'E', 'G♯', 'B'], degrees: ['5', '♭7', '2', '4'] },
                { symbol: 'Dmaj7', notes: ['D', 'F♯', 'A', 'C♯'], degrees: ['♭6', '1', '♭3', '5'] },
                { symbol: 'E7', notes: ['E', 'G♯', 'B', 'D'], degrees: ['♭7', '2', '4', '♭6'] }
            ]
        };

        // Calculate note name based on scale degrees for proper chord spelling
        function getScaleDegreeNote(rootNote, interval, key) {
            const keyData = musicalKeys[key];
            if (!keyData || !keyData.scale) return rootNote;
            
            const scale = keyData.scale;
            const rootIndex = scale.findIndex(note => noteToSemitone(note) === noteToSemitone(rootNote));
            
            if (rootIndex === -1) return rootNote;
            
            // For dominant 7th chords, we want the flatted 7th degree
            if (interval === 6) { // This is the 7th degree
                const seventhIndex = (rootIndex + 6) % 7;
                const seventhNote = scale[seventhIndex];
                
                // Calculate what the natural 7th would be
                const rootSemitone = noteToSemitone(rootNote);
                const naturalSeventhSemitone = (rootSemitone + 11) % 12; // Major 7th
                const flatSeventhSemitone = (rootSemitone + 10) % 12; // Minor 7th (♭7)
                
                // If the scale's 7th degree is the natural 7th, we need to flat it
                if (noteToSemitone(seventhNote) === naturalSeventhSemitone) {
                    return seventhNote + '♭';
                }
                // If the scale's 7th degree is already a flatted note relative to the natural 7th
                else if (noteToSemitone(seventhNote) === flatSeventhSemitone) {
                    return seventhNote;
                }
                // Otherwise calculate the proper flat 7th
                else {
                    return seventhNote + '♭';
                }
            }
            
            // For other intervals, use standard calculation
            const targetIndex = (rootIndex + interval) % 7;
            const targetScaleNote = scale[targetIndex];
            
            // Calculate the semitone difference
            const rootSemitone = noteToSemitone(rootNote);
            const targetSemitone = (rootSemitone + getSemitoneInterval(interval)) % 12;
            
            // If the scale note matches the target semitone, use it
            if (noteToSemitone(targetScaleNote) === targetSemitone) {
                return targetScaleNote;
            }
            
            // Otherwise, we need to alter the scale note with sharps/flats
            const scaleNoteSemitone = noteToSemitone(targetScaleNote);
            const diff = (targetSemitone - scaleNoteSemitone + 12) % 12;
            
            if (diff === 1) {
                return targetScaleNote + '♯';
            } else if (diff === 11) {
                return targetScaleNote + '♭';
            }
            
            return targetScaleNote;
        }
        
        function getSemitoneInterval(scaleDegreeInterval) {
            const intervals = {
                0: 0,   // unison
                1: 2,   // major 2nd
                2: 4,   // major 3rd  
                3: 5,   // perfect 4th
                4: 7,   // perfect 5th
                5: 9,   // major 6th
                6: 10   // minor 7th (for dominant 7th chords)
            };
            return intervals[scaleDegreeInterval] || 0;
        }

        // Generate secondary dominants for a key
        function generateSecondaryDominants(key) {
            // Use current scale data instead of predefined key data
            const keyData = getCurrentKeyData();
            if (!keyData || !keyData.scale) return [];
            
            const scaleNotes = keyData.scale;
            const isMinorScale = selectedScale === 'minor';
            
            // Build dominant 7th chords ON each scale degree (in diatonic order)
            const secondaryDominants = [];
            
            scaleNotes.forEach((note, index) => {
                // Build dominant 7th chord on this scale degree using chromatic intervals
                const root = note;
                const rootSemitone = noteToSemitone(root);
                
                // Build dominant 7th chord: Root + Major 3rd + Perfect 5th + Minor 7th
                const third = semitoneToNote((rootSemitone + 4) % 12, selectedKey);
                const fifth = semitoneToNote((rootSemitone + 7) % 12, selectedKey);
                const seventh = semitoneToNote((rootSemitone + 10) % 12, selectedKey);
                
                // Get scale degree roman numeral (what degree this chord is built on)
                const scaleDegreeRomans = ['I7', 'II7', 'III7', 'IV7', 'V7', 'VI7', 'VII7'];
                const scaleDegreeRoman = scaleDegreeRomans[index];
                
                // Get target roman numeral
                // G7→V7/IV, A7→V7/V, B7→V7/vi, C7→V7/♭VII, D7→V7/I, E7→V7/ii, F#7→V7/iii
                const targetRomanNumerals = isMinorScale ? 
                    ['iv', 'v', '♭VI', '♭VII', 'i', 'ii°', '♭III'] :
                    ['IV', 'V', 'vi', '♭VII', 'I', 'ii', 'iii'];
                const target = targetRomanNumerals[index];
                    
                secondaryDominants.push({
                    symbol: `${root}7`,
                    notes: [root, third, fifth, seventh],
                    degrees: ['1', '3', '5', '♭7'],
                    scaleDegree: scaleDegreeRoman,
                    target: target
                });
            });
            
            return secondaryDominants;
        }

        // Generate diminished passing chords for a key
        function generateDiminishedPassing(key) {
            // Use current scale data instead of predefined key data
            const keyData = getCurrentKeyData();
            if (!keyData || !keyData.scale) return [];
            
            const scaleNotes = keyData.scale;
            const diminishedPassing = [];
            const isMinorScale = selectedScale === 'minor';
            
            // Get all semitone positions of scale notes
            const scalePositions = scaleNotes.map(note => noteToSemitone(note));
            const tonicSemitone = scalePositions[0];
            
            // Find chromatic gaps between scale notes (within one octave)
            const chromaticPositions = [];
            for (let i = 0; i < 12; i++) {
                const currentSemitone = (tonicSemitone + i) % 12;
                if (!scalePositions.includes(currentSemitone)) {
                    chromaticPositions.push(currentSemitone);
                }
            }
            
            // Generate diminished 7th chords on chromatic passing tones
            chromaticPositions.forEach((passingToneSemitone, index) => {
                // Force flat spelling for diminished passing chord roots
                const root = semitoneToNoteFlat(passingToneSemitone);
                const third = semitoneToNoteFlat((passingToneSemitone + 3) % 12); // Minor third
                const fifth = semitoneToNoteFlat((passingToneSemitone + 6) % 12); // Diminished fifth
                const seventh = semitoneToNoteFlat((passingToneSemitone + 9) % 12); // Diminished seventh
                
                // Calculate the chromatic scale degree relative to tonic
                const chromaticDegree = (passingToneSemitone - tonicSemitone + 12) % 12;
                
                // Map chromatic degrees to Roman numeral notation for diminished chords
                const romanNumeralMap = {
                    0: 'I°<sup>7</sup>',      // I (enharmonic)
                    1: '♭II°<sup>7</sup>',    // ♭II
                    2: 'II°<sup>7</sup>',     // II
                    3: '♭III°<sup>7</sup>',   // ♭III
                    4: 'III°<sup>7</sup>',    // III
                    5: 'IV°<sup>7</sup>',     // IV
                    6: '♭V°<sup>7</sup>',     // ♭V (tritone)
                    7: 'V°<sup>7</sup>',      // V
                    8: '♭VI°<sup>7</sup>',    // ♭VI
                    9: 'VI°<sup>7</sup>',     // VI
                    10: '♭VII°<sup>7</sup>',  // ♭VII
                    11: 'VII°<sup>7</sup>'    // VII
                };
                
                const romanNumeral = romanNumeralMap[chromaticDegree] || `${root}°<sup>7</sup>`;
                
                diminishedPassing.push({
                    symbol: `${root}°7`,
                    notes: [root, third, fifth, seventh],
                    degrees: ['1', '♭3', '♭5', '♭♭7'],
                    roman: romanNumeral
                });
            });
            
            return diminishedPassing;
        }
        
        // Helper function to force flat spellings for diminished chords
        function semitoneToNoteFlat(semitone) {
            const flatNotes = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
            return flatNotes[semitone];
        }

        // Instruments data with updated violin positions
        const instruments = {
            guitar: {
                name: 'Guitar',
                type: 'fretted',
                strings: ['E', 'A', 'D', 'G', 'B', 'E'], // Low E to High E
                frets: 24,
                defaultTuning: ['E', 'A', 'D', 'G', 'B', 'E']
            },
            bass: {
                name: 'Bass Guitar', 
                type: 'fretted',
                strings: ['E', 'A', 'D', 'G'], // Low E to High G
                frets: 24,
                defaultTuning: ['E', 'A', 'D', 'G']
            },
            ukulele: {
                name: 'Ukulele',
                type: 'fretted', 
                strings: ['G', 'C', 'E', 'A'], // Low G to High A
                frets: 15,
                defaultTuning: ['G', 'C', 'E', 'A']
            },
            violin: {
                name: 'Violin',
                type: 'bowed',
                strings: ['G', 'D', 'A', 'E'], // Low G to High E
                frets: 20, // positions instead of frets
                defaultTuning: ['G', 'D', 'A', 'E']
            }
        };

        // Note mapping functions
        function noteToSemitone(note) {
            const noteMap = {
                'C': 0, 'C♯': 1, 'C#': 1, 'D♭': 1, 'Db': 1, 'C♯/D♭': 1, 'D': 2, 
                'D♯': 3, 'D#': 3, 'E♭': 3, 'Eb': 3, 'D♯/E♭': 3,
                'E': 4, 'E♯': 5, 'E#': 5, 'F': 5, 
                'F♯': 6, 'F#': 6, 'G♭': 6, 'Gb': 6, 'F♯/G♭': 6, 'G': 7, 
                'G♯': 8, 'G#': 8, 'A♭': 8, 'Ab': 8, 'G♯/A♭': 8,
                'A': 9, 'A♯': 10, 'A#': 10, 'B♭': 10, 'Bb': 10, 'A♯/B♭': 10, 
                'B': 11, 'B♯': 0, 'B#': 0
            };
            return noteMap[note] !== undefined ? noteMap[note] : 0;
        }

        function semitoneToNote(semitone, key) {
            // Get proper enharmonic spelling based on key signature and scale type
            const keyRoot = key ? key.replace(/m$/, '').split('/')[0] : 'C';
            
            // Determine if we should use flats based on scale type and key
            let useFlats = false;
            
            // Check key signatures for traditional keys
            const keyInfo = keySignatures[keyRoot];
            if (keyInfo && keyInfo.flats.length > 0) {
                useFlats = true;
            }
            
            // Mode-specific flat/sharp preferences (same as generateScaleNotes)
            const modePreferences = {
                'dorian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'phrygian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'D♭', 'E♭', 'G♭', 'A♭', 'B♭'],
                'lydian': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'mixolydian': ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'locrian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'D♭', 'E♭', 'G♭', 'A♭', 'B♭'],
                'dorianFlat2': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'lydianAugmented': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'lydianDominant': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'mixolydianFlat6': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'locrianSharp2': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'altered': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭']
            };
            
            // Check if current scale type has mode preference
            if (modePreferences[selectedScale]) {
                useFlats = modePreferences[selectedScale].includes(keyRoot);
            } else if (['minor', 'harmonicMinor', 'melodicMinor', 'minorPentatonic', 'minorSixDiminished'].includes(selectedScale)) {
                // Minor-based scales
                useFlats = true;
            }
            
            if (useFlats) {
                const flatNotes = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
                return flatNotes[semitone % 12];
            } else {
                const sharpNotes = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
                return sharpNotes[semitone % 12];
            }
        }

        function isNoteInScale(note, scaleNotes) {
            const noteSemi = noteToSemitone(note);
            return scaleNotes.some(scaleNote => {
                const scaleSemi = noteToSemitone(scaleNote);
                return noteSemi === scaleSemi;
            });
        }

        function isRootNote(note, key) {
            if (!key) return false; // No root in chromatic mode
            const rootNote = key.replace(/m$/, '').split('/')[0];
            return noteToSemitone(note) === noteToSemitone(rootNote);
        }

        function isChordRoot(note, chord) {
            if (!chord || !chord.notes || chord.notes.length === 0) return false;
            // The first note in the chord.notes array is the root
            const chordRoot = chord.notes[0];
            return noteToSemitone(note) === noteToSemitone(chordRoot);
        }

        // Cadence System
        function getCadencesForChord(chordSymbol, key) {
            const cadences = [];
            
            if (!chordSymbol || !key) return cadences;
            
            // Define common cadences based on chord function
            const cadencePatterns = {
                // Dominant function (V, V7, vii°) -> Tonic resolutions
                'V': [
                    { name: 'Authentic', target: 'I', description: 'Strong resolution to tonic' },
                    { name: 'Deceptive', target: 'vi', description: 'Surprise resolution to relative minor' }
                ],
                'V7': [
                    { name: 'Authentic', target: 'I', description: 'Classic V7→I resolution' },
                    { name: 'Deceptive', target: 'vi', description: 'V7→vi deceptive cadence' }
                ],
                'vii°': [
                    { name: 'Leading Tone', target: 'I', description: 'Leading tone resolution' }
                ],
                
                // Subdominant function (IV, ii) -> Dominant or Tonic
                'IV': [
                    { name: 'Plagal', target: 'I', description: 'Amen cadence' },
                    { name: 'Subdominant', target: 'V', description: 'IV→V motion' }
                ],
                'ii': [
                    { name: 'ii-V', target: 'V', description: 'Classic ii→V motion' },
                    { name: 'ii-V-I', target: 'V7', description: 'Setup for V7→I' }
                ],
                'ii7': [
                    { name: 'ii7-V7', target: 'V7', description: 'Jazz ii7→V7 progression' }
                ],
                
                // Tonic function (I, vi) -> Any direction
                'I': [
                    { name: 'Circle of 5ths', target: 'vi', description: 'I→vi motion' },
                    { name: 'To Subdominant', target: 'IV', description: 'I→IV progression' },
                    { name: 'To Dominant', target: 'V', description: 'I→V progression' }
                ],
                'vi': [
                    { name: 'vi-IV', target: 'IV', description: 'Popular vi→IV motion' },
                    { name: 'vi-ii', target: 'ii', description: 'vi→ii progression' },
                    { name: 'Relative Major', target: 'I', description: 'Return to tonic' }
                ],
                
                // Other common progressions
                'iii': [
                    { name: 'iii-vi', target: 'vi', description: 'iii→vi motion' },
                    { name: 'iii-IV', target: 'IV', description: 'iii→IV progression' }
                ]
            };
            
            // Get Roman numeral for current chord
            // Need to create a chord object with the symbol for generateRomanNumeralForChord
            const chordObj = { symbol: chordSymbol };
            const currentRoman = calculateRomanNumeralFromRoot(chordObj, key);
            
            // Find matching cadences
            if (cadencePatterns[currentRoman]) {
                cadencePatterns[currentRoman].forEach(pattern => {
                    const targetChord = romanToChordSymbol(pattern.target, key);
                    if (targetChord) {
                        cadences.push({
                            name: pattern.name,
                            description: pattern.description,
                            targetRoman: pattern.target,
                            targetChord: targetChord,
                            displayText: `${pattern.name} →${pattern.target}`
                        });
                    }
                });
            }
            
            return cadences;
        }

        function romanToChordSymbol(roman, key) {
            const keyData = getCurrentKeyData();
            if (!keyData || !keyData.scale) return null;
            
            const scale = keyData.scale;
            const isMinor = key.includes('m');
            
            // Roman numeral to scale degree mapping
            const romanMap = {
                'I': 0, 'ii': 1, 'iii': 2, 'IV': 3, 'V': 4, 'vi': 5, 'vii°': 6,
                'i': 0, 'ii°': 1, 'III': 2, 'iv': 3, 'v': 4, 'VI': 5, 'VII': 6
            };
            
            const degree = romanMap[roman];
            if (degree === undefined) return null;
            
            const root = scale[degree];
            
            // Determine chord quality based on roman numeral
            if (roman === 'V7') return root + '7';
            if (roman === 'ii7') return root + 'm7';
            if (roman === 'vii°') return root + 'dim';
            if (roman === 'ii°') return root + 'dim';
            if (roman.toLowerCase() === roman) return root + 'm'; // lowercase = minor
            return root; // uppercase = major
        }

        function showCadenceOptions(chordSymbol, key) {
            const cadenceControls = document.getElementById('cadenceControls');
            const cadenceButtons = document.getElementById('cadenceButtons');
            
            if (!chordSymbol || !key) {
                cadenceControls.style.display = 'none';
                return;
            }
            
            const cadences = getCadencesForChord(chordSymbol, key);
            
            if (cadences.length === 0) {
                cadenceControls.style.display = 'none';
                return;
            }
            
            // Clear existing buttons
            cadenceButtons.innerHTML = '';
            
            // Create cadence buttons
            cadences.forEach(cadence => {
                const button = document.createElement('button');
                button.className = 'cadence-btn';
                button.textContent = cadence.displayText;
                button.title = cadence.description;
                button.onclick = () => applyCadence(cadence.targetChord);
                cadenceButtons.appendChild(button);
            });
            
            cadenceControls.style.display = 'block';
        }

        function applyCadence(targetChord) {
            // Find the next empty measure and add the target chord
            const nextEmptyIndex = progressionMeasures.findIndex(measure => measure.chord === null);
            
            if (nextEmptyIndex !== -1) {
                // Add the cadence chord to the next measure
                const chordData = getChordData(targetChord, selectedKey);
                progressionMeasures[nextEmptyIndex] = {
                    ...progressionMeasures[nextEmptyIndex],
                    chord: chordData
                };
                updateProgressionChart();
                
                // Play the cadence chord
                if (chordData && chordData.notes) {
                    playChordFromNotes(chordData.notes);
                }
                
                // Show new cadence options for the newly added chord
                showCadenceOptions(targetChord, selectedKey);
            }
        }

        function isChordTone(note, chord) {
            if (!chord || !chord.notes) return false;
            const noteSemi = noteToSemitone(note);
            return chord.notes.some(chordNote => {
                const chordSemi = noteToSemitone(chordNote);
                return noteSemi === chordSemi;
            });
        }

        function getCorrectChordNoteName(semitone, chord) {
            if (!chord || !chord.notes) return null;
            
            // Find the exact note name from the chord that matches this semitone
            return chord.notes.find(chordNote => {
                return noteToSemitone(chordNote) === semitone;
            });
        }

        // State
        let selectedKey = null; // Start with no key selected (chromatic mode)
        let selectedScale = 'chromatic'; // Start in chromatic mode
        let selectedInstrument = 'guitar';
        let currentTuning = {};
        let chordMode = 'triads'; // 'triads', 'sevenths', 'secondary', or 'diminished'
        let selectedChord = null; // Currently selected chord for highlighting

        // Custom chord creation state
        let customChordNotes = []; // Array of selected notes for custom chord
        let customChordRoot = null; // Root note of custom chord
        let isCustomChordMode = true; // Always in chord creation mode now
        let customChordClickCount = {}; // Track click counts for double-click detection
        let customChordPositions = []; // Array of {note, string, fret} for single-note highlighting
        let selectedMeasureIndex = null; // Currently selected measure for chord building

        // Scale display names
        const scaleNames = {
            major: 'Major',
            minor: 'Natural Minor',
            harmonicMinor: 'Harmonic Minor',
            melodicMinor: 'Melodic Minor',
            dorian: 'Dorian',
            phrygian: 'Phrygian',
            lydian: 'Lydian',
            mixolydian: 'Mixolydian',
            locrian: 'Locrian',
            dorianFlat2: 'Dorian ♭2',
            lydianAugmented: 'Lydian Augmented',
            lydianDominant: 'Lydian Dominant',
            mixolydianFlat6: 'Mixolydian ♭6',
            locrianSharp2: 'Locrian ♯2',
            altered: 'Altered',
            majorPentatonic: 'Major Pentatonic',
            minorPentatonic: 'Minor Pentatonic',
            wholeTone: 'Whole Tone',
            halfWholeDiminished: 'Half-Whole Diminished',
            wholeHalfDiminished: 'Whole-Half Diminished',
            majorSixDiminished: 'Major 6 Diminished',
            minorSixDiminished: 'Minor 6 Diminished'
        };

        // Scale formulas (intervals in semitones from root)
        const scaleFormulas = {
            major: [0, 2, 4, 5, 7, 9, 11],           // W-W-H-W-W-W-H (Ionian)
            minor: [0, 2, 3, 5, 7, 8, 10],            // W-H-W-W-H-W-W (Aeolian)
            harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
            melodicMinor: [0, 2, 3, 5, 7, 9, 11],
            dorian: [0, 2, 3, 5, 7, 9, 10],           // W-H-W-W-W-H-W (Mode II of major)
            phrygian: [0, 1, 3, 5, 7, 8, 10],         // H-W-W-W-H-W-W (Mode III of major)
            lydian: [0, 2, 4, 6, 7, 9, 11],           // W-W-W-H-W-W-H (Mode IV of major)
            mixolydian: [0, 2, 4, 5, 7, 9, 10],       // W-W-H-W-W-H-W (Mode V of major)
            locrian: [0, 1, 3, 5, 6, 8, 10],          // H-W-W-H-W-W-W (Mode VII of major)
            dorianFlat2: [0, 1, 3, 5, 7, 9, 10],      // H-W-W-W-W-H-W (Mode II of melodic minor)
            lydianAugmented: [0, 2, 4, 6, 8, 9, 11],  // W-W-W-W-H-W-H (Mode III of melodic minor)
            lydianDominant: [0, 2, 4, 6, 7, 9, 10],   // W-W-W-H-W-H-W (Mode IV of melodic minor)
            mixolydianFlat6: [0, 2, 4, 5, 7, 8, 10],  // W-W-H-W-H-W-W (Mode V of melodic minor)
            locrianSharp2: [0, 2, 3, 5, 6, 8, 10],    // W-H-W-H-W-W-W (Mode VI of melodic minor)
            altered: [0, 1, 3, 4, 6, 8, 10],          // H-W-H-W-W-W-W (Mode VII of melodic minor)
            majorPentatonic: [0, 2, 4, 7, 9],
            minorPentatonic: [0, 3, 5, 7, 10],
            wholeTone: [0, 2, 4, 6, 8, 10],
            halfWholeDiminished: [0, 1, 3, 4, 6, 7, 9, 10],
            wholeHalfDiminished: [0, 2, 3, 5, 6, 8, 9, 11],
            majorSixDiminished: [0, 2, 4, 5, 7, 8, 9, 11], // Major scale + b6 (C D E F G Ab A B)
            minorSixDiminished: [0, 2, 3, 5, 7, 8, 9, 11]  // Major 6 diminished with b3 (C D Eb F G Ab A B)
        };

        // Comprehensive chord template repository
        const CHORD_TEMPLATES = {
                        '7b9': { intervals: [0, 4, 7, 10, 13], priority: 9, symbol: '7b9', type: 'altered', completenessThreshold: 0.6, excludeIf: [] },
                        '7#9': { intervals: [0, 4, 7, 10, 15], priority: 9, symbol: '7#9', type: 'altered', completenessThreshold: 0.6, excludeIf: [] },
                        '7b5': { intervals: [0, 4, 6, 10], priority: 9, symbol: '7b5', type: 'altered', completenessThreshold: 0.75, excludeIf: [] },
                        '7#5': { intervals: [0, 4, 8, 10], priority: 9, symbol: '7#5', type: 'altered', completenessThreshold: 0.75, excludeIf: [] },
                        '7#11': { intervals: [0, 4, 7, 10, 18], priority: 9, symbol: '7#11', type: 'altered', completenessThreshold: 0.6, excludeIf: [] },
                        '13': { intervals: [0, 4, 7, 10, 14, 17, 21], priority: 9, symbol: '13', type: 'extended', completenessThreshold: 0.5, excludeIf: [] },
            // TRIADS (Priority 1)
            'major': { 
                intervals: [0, 4, 7], 
                priority: 1, 
                symbol: '', 
                type: 'triad',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            'minor': { 
                intervals: [0, 3, 7], 
                priority: 1, 
                symbol: 'm', 
                type: 'triad',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            'diminished': { 
                intervals: [0, 3, 6], 
                priority: 1, 
                symbol: '°', 
                type: 'triad',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            'augmented': { 
                intervals: [0, 4, 8], 
                priority: 1, 
                symbol: '+', 
                type: 'triad',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            
            // SUSPENDED (Priority 1.5)
            'sus4': { 
                intervals: [0, 5, 7], 
                priority: 1.5, 
                symbol: 'sus4', 
                type: 'suspended',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            'sus2': { 
                intervals: [0, 2, 7], 
                priority: 1.5, 
                symbol: 'sus2', 
                type: 'suspended',
                completenessThreshold: 0.67,
                excludeIf: []
            },
            
            // SIXTH CHORDS (Priority 2)
            'major6': { 
                intervals: [0, 4, 7, 9], 
                priority: 2, 
                symbol: '6', 
                type: 'sixth',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'minor6': { 
                intervals: [0, 3, 7, 9], 
                priority: 2, 
                symbol: 'm6', 
                type: 'sixth',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            
            // SEVENTH CHORDS (Priority 3)
            'dominant7': { 
                intervals: [0, 4, 7, 10], 
                priority: 3, 
                symbol: '7', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'major7': { 
                intervals: [0, 4, 7, 11], 
                priority: 3, 
                symbol: 'maj7', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'minor7': { 
                intervals: [0, 3, 7, 10], 
                priority: 3, 
                symbol: 'm7', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'minorMajor7': { 
                intervals: [0, 3, 7, 11], 
                priority: 3, 
                symbol: 'mMaj7', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'halfDiminished7': { 
                intervals: [0, 3, 6, 10], 
                priority: 3, 
                symbol: 'm7♭5', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'diminished7': { 
                intervals: [0, 3, 6, 9], 
                priority: 3, 
                symbol: '°7', 
                type: 'seventh',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            
            // ADD CHORDS (Priority 3.5) - only if NO 7th present
            'add9': { 
                intervals: [0, 2, 4, 7], 
                priority: 3.5, 
                symbol: 'add9', 
                type: 'add',
                completenessThreshold: 0.75,
                excludeIf: [10, 11] // No 7ths
            },
            'madd9': { 
                intervals: [0, 2, 3, 7], 
                priority: 3.5, 
                symbol: 'madd9', 
                type: 'add',
                completenessThreshold: 0.75,
                excludeIf: [10, 11] // No 7ths
            },
            'add11': { 
                intervals: [0, 4, 5, 7], 
                priority: 3.5, 
                symbol: 'add11', 
                type: 'add',
                completenessThreshold: 0.75,
                excludeIf: [10, 11] // No 7ths
            },
            
            // NINTH CHORDS (Priority 5)
            'dominant9': { 
                intervals: [0, 2, 4, 7, 10], 
                priority: 5, 
                symbol: '9', 
                type: 'extended',
                completenessThreshold: 0.6,
                excludeIf: []
            },
            'minor9': { 
                intervals: [0, 2, 3, 7, 10], 
                priority: 5, 
                symbol: 'm9', 
                type: 'extended',
                completenessThreshold: 0.6,
                excludeIf: []
            },
            'major9': { 
                intervals: [0, 2, 4, 7, 11], 
                priority: 5, 
                symbol: 'maj9', 
                type: 'extended',
                completenessThreshold: 0.6,
                excludeIf: []
            },
            
            // ELEVENTH CHORDS (Priority 6)
            'dominant11': { 
                intervals: [0, 2, 4, 5, 7, 10], 
                priority: 6, 
                symbol: '11', 
                type: 'extended',
                completenessThreshold: 0.5,
                excludeIf: []
            },
            'minor11': { 
                intervals: [0, 2, 3, 5, 7, 10], 
                priority: 6, 
                symbol: 'm11', 
                type: 'extended',
                completenessThreshold: 0.5,
                excludeIf: []
            },
            
            // THIRTEENTH CHORDS (Priority 7)
            'dominant13': { 
                intervals: [0, 2, 4, 7, 9, 10], 
                priority: 7, 
                symbol: '13', 
                type: 'extended',
                completenessThreshold: 0.5,
                excludeIf: []
            },
            'minor13': { 
                intervals: [0, 2, 3, 7, 9, 10], 
                priority: 7, 
                symbol: 'm13', 
                type: 'extended',
                completenessThreshold: 0.5,
                excludeIf: []
            },
            
            // ALTERED DOMINANTS (Priority 9)
            'dom7flat9': { 
                intervals: [0, 1, 4, 7, 10], 
                priority: 9, 
                symbol: '7♭9', 
                type: 'altered',
                completenessThreshold: 0.6,
                excludeIf: []
            },
            'dom7sharp9': { 
                intervals: [0, 3, 4, 7, 10], 
                priority: 9, 
                symbol: '7♯9', 
                type: 'altered',
                completenessThreshold: 0.6,
                excludeIf: []
            },
            'dom7sharp5': { 
                intervals: [0, 4, 8, 10], 
                priority: 9, 
                symbol: '7♯5', 
                type: 'altered',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'dom7flat5': { 
                intervals: [0, 4, 6, 10], 
                priority: 9, 
                symbol: '7♭5', 
                type: 'altered',
                completenessThreshold: 0.75,
                excludeIf: []
            },
            'dom7sharp11': { 
                intervals: [0, 4, 6, 7, 10], 
                priority: 9, 
                symbol: '7♯11', 
                type: 'altered',
                completenessThreshold: 0.6,
                excludeIf: []
            }
        };

        // Scoring and matching functions
        function scoreChordMatch(inputIntervals, template) {
            const required = template.intervals;
            const inputSet = new Set(inputIntervals);
            
            // Check exclusion rules first
            if (template.excludeIf && template.excludeIf.length > 0) {
                for (let excludedInterval of template.excludeIf) {
                    if (inputSet.has(excludedInterval)) {
                        return 0; // Excluded
                    }
                }
            }
            
            // Calculate completeness
            const matchCount = required.filter(interval => inputSet.has(interval)).length;
            const completeness = matchCount / required.length;
            
            // Check threshold
            if (completeness < template.completenessThreshold) {
                return 0;
            }
            
            // Penalties and bonuses
            const extraNotes = inputIntervals.length - required.length;
            const extraNotePenalty = Math.max(0, extraNotes * 0.1);
            const missingNotes = required.length - matchCount;
            const missingNotePenalty = missingNotes * 0.15;
            
            // Exact match bonus
            const exactMatchBonus = (completeness === 1.0 && extraNotes === 0) ? 0.2 : 0;
            
            return Math.max(0, completeness - extraNotePenalty - missingNotePenalty + exactMatchBonus);
        }

        // Generate slash chord suggestions
        function generateSlashChordSuggestions(inputIntervals, customChordNotes) {
            if (customChordNotes.length < 3) return [];
            
            const slashSuggestions = [];
            
            // Test each note as potential bass note
            customChordNotes.forEach(bassNote => {
                // Test each note (including bass) as potential root of the complete chord
                customChordNotes.forEach(potentialRoot => {
                    // Skip if bass and root are the same (that would be root position, not a slash chord)
                    if (bassNote === potentialRoot) return;
                    
                    // Calculate intervals from potential root using ALL notes
                    const rootSemitone = noteToSemitone(potentialRoot);
                    const testIntervals = customChordNotes.map(note => {
                        return (noteToSemitone(note) - rootSemitone + 12) % 12;
                    }).sort((a, b) => a - b);
                    
                    // Test against chord templates (focus on basic chords for slash recognition)
                    const basicTemplates = ['major', 'minor', 'dominant7', 'major7', 'minor7', 'diminished'];
                    
                    basicTemplates.forEach(templateName => {
                        const template = CHORD_TEMPLATES[templateName];
                        if (!template) return;
                        
                        const score = scoreChordMatch(testIntervals, template);
                        
                        if (score >= 0.75) { // Good threshold for slash chord recognition
                            const upperChordSymbol = potentialRoot + template.symbol;
                            const slashChordSymbol = upperChordSymbol + '/' + bassNote;
                            
                            slashSuggestions.push({
                                symbol: slashChordSymbol,
                                score: score + 0.1, // Small bonus for inversion recognition
                                priority: 0.5, // High priority for slash chords
                                intervals: testIntervals,
                                type: 'slash',
                                isSlashChord: true
                            });
                        }
                    });
                });
            });
            
            // Remove duplicates and sort by score
            const uniqueSlashSuggestions = [];
            const seenSymbols = new Set();
            
            slashSuggestions.sort((a, b) => b.score - a.score);
            
            for (let suggestion of slashSuggestions) {
                if (!seenSymbols.has(suggestion.symbol)) {
                    seenSymbols.add(suggestion.symbol);
                    uniqueSlashSuggestions.push(suggestion);
                }
            }
            
            return uniqueSlashSuggestions;
        }

        // Position zoom state
        let currentPosition = null;
        let isPositionZoomed = false;
        let arpeggioLinesEnabled = true;

        // Position definitions (fret ranges)
        const POSITIONS = {
            'I': { frets: [1, 2, 3, 4, 5], label: 'I' },
            'II': { frets: [2, 3, 4, 5, 6], label: 'II' },
            'III': { frets: [3, 4, 5, 6, 7], label: 'III' },
            'IV': { frets: [4, 5, 6, 7, 8], label: 'IV' },
            'V': { frets: [5, 6, 7, 8, 9], label: 'V' },
            'VI': { frets: [6, 7, 8, 9, 10], label: 'VI' },
            'VII': { frets: [7, 8, 9, 10, 11], label: 'VII' },
            'VIII': { frets: [8, 9, 10, 11, 12], label: 'VIII' },
            'IX': { frets: [9, 10, 11, 12, 13], label: 'IX' },
            'X': { frets: [10, 11, 12, 13, 14], label: 'X' },
            'XI': { frets: [11, 12, 13, 14, 15], label: 'XI' },
            'XII': { frets: [12, 13, 14, 15, 16], label: 'XII' },
            'XIII': { frets: [13, 14, 15, 16, 17], label: 'XIII' },
            'XIV': { frets: [14, 15, 16, 17, 18], label: 'XIV' },
            'XV': { frets: [15, 16, 17, 18, 19], label: 'XV' },
            'XVI': { frets: [16, 17, 18, 19, 20, 21], label: 'XVI' },
            'XVII': { frets: [17, 18, 19, 20, 21, 22], label: 'XVII' }
        };

        // Progression state - NEW SONG STRUCTURE
        let progressionActive = false;
        let progressionKey = 'C';
        
        // Song structure with sections
        let currentSong = {
            title: "Untitled Song",
            sections: [
                {
                    id: 'section-1',
                    name: 'Intro',
                    bars: 4,
                    key: 'C',
                    timeSignature: '4/4',
                    repeat: false,
                    measures: new Array(4).fill(null).map(() => ({
                        chord: null,
                        chords: [],
                        localKey: 'C',
                        timeSignature: '4/4'
                    }))
                }
            ],
            currentSectionIndex: 0
        };
        
        // Compatibility layer - progressionMeasures points to current section's measures or all sections in Song mode
        let progressionMeasures = currentSong.sections[0].measures;

        // Helper to get all measures from all sections
        function getAllSectionsMeasures() {
            if (!currentSong || !currentSong.sections) return [];
            let all = [];
            currentSong.sections.forEach(section => {
                const repeat = section.repeat || 1;
                for (let i = 0; i < repeat; i++) {
                    all = all.concat(section.measures);
                }
            });
            return all;
        }

        // Listen for playback mode change to update staff
        document.getElementById('playCurrentSection').addEventListener('change', updateStaffForPlaybackMode);
        document.getElementById('playAllSections').addEventListener('change', updateStaffForPlaybackMode);

        function updateStaffForPlaybackMode() {
            const playAllSections = document.getElementById('playAllSections').checked;
            if (playAllSections) {
                progressionMeasures = getAllSectionsMeasures();
                // Use first section's time signature for now (could be improved for multi-time-signature songs)
                generateStaffMeasures(progressionMeasures.length, currentSong.sections[0].timeSignature);
            } else {
                progressionMeasures = currentSong.sections[currentSong.currentSectionIndex].measures;
                generateStaffMeasures(progressionMeasures.length, currentSong.sections[currentSong.currentSectionIndex].timeSignature);
            }
            setTimeout(() => updateProgressionChart(), 100);
        }

        // Ensure staff updates on song/section load
        function regenerateStaffForCurrentSection() {
            const playAllSections = document.getElementById('playAllSections').checked;
            if (playAllSections) {
                progressionMeasures = getAllSectionsMeasures();
                generateStaffMeasures(progressionMeasures.length, currentSong.sections[0].timeSignature);
            } else {
                const currentSection = currentSong.sections[currentSong.currentSectionIndex];
                const repeatCount = currentSection.repeat || 1;
                const totalBars = currentSection.bars * repeatCount;
                progressionMeasures = currentSection.measures;
                generateStaffMeasures(totalBars, currentSection.timeSignature);
            }
            updateProgressionChart();
        }
        
        // Generate initial staff on page load - wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                generateStaffMeasures(4, '4/4');
                setTimeout(() => updateProgressionChart(), 100);
            });
        } else {
            // DOM already loaded
            setTimeout(() => {
                generateStaffMeasures(4, '4/4');
                setTimeout(() => updateProgressionChart(), 100);
            }, 50);
        }
        
        let audioContext = null;
        let isPlaying = false;
        let isMobileAudioUnlocked = false;
        let isRegeneratingStaff = false; // Prevent infinite regeneration loop
        let updateChartCallCount = 0; // Debug: track how many times updateProgressionChart is called
        
        // Additional progression state for enhanced staff system
        let isLooping = true;
        let countInActive = false;
        let cursorPosition = 0;

        // Mobile audio unlock function
        function unlockMobileAudio() {
            if (isMobileAudioUnlocked) return;
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Mobile audio unlocked!');
                    isMobileAudioUnlocked = true;
                });
            } else {
                isMobileAudioUnlocked = true;
            }
        }

        // Add mobile audio unlock listeners
        document.addEventListener('touchstart', unlockMobileAudio, { once: true });
        document.addEventListener('click', unlockMobileAudio, { once: true });

        // Scale-related functions
        function selectScale(scaleType) {
            selectedScale = scaleType;
            selectedChord = null; // Clear selected chord when switching scales
            
            // Clear custom chord when scale changes
            clearCustomChord();
            
            // If switching to an alternative scale and current mode is secondary/diminished, switch to triads
            if (!isHomeScale() && (chordMode === 'secondary' || chordMode === 'diminished')) {
                chordMode = 'triads';
            }
            
            updateKeyInfo();
            updateFretboard();
        }

        // Generate scale notes from root and formula
        function generateScaleNotes(root, scaleType) {
            const formula = scaleFormulas[scaleType];
            if (!formula) return [];
            
            const rootSemitone = noteToSemitone(root);
            
            // Determine if we should prefer flats or sharps based on scale type and root
            let preferFlats = false;
            
            // Check for explicitly flat root notes
            const rootPreferFlats = ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭', 'C♭'].includes(root);
            
            // Mode-specific flat/sharp preferences based on parent scale relationships
            const modePreferences = {
                'dorian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'phrygian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'D♭', 'E♭', 'G♭', 'A♭', 'B♭'], // Most roots prefer flats
                'lydian': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'mixolydian': ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
                'locrian': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'D♭', 'E♭', 'G♭', 'A♭', 'B♭'], // Most roots prefer flats
                'dorianFlat2': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'lydianAugmented': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'lydianDominant': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'mixolydianFlat6': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'locrianSharp2': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'], // Only flat keys use flats
                'altered': ['F', 'B♭', 'E♭', 'A♭', 'D♭', 'G♭'] // Only flat keys use flats
            };
            
            // Check if mode has specific preference
            if (modePreferences[scaleType]) {
                preferFlats = modePreferences[scaleType].includes(root);
            } else {
                // For non-modal scales
                const isMinorBasedScale = ['minor', 'harmonicMinor', 'melodicMinor', 'minorPentatonic', 'minorSixDiminished'].includes(scaleType);
                preferFlats = isMinorBasedScale || rootPreferFlats;
            }
            
            return formula.map((interval, index) => {
                const noteSemitone = (rootSemitone + interval) % 12;
                
                if (preferFlats) {
                    const flatNotes = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
                    return flatNotes[noteSemitone];
                } else {
                    const sharpNotes = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
                    return sharpNotes[noteSemitone];
                }
            });
        }

        // Generate triads from a scale
        function generateTriadsFromScale(scaleNotes, root) {
            const triads = [];
            
            // Generate a triad for each scale degree by stacking thirds
            scaleNotes.forEach((note, index) => {
                const thirdIndex = (index + 2) % scaleNotes.length;
                const fifthIndex = (index + 4) % scaleNotes.length;
                
                const third = scaleNotes[thirdIndex];
                const fifth = scaleNotes[fifthIndex];
                
                const chordNotes = [note, third, fifth];
                const symbol = determineTriadSymbol(note, third, fifth, root);
                const degrees = [(index + 1).toString(), (thirdIndex + 1).toString(), (fifthIndex + 1).toString()];
                
                triads.push({
                    symbol: symbol,
                    notes: chordNotes,
                    degrees: degrees
                });
            });
            
            return triads;
        }

        // Generate seventh chords from a scale
        function generateSeventhsFromScale(scaleNotes, root) {
            const sevenths = [];
            
            // Generate a seventh chord for each scale degree by stacking thirds
            scaleNotes.forEach((note, index) => {
                const thirdIndex = (index + 2) % scaleNotes.length;
                const fifthIndex = (index + 4) % scaleNotes.length;
                const seventhIndex = (index + 6) % scaleNotes.length;
                
                const third = scaleNotes[thirdIndex];
                const fifth = scaleNotes[fifthIndex];
                const seventh = scaleNotes[seventhIndex];
                
                const chordNotes = [note, third, fifth, seventh];
                const symbol = determineSeventhSymbol(note, third, fifth, seventh, root);
                const degrees = [(index + 1).toString(), (thirdIndex + 1).toString(), (fifthIndex + 1).toString(), (seventhIndex + 1).toString()];
                
                sevenths.push({
                    symbol: symbol,
                    notes: chordNotes,
                    degrees: degrees
                });
            });
            
            return sevenths;
        }

        // Determine triad symbol based on intervals
        function determineTriadSymbol(root, third, fifth, keyRoot) {
            const rootSemi = noteToSemitone(root);
            const thirdInterval = (noteToSemitone(third) - rootSemi + 12) % 12;
            const fifthInterval = (noteToSemitone(fifth) - rootSemi + 12) % 12;
            
            if (thirdInterval === 4 && fifthInterval === 7) {
                return root; // Major
            } else if (thirdInterval === 3 && fifthInterval === 7) {
                return root + 'm'; // Minor
            } else if (thirdInterval === 3 && fifthInterval === 6) {
                return root + '°'; // Diminished
            } else if (thirdInterval === 4 && fifthInterval === 8) {
                return root + '+'; // Augmented
            } else {
                return root; // Default to major
            }
        }

        // Determine seventh chord symbol
        function determineSeventhSymbol(root, third, fifth, seventh, keyRoot) {
            const baseSymbol = determineTriadSymbol(root, third, fifth, keyRoot);
            const rootSemi = noteToSemitone(root);
            const seventhInterval = (noteToSemitone(seventh) - rootSemi + 12) % 12;
            
            if (seventhInterval === 11) { // Major 7th
                if (baseSymbol === root) return root + 'maj7';
                if (baseSymbol === root + 'm') return root + 'mMaj7';
                if (baseSymbol === root + '+') return root + '+maj7';
            } else if (seventhInterval === 10) { // Minor 7th
                if (baseSymbol === root) return root + '7';
                if (baseSymbol === root + 'm') return root + 'm7';
                if (baseSymbol === root + '°') return root + 'm7♭5';
            } else if (seventhInterval === 9) { // Diminished 7th
                return root + '°7';
            }
            
            return baseSymbol + '7'; // Default
        }

        // Generate limited triads for pentatonic and other short scales
        function generateLimitedTriads(scaleNotes, root) {
            const triads = [];
            
            if (scaleNotes.length === 5) { // Pentatonic
                // Generate triads from the first few scale degrees
                for (let i = 0; i < 3; i++) {
                    const chordRoot = scaleNotes[i];
                    const third = scaleNotes[(i + 2) % scaleNotes.length];
                    const fifth = scaleNotes[(i + 4) % scaleNotes.length];
                    
                    const symbol = determineTriadSymbol(chordRoot, third, fifth, root);
                    
                    triads.push({
                        symbol,
                        notes: [chordRoot, third, fifth],
                        degrees: ['1', '3', '5']
                    });
                }
            } else if (scaleNotes.length === 6) { // Whole tone
                // Whole tone scales create augmented triads
                for (let i = 0; i < 3; i++) {
                    const chordRoot = scaleNotes[i];
                    const third = scaleNotes[(i + 2) % scaleNotes.length];
                    const fifth = scaleNotes[(i + 4) % scaleNotes.length];
                    
                    triads.push({
                        symbol: chordRoot + '+',
                        notes: [chordRoot, third, fifth],
                        degrees: ['1', '3', '♯5']
                    });
                }
            }
            
            return triads;
        }

        // Generate limited sevenths for shorter scales
        function generateLimitedSevenths(scaleNotes, root) {
            const sevenths = [];
            
            if (scaleNotes.length === 5) { // Pentatonic - create some extended chords
                for (let i = 0; i < 2; i++) {
                    const chordRoot = scaleNotes[i];
                    const third = scaleNotes[(i + 2) % scaleNotes.length];
                    const fifth = scaleNotes[(i + 4) % scaleNotes.length];
                    // Add 6th or 9th instead of 7th for pentatonic flavor
                    const extension = scaleNotes[(i + 1) % scaleNotes.length];
                    
                    sevenths.push({
                        symbol: chordRoot + '6/9',
                        notes: [chordRoot, third, fifth, extension],
                        degrees: ['1', '3', '5', '6/9']
                    });
                }
            } else if (scaleNotes.length === 6) { // Whole tone
                for (let i = 0; i < 2; i++) {
                    const chordRoot = scaleNotes[i];
                    const third = scaleNotes[(i + 2) % scaleNotes.length];
                    const fifth = scaleNotes[(i + 4) % scaleNotes.length];
                    const seventh = scaleNotes[(i + 5) % scaleNotes.length];
                    
                    sevenths.push({
                        symbol: chordRoot + '+maj7',
                        notes: [chordRoot, third, fifth, seventh],
                        degrees: ['1', '3', '♯5', '7']
                    });
                }
            }
            
            return sevenths;
        }

        // Barry Harris chord generation (simplified versions)
        function generateBarryHarrisTriads(scaleNotes, root, scaleType) {
            const triads = [];
            
            // Define the base chords for Barry Harris system
            const baseChordType = scaleType === 'majorSixDiminished' ? '6' : 'm6';
            const baseDimType = '°7';
            
            // Get base chord notes (using root position)
            const base6ChordNotes = buildChordFromScale(scaleNotes, 0, [0, 2, 4, 6]); // C6 or Cm6
            const baseDimChordNotes = buildChordFromScale(scaleNotes, 1, [0, 2, 4, 6]); // D°7
            
            // Generate alternating 6th chords and diminished 7th chords with slash notation
            for (let i = 0; i < scaleNotes.length; i++) {
                const bassNote = scaleNotes[i];
                
                if (i % 2 === 0) {
                    // Even positions: 6th chord inversions
                    let symbol, notes;
                    if (i === 0) {
                        // Root position
                        symbol = root + baseChordType;
                        notes = base6ChordNotes;
                    } else {
                        // Slash chord (inversion)
                        symbol = root + baseChordType + '/' + bassNote;
                        notes = base6ChordNotes; // Same chord notes, different bass
                    }
                    
                    triads.push({
                        symbol: symbol,
                        notes: notes,
                        degrees: scaleType === 'majorSixDiminished' ? ['1', '3', '5', '6'] : ['1', '♭3', '5', '6']
                    });
                } else {
                    // Odd positions: Diminished 7th chord inversions
                    const dimRoot = scaleNotes[1]; // Always D in C major/minor
                    let symbol, notes;
                    if (i === 1) {
                        // Root position
                        symbol = dimRoot + baseDimType;
                        notes = baseDimChordNotes;
                    } else {
                        // Slash chord (inversion)
                        symbol = dimRoot + baseDimType + '/' + bassNote;
                        notes = baseDimChordNotes; // Same chord notes, different bass
                    }
                    
                    triads.push({
                        symbol: symbol,
                        notes: notes,
                        degrees: ['1', '♭3', '♭5', '♭♭7']
                    });
                }
            }
            
            return triads;
        }
        
        // Helper function to build chord from scale starting at specific position
        function buildChordFromScale(scaleNotes, startIndex, intervals) {
            const chord = [];
            for (let interval of intervals) {
                const noteIndex = (startIndex + interval) % scaleNotes.length;
                chord.push(scaleNotes[noteIndex]);
            }
            return chord;
        }

        function generateBarryHarrisSevenths(scaleNotes, root, scaleType) {
            return generateBarryHarrisTriads(scaleNotes, root, scaleType); // Same for now
        }

        function getAvailableScales(key) {
            const baseScales = [
                'major',
                'minor',
                'harmonicMinor',
                'melodicMinor',
                'dorian',
                'phrygian',
                'lydian',
                'mixolydian',
                'locrian',
                'dorianFlat2',
                'lydianAugmented',
                'lydianDominant',
                'mixolydianFlat6',
                'locrianSharp2',
                'altered',
                'majorPentatonic',
                'minorPentatonic',
                'wholeTone',
                'halfWholeDiminished',
                'wholeHalfDiminished',
                'majorSixDiminished',
                'minorSixDiminished'
            ];
            
            return baseScales;
        }

        function getCurrentScaleData() {
            // Handle null selectedKey (chromatic mode)
            if (!selectedKey) {
                return {
                    scale: ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'],
                    signature: 'All 12 notes',
                    triads: [],
                    sevenths: []
                };
            }
            
            const root = selectedKey.replace(/m$/, '').split('/')[0];
            const scaleNotes = generateScaleNotes(root, selectedScale);
            
            // Generate chords for the current scale
            const triads = generateTriadsFromScale(scaleNotes, root);
            const sevenths = generateSeventhsFromScale(scaleNotes, root);
            
            return {
                scale: scaleNotes,
                signature: getScaleSignature(selectedScale, root),
                triads: triads,
                sevenths: sevenths
            };
        }

        function getScaleSignature(scaleType, root) {
            const scaleInfo = {
                major: 'Major scale',
                minor: 'Natural minor scale',
                harmonicMinor: 'Harmonic minor scale (raised 7th)',
                melodicMinor: 'Melodic minor scale (raised 6th & 7th)',
                dorian: 'Dorian mode (minor with raised 6th)',
                phrygian: 'Phrygian mode (minor with lowered 2nd)',
                lydian: 'Lydian mode (major with raised 4th)',
                mixolydian: 'Mixolydian mode (major with lowered 7th)',
                locrian: 'Locrian mode (diminished)',
                dorianFlat2: 'Dorian ♭2 (Mode II of melodic minor)',
                lydianAugmented: 'Lydian Augmented (Mode III of melodic minor)',
                lydianDominant: 'Lydian Dominant (Mode IV of melodic minor)',
                mixolydianFlat6: 'Mixolydian ♭6 (Mode V of melodic minor)',
                locrianSharp2: 'Locrian ♯2 (Mode VI of melodic minor)',
                altered: 'Altered scale (Mode VII of melodic minor)',
                majorPentatonic: 'Major pentatonic scale (5 notes)',
                minorPentatonic: 'Minor pentatonic scale (5 notes)',
                wholeTone: 'Whole tone scale (6 notes)',
                halfWholeDiminished: 'Half-whole diminished scale (8 notes)',
                wholeHalfDiminished: 'Whole-half diminished scale (8 notes)',
                majorSixDiminished: 'Major 6 diminished scale (major 6 + dim 7)',
                minorSixDiminished: 'Minor 6 diminished scale (minor 6 + dim 7)'
            };
            
            return scaleInfo[scaleType] || 'Unknown scale';
        }

        // Initialize the app
        function init() {
            createCircleOfFifths();
            createInstrumentButtons();
            initializeTuning();
            generatePositionButtons(); // Generate position buttons on startup
            
            // Set default to chromatic scale (no key center)
            selectedScale = 'chromatic';
            selectedKey = null;
            
            // Initialize chromatic mode
            selectChromaticScale(); // This will properly set up all the initial state
            
            // Initialize custom chord controls
            updateCustomChordControls();
            
            // Initialize chord analysis window
            updateChordAnalysis();
            
            // Ensure key info is displayed on initialization
            setTimeout(() => {
                console.log('Force updating key info after init');
                updateKeyInfo();
                updateFretboard();
            }, 100);
        }

        function createCircleOfFifths() {
            const container = document.getElementById('circleOfFifths');
            const centerX = 200;
            const centerY = 200;
            const majorRadius = 160;
            const minorRadius = 110;

            // Major keys (outer circle)
            const majorKeys = ['C', 'G', 'D', 'A', 'E', 'B', 'F♯/G♭', 'D♭', 'A♭', 'E♭', 'B♭', 'F'];
            majorKeys.forEach((key, index) => {
                const angle = (index * 30 - 90) * Math.PI / 180;
                const x = centerX + majorRadius * Math.cos(angle) - 30;
                const y = centerY + majorRadius * Math.sin(angle) - 30;
                
                const button = document.createElement('button');
                button.className = 'circle-button major-key';
                button.innerHTML = key;
                button.style.left = x + 'px';
                button.style.top = y + 'px';
                button.onclick = () => selectKey(key);
                container.appendChild(button);
            });

            // Minor keys (inner circle)
            const minorKeys = ['Am', 'Em', 'Bm', 'F♯m', 'C♯m', 'G♯m', 'D♯m/E♭m', 'B♭m', 'Fm', 'Cm', 'Gm', 'Dm'];
            minorKeys.forEach((key, index) => {
                const angle = (index * 30 - 90) * Math.PI / 180;
                const x = centerX + minorRadius * Math.cos(angle) - 30;
                const y = centerY + minorRadius * Math.sin(angle) - 30;
                
                const button = document.createElement('button');
                button.className = 'circle-button minor-key';
                button.innerHTML = key;
                button.style.left = x + 'px';
                button.style.top = y + 'px';
                button.onclick = () => selectKey(key);
                container.appendChild(button);
            });
        }

        function createInstrumentButtons() {
            const container = document.getElementById('instrumentButtons');
            Object.keys(instruments).forEach(key => {
                const button = document.createElement('button');
                button.className = 'instrument-btn';
                button.textContent = instruments[key].name;
                button.onclick = () => selectInstrument(key);
                container.appendChild(button);
            });
        }

        function initializeTuning() {
            const instrument = instruments[selectedInstrument];
            currentTuning = [...instrument.defaultTuning];
            createTuningControls();
        }

        function createTuningControls() {
            const container = document.getElementById('stringTunings');
            const instrument = instruments[selectedInstrument];
            
            container.innerHTML = '';
            
            // Reverse the strings array so String 1 is the highest pitch (thinnest) string
            const reversedStrings = [...instrument.strings].reverse();
            const reversedTuning = [...currentTuning].reverse();
            
            reversedStrings.forEach((string, index) => {
                const stringDiv = document.createElement('div');
                stringDiv.className = 'string-tuning';
                
                const label = document.createElement('label');
                label.textContent = `String ${index + 1}:`;
                
                const select = document.createElement('select');
                select.id = `tuning-${index}`;
                
                allNotes.forEach(note => {
                    const option = document.createElement('option');
                    option.value = note;
                    option.textContent = note;
                    if (note === reversedTuning[index]) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                
                select.onchange = (e) => {
                    // Calculate the original index (reverse the index back)
                    const originalIndex = instrument.strings.length - 1 - index;
                    currentTuning[originalIndex] = e.target.value;
                    updateFretboard();
                };
                
                stringDiv.appendChild(label);
                stringDiv.appendChild(select);
                container.appendChild(stringDiv);
            });
        }

        // Transpose chord from one key to another
        function transposeChord(chordSymbol, fromKey, toKey) {
            const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const flatScale = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
            const enharmonicMap = {
                'D♭': 'C#', 'Db': 'C#', 'E♭': 'D#', 'Eb': 'D#', 
                'G♭': 'F#', 'Gb': 'F#', 'A♭': 'G#', 'Ab': 'G#', 
                'B♭': 'A#', 'Bb': 'A#', 'C♭': 'B', 'Cb': 'B',
                'C#': 'D♭', 'D#': 'E♭', 'F#': 'G♭', 'G#': 'A♭', 'A#': 'B♭'
            };
            
            // Determine if target key uses flats (check both ASCII and Unicode)
            const flatKeys = ['F', 'B♭', 'Bb', 'E♭', 'Eb', 'A♭', 'Ab', 'D♭', 'Db', 'G♭', 'Gb', 'C♭', 'Cb'];
            const cleanToKey = toKey.replace('m', '').split('/')[0]; // Handle F♯/G♭ format
            const useFlatNotation = flatKeys.includes(cleanToKey);
            
            // Parse chord to get root note and quality
            let rootNote = chordSymbol.charAt(0);
            let accidental = '';
            let quality = '';
            
            if (chordSymbol.length > 1 && (chordSymbol[1] === '#' || chordSymbol[1] === 'b' || chordSymbol[1] === '♯' || chordSymbol[1] === '♭')) {
                accidental = chordSymbol[1];
                rootNote += accidental;
                quality = chordSymbol.slice(2);
            } else {
                quality = chordSymbol.slice(1);
            }
            
            // Convert to sharp notation for calculation
            if (enharmonicMap[rootNote]) {
                rootNote = enharmonicMap[rootNote];
            }
            const cleanFromKey = fromKey.replace('m', '').split('/')[0];
            const calcFromKey = enharmonicMap[cleanFromKey] || cleanFromKey;
            const calcToKey = enharmonicMap[cleanToKey] || cleanToKey;
            
            // Calculate semitone difference
            const fromIndex = chromaticScale.indexOf(calcFromKey.replace('m', ''));
            const toIndex = chromaticScale.indexOf(calcToKey.replace('m', ''));
            const rootIndex = chromaticScale.indexOf(rootNote);
            
            if (fromIndex === -1 || toIndex === -1 || rootIndex === -1) {
                console.warn('Invalid key or chord:', { chordSymbol, fromKey, toKey });
                return chordSymbol;
            }
            
            const semitones = (toIndex - fromIndex + 12) % 12;
            const newRootIndex = (rootIndex + semitones) % 12;
            
            // Use appropriate scale based on target key
            const newRoot = useFlatNotation ? flatScale[newRootIndex] : chromaticScale[newRootIndex];
            
            return newRoot + quality;
        }
        
        // Transpose notes array from one key to another
        function transposeNotes(notes, fromKey, toKey) {
            if (!notes || !Array.isArray(notes)) return notes;
            return notes.map(note => {
                if (!note) return note;
                // Extract just the note name (without octave)
                const noteName = note.replace(/[0-9]/g, '');
                const transposed = transposeChord(noteName, fromKey, toKey);
                // If original had octave, preserve it (simplified)
                const octaveMatch = note.match(/[0-9]/);
                return octaveMatch ? transposed + octaveMatch[0] : transposed;
            });
        }

        function selectKey(key, force = false) {
            console.log('Selecting key:', key, 'force:', force);
            
            // Toggle key: if clicking already selected key, return to chromatic (unless forced)
            // BUT: Don't toggle if we're in a non-basic scale (modes, melodic minor modes, etc.)
            const nonBasicScales = ['dorian', 'phrygian', 'lydian', 'mixolydian', 'locrian', 
                                     'dorianFlat2', 'lydianAugmented', 'lydianDominant', 
                                     'mixolydianFlat6', 'locrianSharp2', 'altered',
                                     'harmonicMinor', 'melodicMinor', 'majorPentatonic', 
                                     'minorPentatonic', 'wholeTone', 'halfWholeDiminished',
                                     'wholeHalfDiminished', 'majorSixDiminished', 'minorSixDiminished'];
            
            if (!force && selectedKey === key && !nonBasicScales.includes(selectedScale)) {
                console.log('Key already selected, toggling to chromatic');
                selectChromaticScale();
                return;
            }
            
            const oldKey = selectedKey;
            selectedKey = key;
            
            // Clear chromatic mode when selecting a key
            if (selectedScale === 'chromatic') {
                selectedScale = 'major'; // Reset to major when leaving chromatic
            }
            
            // Clear custom chord when key changes
            clearCustomChord();
            
            // Determine appropriate default scale based on key - but only if using basic scales
            const basicScales = ['major', 'minor'];
            if (basicScales.includes(selectedScale)) {
                if (key.includes('m') && selectedScale === 'major') {
                    selectedScale = 'minor';
                } else if (!key.includes('m') && selectedScale === 'minor') {
                    selectedScale = 'major';
                }
            }
            // For other scales (modes, melodic minor modes, etc.), preserve the current scale
            
            console.log('Selected key:', selectedKey, 'Selected scale:', selectedScale);
            
            // Update the progression key dropdown to match ONLY if progression is NOT active
            // When progression is active, the dropdown controls per-measure keys
            const progressionKeySelect = document.getElementById('progressionKey');
            if (progressionKeySelect && !progressionActive) {
                progressionKeySelect.value = key;
                console.log('Updated progression dropdown to:', key);
            } else if (progressionActive) {
                console.log('Progression active - NOT updating dropdown, it controls measure keys');
            }
            
            // AUTO-TRANSPOSE: If progression is active and key changed, transpose all measures
            if (progressionActive && progressionMeasures.length > 0 && oldKey && oldKey !== key) {
                console.log(`Transposing progression from ${oldKey} to ${key}`);
                
                // Update the progression key variable
                progressionKey = key;
                
                // Only transpose measures that match the old progression key
                // Preserve measures with different localKey values (modulated sections)
                progressionMeasures = progressionMeasures.map(measure => {
                    if (!measure || !measure.chord) return measure;
                    
                    // If measure has a different localKey, preserve it
                    if (measure.localKey && measure.localKey !== oldKey) {
                        console.log(`Preserving measure with localKey ${measure.localKey}, not transposing`);
                        return measure;
                    }
                    
                    // Otherwise, transpose the chord and update localKey
                    return {
                        ...measure,
                        chord: {
                            ...measure.chord,
                            symbol: transposeChord(measure.chord.symbol, oldKey, key),
                            notes: transposeNotes(measure.chord.notes, oldKey, key)
                        },
                        localKey: key // Update localKey to match new progression key
                    };
                });
                
                // Update the staff UI with transposed chords
                updateProgressionChart();
                console.log('Progression transposed successfully');
            }
            
            // Reset fretboard zoom when key changes
            resetZoom();
            
            updateKeyInfo();
            updateFretboard();
            updateSelectedButtons();
            console.log('selectKey complete: Circle of Fifths and UI updated');
        }

        function selectChromaticScale() {
            console.log('Selecting chromatic scale');
            
            // Set chromatic mode
            selectedScale = 'chromatic';
            
            // Clear selected chord and custom chord
            selectedChord = null;
            clearCustomChord();
            
            // Reset fretboard zoom
            resetZoom();
            
            // Update UI
            updateKeyInfo();
            updateFretboard();
            
            // Clear Circle of Fifths selection
            document.querySelectorAll('.circle-button').forEach(btn => {
                btn.classList.remove('selected');
            });
        }

        function selectInstrument(instrument) {
            selectedInstrument = instrument;
            initializeTuning();
            generatePositionButtons(); // Add position buttons for the selected instrument
            updateFretboard();
            updateSelectedButtons();
        }

        function updateSelectedButtons() {
            // Update circle buttons - handle null selectedKey (chromatic mode)
            document.querySelectorAll('.circle-button').forEach(btn => {
                btn.classList.toggle('selected', selectedKey && btn.innerHTML === selectedKey);
            });
            
            // Update instrument buttons
            document.querySelectorAll('.instrument-btn').forEach((btn, index) => {
                const instrumentKeys = Object.keys(instruments);
                btn.classList.toggle('selected', instrumentKeys[index] === selectedInstrument);
            });
        }

        // Generate Roman numeral for a chord with proper HTML formatting
        function generateRomanNumeral(chordIndex, chordMode, key) {
            const isMinor = key.includes('m');
            
            switch(chordMode) {
                case 'triads':
                    if (!isMinor) {
                        const majorRomanNumerals = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'];
                        return majorRomanNumerals[chordIndex];
                    } else {
                        const minorRomanNumerals = ['i', 'ii°', '♭III', 'iv', 'v', '♭VI', '♭VII'];
                        return minorRomanNumerals[chordIndex];
                    }
                case 'sevenths':
                    if (!isMinor) {
                        const majorRomanNumerals = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'];
                        return majorRomanNumerals[chordIndex] + '<sup>7</sup>';
                    } else {
                        const minorRomanNumerals = ['i', 'ii°', '♭III', 'iv', 'v', '♭VI', '♭VII'];
                        return minorRomanNumerals[chordIndex] + '<sup>7</sup>';
                    }
                case 'secondary':
                    // Get the actual secondary dominant data
                    const secondaryChords = generateSecondaryDominants(key);
                    if (secondaryChords[chordIndex]) {
                        return `V<sup>7</sup>/${secondaryChords[chordIndex].target}`;
                    }
                    return 'V<sup>7</sup>';
                case 'diminished':
                    // Get the actual diminished passing chord data
                    const diminishedChords = generateDiminishedPassing(key);
                    if (diminishedChords[chordIndex] && diminishedChords[chordIndex].roman) {
                        return diminishedChords[chordIndex].roman;
                    }
                    return '°<sup>7</sup>';
            }
        }
        
        // Generate chord column HTML
        function generateChordColumn(chord, chordIndex, isSelected) {
            const roman = generateRomanNumeral(chordIndex, chordMode, selectedKey);
            
            // For secondary dominants, show both the scale degree and the V7/target
            let romanNumeralContent = '';
            if (chordMode === 'secondary' && chord.scaleDegree) {
                romanNumeralContent = `
                    <div class="scale-degree-roman">${chord.scaleDegree}</div>
                    <div class="function-roman">${roman}</div>
                `;
            } else {
                romanNumeralContent = `<div class="roman-numeral">${roman}</div>`;
            }
            
            return `
                <div class="chord-column ${isSelected ? 'selected' : ''}" 
                     onclick="selectChord(${chordIndex})">
                  
                  ${romanNumeralContent}
                  
                  <button class="chord-button ${isSelected ? 'selected' : ''}">
                    ${chord.symbol}
                  </button>
                  
                  <div class="note-members">
                    ${chord.notes.map((note, noteIndex) => 
                        `<div class="note-member">
                           <span class="degree-subscript">${chord.degrees[noteIndex]}</span>${note}
                         </div>`
                    ).join('')}
                  </div>
                </div>
            `;
        }

        function updateKeyInfo() {
            const container = document.getElementById('keyInfo');
            if (!container) {
                console.error('keyInfo container not found');
                return;
            }
            
            console.log('Updating key info for:', selectedKey, 'scale:', selectedScale);
            
            // Use the unified key data function
            const keyData = getCurrentKeyData();
            console.log('Key data:', keyData);
            
            if (keyData) {
                // Handle chromatic mode
                if (selectedScale === 'chromatic' || !selectedKey) {
                    container.innerHTML = `
                        <h4>Chromatic Scale</h4>
                        <p><strong>Scale Type:</strong> All 12 notes</p>
                        
                        <p><strong>Scale Notes:</strong></p>
                        <div class="scale-notes">
                            ${keyData.scale.map(note => 
                                `<span class="note-chip">${note}</span>`
                            ).join('')}
                        </div>
                        
                        <p style="margin-top: 15px;"><small>Chromatic scale shows all 12 notes with no key center. Click any key in the Circle of Fifths to see that key's scales and chords.</small></p>
                    `;
                    return;
                }
                
                const root = selectedKey.replace(/m$/, '').split('/')[0];
                
                // Check if we're viewing a local key (during measure selection)
                const isLocalKeyView = progressionActive && 
                                      selectedMeasureIndex !== null && 
                                      progressionMeasures[selectedMeasureIndex] && 
                                      progressionMeasures[selectedMeasureIndex].localKey !== window.originalProgressionKey;
                const localKeyBadge = isLocalKeyView ? '<span style="background: #4a90e2; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">LOCAL KEY</span>' : '';
                
                let chords = [];
                let chordModeTitle = '';
                
                // Get appropriate chord set based on mode
                switch(chordMode) {
                    case 'triads':
                        chords = keyData.triads || [];
                        chordModeTitle = 'Triads';
                        break;
                    case 'sevenths':
                        chords = keyData.sevenths || [];
                        chordModeTitle = '7th Chords';
                        break;
                    case 'secondary':
                        chords = generateSecondaryDominants(selectedKey);
                        chordModeTitle = 'Secondary Dominants';
                        break;
                    case 'diminished':
                        chords = generateDiminishedPassing(selectedKey);
                        chordModeTitle = 'Diminished Passing';
                        break;
                }

                // Generate scale selection buttons
                const availableScales = getAvailableScales(selectedKey);
                const scaleButtons = availableScales.map(scale => 
                    `<button class="scale-btn ${selectedScale === scale ? 'active' : ''}" 
                             onclick="selectScale('${scale}')">${scaleNames[scale]}</button>`
                ).join('');
                
                container.innerHTML = `
                    <h4>${root} ${scaleNames[selectedScale]}${localKeyBadge}</h4>
                    <p><strong>Scale Type:</strong> ${keyData.signature}</p>
                    
                    <div class="scale-selector">
                        <p><strong>Available Scales:</strong></p>
                        <div class="scale-buttons">
                            ${scaleButtons}
                        </div>
                    </div>
                    
                    <p><strong>Scale Notes:</strong></p>
                    <div class="scale-notes">
                        ${keyData.scale.map((note, index) => 
                            `<span class="note-chip ${index === 0 ? 'root' : ''}">${note}</span>`
                        ).join('')}
                    </div>
                    
                    <div class="chord-toggle">
                        <button class="${chordMode === 'triads' ? 'active' : ''}" onclick="toggleChordMode('triads')">Triads</button>
                        <button class="${chordMode === 'sevenths' ? 'active' : ''}" onclick="toggleChordMode('sevenths')">7th Chords</button>
                        ${isHomeScale() ? `
                        <button class="${chordMode === 'secondary' ? 'active' : ''}" onclick="toggleChordMode('secondary')">Secondary</button>
                        <button class="${chordMode === 'diminished' ? 'active' : ''}" onclick="toggleChordMode('diminished')">Diminished</button>
                        ` : ''}
                    </div>
                    
                    <p><strong>${chordModeTitle}:</strong></p>
                    <div class="chord-analysis-grid ${chordMode === 'diminished' ? 'diminished-mode' : ''}">
                        ${chords.map((chord, index) => 
                            generateChordColumn(chord, index, selectedChord && selectedChord.symbol === chord.symbol)
                        ).join('')}
                    </div>
                `;
            }
        }

        function isHomeScale() {
            // Allow secondary dominants and diminished passing chords for major and natural minor scales
            return selectedScale === 'major' || selectedScale === 'minor';
        }

        function toggleChordMode(mode) {
            chordMode = mode;
            selectedChord = null; // Clear selected chord when switching modes
            
            // If switching to an alternative scale and mode is secondary/diminished, switch to triads
            if (!isHomeScale() && (mode === 'secondary' || mode === 'diminished')) {
                chordMode = 'triads';
            }
            
            updateKeyInfo();
            updateFretboard();
        }

        // Custom chord creation functions
        function selectCustomChordNote(note, string, fret, event) {
            
            event.stopPropagation();
            
            // Clear preset chord selection when starting to build custom chord
            selectedChord = null;
            
            // Handle double-click for root selection
            const currentTime = Date.now();
            const lastClickTime = customChordClickCount[note] || 0;
            const isDoubleClick = (currentTime - lastClickTime) < 300;
            
            customChordClickCount[note] = currentTime;
            
            if (isDoubleClick) {
                // Double-click: make this note the root
                customChordRoot = note;
                console.log('Root changed to:', note);
            } else {
                // Single click: toggle note selection at this specific position
                const positionIndex = customChordPositions.findIndex(pos => 
                    pos.string === string && pos.fret === fret
                );
                
                if (positionIndex === -1) {
                    // Add note at this position
                    if (customChordPositions.length < 6) {
                        customChordPositions.push({ note, string, fret });
                        customChordNotes.push(note);
                        // First note becomes root by default
                        if (customChordNotes.length === 1) {
                            customChordRoot = note;
                        }
                    }
                } else {
                    // Position is already selected
                    if (customChordPositions.length > 1 && note !== customChordRoot) {
                        // Clicking an existing chord tone (not current root) makes it the new root
                        customChordRoot = note;
                        console.log('New root selected:', note);
                        console.log('Current customChordNotes:', customChordNotes);
                        console.log('All notes in order selected:', customChordNotes);
                    } else {
                        // Remove note (original behavior for current root or single note)
                        customChordPositions.splice(positionIndex, 1);
                        customChordNotes.splice(positionIndex, 1);
                        // If we removed the root, make first remaining note the root
                        if (customChordRoot === note && customChordNotes.length > 0) {
                            customChordRoot = customChordNotes[0];
                        } else if (customChordNotes.length === 0) {
                            customChordRoot = null;
                        }
                    }
                }
            }
            
            // Removed auto-population - user must manually add chord using "Add to Progression" button
            
            // Update UI - this will hide preset chord colors and show custom chord colors
            updateCustomChordControls();
            updateFretboard();
        }
        
        function updateCustomChordControls() {
            const playButton = document.getElementById('playCustomChordBtn');
            const addButton = document.getElementById('addCustomChordBtn');
            
            if (playButton) {
                playButton.disabled = customChordNotes.length < 1;
            }            if (addButton) {
                addButton.disabled = customChordNotes.length < 3;
            }
            
            const statusDiv = document.getElementById('customChordStatus');
            if (statusDiv) {
                if (customChordNotes.length === 0) {
                    statusDiv.innerHTML = '<small>Click notes to build chord • Selected measure will auto-populate if progression is active</small>';
                } else {
                    const noteList = customChordNotes.join(', ');
                    const rootText = customChordRoot ? ` (Root: ${customChordRoot})` : '';
                    statusDiv.innerHTML = `<small>Notes: ${noteList}${rootText}</small>`;
                }
            }
            
            // Update chord analysis
            updateChordAnalysis();
        }
        
        function updateChordAnalysis() {
            const notesDiv = document.getElementById('currentNotes');
            const suggestionsDiv = document.getElementById('chordSuggestions');
            const suggestionsList = document.getElementById('suggestionsList');
            
            if (customChordNotes.length === 0) {
                notesDiv.innerHTML = '<span class="no-notes">Click notes to build chord</span>';
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            // Display notes with scale degrees
            const notesWithDegrees = customChordNotes.map(note => {
                const degree = calculateScaleDegreeFromRoot(note, customChordRoot);
                return `<span class="note-with-degree">${note}<span class="degree-subscript">${degree}</span></span>`;
            }).join(' ');
            
            notesDiv.innerHTML = notesWithDegrees;
            
            // Show suggestions if 1+ notes (changed from 2+ to include single notes)
            if (customChordNotes.length >= 1) {
                const suggestions = customChordNotes.length >= 2 ? generateChordSuggestions() : [];
                
                // Check for perfect chord matches (100% completeness) to update custom button
                let customChordName = `Custom (${customChordNotes.join('-')})`;
                let isPerfectMatch = false;
                
                if (customChordNotes.length >= 3 && suggestions.length > 0) {
                    // Calculate intervals to find perfect matches
                    const rootSemitone = noteToSemitone(customChordRoot);
                    const intervals = customChordNotes.map(note => {
                        return (noteToSemitone(note) - rootSemitone + 12) % 12;
                    }).sort((a, b) => a - b);
                    
                    // Find the highest priority perfect match
                    let bestMatch = null;
                    let bestPriority = Infinity;
                    
                    Object.entries(CHORD_TEMPLATES).forEach(([templateName, template]) => {
                        const inputSet = new Set(intervals);
                        const templateSet = new Set(template.intervals);
                        
                        // Check for exact match (same intervals, no extras, no missing)
                        const isExactMatch = inputSet.size === templateSet.size && 
                                           template.intervals.every(interval => inputSet.has(interval)) &&
                                           intervals.every(interval => templateSet.has(interval));
                        
                        if (isExactMatch && template.priority < bestPriority) {
                            // Check exclusion rules
                            const isExcluded = template.excludeIf && template.excludeIf.some(excluded => inputSet.has(excluded));
                            if (!isExcluded) {
                                bestMatch = template;
                                bestPriority = template.priority;
                            }
                        }
                    });
                    
                    if (bestMatch) {
                        customChordName = customChordRoot + bestMatch.symbol;
                        isPerfectMatch = true;
                        console.log('Perfect chord match found:', customChordName, 'priority:', bestPriority);
                    }
                }
                
                // Create custom chord button with perfect match name if available
                let suggestionsHTML;
                if (isPerfectMatch) {
                    // Perfect match: make it generate proper chord notes, not custom
                    suggestionsHTML = `<span class="chord-suggestion custom-chord perfect-match" onclick="selectChordSuggestion('${customChordName}', false)">${customChordName}</span>`;
                } else {
                    // No perfect match: show custom notes
                    suggestionsHTML = `<span class="chord-suggestion custom-chord" onclick="selectChordSuggestion('${customChordName}', true)">${customChordName}</span>`;
                }
                
                // Add generated suggestions if available (excluding the perfect match to avoid duplicates)
                if (suggestions.length > 0) {
                    const filteredSuggestions = isPerfectMatch ? 
                        suggestions.filter(chord => chord !== customChordName) : 
                        suggestions;
                    
                    suggestionsHTML += filteredSuggestions.map(chord => 
                        `<span class="chord-suggestion" onclick="selectChordSuggestion('${chord}', false)">${chord}</span>`
                    ).join('');
                }
                
                // Add clear button at the end
                suggestionsHTML += `<span class="chord-suggestion clear-button" onclick="clearCustomChord()">Clear</span>`;
                
                suggestionsList.innerHTML = suggestionsHTML;
                suggestionsDiv.style.display = 'block';
            } else {
                suggestionsDiv.style.display = 'none';
            }
        }
        
        function calculateScaleDegreeFromRoot(note, root) {
            if (!root) return '?';
            
            const rootSemitone = noteToSemitone(root);
            const noteSemitone = noteToSemitone(note);
            const interval = (noteSemitone - rootSemitone + 12) % 12;
            
            const degreeMap = {
                0: '1', 1: 'm2', 2: 'M2', 3: 'm3', 4: 'M3', 5: 'P4',
                6: 'dim5', 7: 'P5', 8: 'aug5', 9: 'M6', 10: 'm7', 11: 'M7'
            };
            
            return degreeMap[interval] || '?';
        }
        
        function generateChordSuggestions() {
            if (customChordNotes.length < 2) return [];
            
            if (!customChordRoot) {
                console.warn('No root note selected for chord analysis');
                return [];
            }
            
            const suggestions = [];
            
            // Calculate intervals from root
            const rootSemitone = noteToSemitone(customChordRoot);
            const intervals = customChordNotes.map(note => {
                return (noteToSemitone(note) - rootSemitone + 12) % 12;
            }).sort((a, b) => a - b);
            
            console.log('Analyzing intervals:', intervals, 'from root:', customChordRoot);
            
            // 1. Generate slash chord suggestions (highest priority)
            const slashSuggestions = generateSlashChordSuggestions(intervals, customChordNotes);
            suggestions.push(...slashSuggestions);
            
            // 2. Test all chord templates against input
            Object.entries(CHORD_TEMPLATES).forEach(([templateName, template]) => {
                const score = scoreChordMatch(intervals, template);
                
                if (score > 0) {
                    let chordSymbol = customChordRoot + template.symbol;
                    
                    // Add notation for incomplete chords
                    const missingIntervals = template.intervals.filter(interval => !intervals.includes(interval));
                    if (missingIntervals.length > 0) {
                        // Check for specific missing notes
                        if (missingIntervals.includes(7) && template.intervals.includes(7)) {
                            chordSymbol += ' (no 5th)';
                        } else if (missingIntervals.includes(4) && template.intervals.includes(4) && missingIntervals.includes(3) && template.intervals.includes(3)) {
                            chordSymbol += ' (no 3rd)';
                        }
                    }
                    
                    suggestions.push({
                        symbol: chordSymbol,
                        score: score,
                        priority: template.priority,
                        type: template.type
                    });
                }
            });
            
            // 3. Sort suggestions by priority (lower = higher priority) then by score
            suggestions.sort((a, b) => {
                if (a.priority !== b.priority) {
                    return a.priority - b.priority;
                }
                return b.score - a.score;
            });
            
            console.log('All suggestions before filtering:', suggestions.map(s => `${s.symbol} (p:${s.priority}, s:${s.score.toFixed(2)})`));
            
            // 4. Remove duplicates and return top 8 unique suggestions (increased from 6)
            const uniqueSuggestions = [];
            const seenSymbols = new Set();
            
            for (let suggestion of suggestions) {
                if (!seenSymbols.has(suggestion.symbol) && uniqueSuggestions.length < 8) {
                    seenSymbols.add(suggestion.symbol);
                    uniqueSuggestions.push(suggestion.symbol);
                }
            }
            
            console.log('Final chord suggestions:', uniqueSuggestions);
            return uniqueSuggestions;
        }
        
        function autoAdvanceToNextMeasureFixed() {
            if (progressionActive) {
                // Use unified selectedMeasureIndex for all chord inputs
                if (selectedMeasureIndex !== null && progressionMeasures.length > 0) {
                    const nextMeasureIndex = selectedMeasureIndex + 1;
                    
                    if (nextMeasureIndex < progressionMeasures.length) {
                        selectedMeasureIndex = nextMeasureIndex;
                        console.log('Advanced to next measure:', selectedMeasureIndex);
                        selectMeasure(selectedMeasureIndex); // Update key display for new measure
                    } else {
                        // End of progression reached - wrap to beginning
                        selectedMeasureIndex = 0;
                        console.log('Wrapped to beginning of progression');
                        selectMeasure(selectedMeasureIndex); // Update key display for new measure
                    }
                } else {
                    console.log('No valid measure to advance from');
                }
            }
        }
        
        function selectChordSuggestion(chordName, isCustom = false) {
            console.log('=== CHORD SUGGESTION CLICKED ===');
            console.log('Chord name:', chordName);
            console.log('Is custom:', isCustom);
            console.log('Current customChordNotes:', customChordNotes);
            console.log('Current customChordRoot:', customChordRoot);
            console.log('progressionActive:', progressionActive);
            console.log('selectedMeasureIndex:', selectedMeasureIndex);
            
            // Clear position-based highlighting and restore octave highlighting
            customChordPositions = [];
            
            if (progressionActive && selectedMeasureIndex !== null) {
                console.log('ENTERING PROGRESSION MODE - storing chord');
                // IN PROGRESSION MODE: Add chord to staff
                const customChord = {
                    symbol: chordName,
                    notes: [...customChordNotes],
                    root: customChordRoot,
                    isCustom: isCustom,
                    degrees: customChordNotes.map(note => calculateScaleDegreeFromRoot(note, customChordRoot))
                };
                
                console.log('=== STORING CUSTOM CHORD (selectChordSuggestion) ===');
                console.log('Chord name:', chordName);
                console.log('Chord notes being stored:', customChord.notes);
                console.log('Custom chord notes source:', customChordNotes);
                console.log('Chord root:', customChord.root);
                console.log('Is custom:', customChord.isCustom);
                
                progressionMeasures[selectedMeasureIndex] = {
                    ...progressionMeasures[selectedMeasureIndex],
                    chord: customChord
                };
                updateProgressionChart();
                
                // Auto-advance to next measure
                autoAdvanceToNextMeasureFixed();
                
                clearCustomChord();
            } else {
                // NOT IN PROGRESSION MODE: Play the chord and update fretboard
                if (isCustom) {
                    // Play the exact notes the user selected
                    console.log('Playing custom notes (user selected):', customChordNotes);
                    playChordFromNotes(customChordNotes);
                    
                    // Update selectedChord so fretboard shows these notes with octave highlighting
                    selectedChord = {
                        symbol: chordName,
                        notes: [...customChordNotes],
                        root: customChordRoot
                    };
                } else {
                    // Parse and play the suggested chord
                    console.log('Generating chord for suggestion:', chordName);
                    const actualChordNotes = parseChordSymbol(chordName, customChordRoot);
                    console.log('Generated notes for', chordName, ':', actualChordNotes);
                    playChordFromNotes(actualChordNotes);
                    
                    // Update selectedChord so fretboard shows these notes with octave highlighting
                    selectedChord = {
                        symbol: chordName,
                        notes: actualChordNotes,
                        root: customChordRoot
                    };
                }
                
                // Update the fretboard to show the new chord with octave highlighting
                updateFretboard();
            }
        }
        
        function autoPopulateMeasure() {
            if (selectedMeasureIndex !== null && customChordNotes.length >= 3) {
                const customChord = {
                    symbol: generateCustomChordName(),
                    notes: [...customChordNotes],
                    root: customChordRoot,
                    isCustom: true,
                    degrees: calculateScaleDegrees(customChordNotes)
                };
                
                console.log('=== STORING CUSTOM CHORD (autoPopulateMeasure) ===');
                console.log('Chord symbol:', customChord.symbol);
                console.log('Chord notes:', customChord.notes);
                console.log('Chord root:', customChord.root);
                console.log('Is custom:', customChord.isCustom);
                console.log('Custom chord notes source:', customChordNotes);
                
                // Update measure object with custom chord, preserving localKey and timeSignature
                progressionMeasures[selectedMeasureIndex] = {
                    ...progressionMeasures[selectedMeasureIndex],
                    chord: customChord
                };
                updateProgressionChart();
                
                // Clear the custom chord after adding
                clearCustomChord();
            }
        }
        
        function autoAdvanceToNextMeasure() {
            if (progressionActive && selectedMeasureIndex !== null) {
                const nextMeasureIndex = selectedMeasureIndex + 1;
                if (nextMeasureIndex < progressionMeasures.length) {
                    // Move to next measure
                    selectedMeasureIndex = nextMeasureIndex;
                    highlightSelectedMeasure(nextMeasureIndex);
                } else {
                    // If at the end, cycle back to the beginning
                    selectedMeasureIndex = 0;
                    highlightSelectedMeasure(0);
                }
            }
        }
        
        function playCustomChord() {
            if (customChordNotes.length >= 1) {
                playChordFromNotes(customChordNotes);
            }
        }
        
        // New function to play chord from note array
        function playChordFromNotes(noteArray) {
            if (!audioContext || noteArray.length === 0) return;
            
            console.log('=== AUDIO PLAYBACK ===');
            console.log('Input notes to play:', noteArray);
            
            try {
                const frequencies = noteArray.map(note => {
                    const semitone = noteToSemitone(note);
                    const freq = 440 * Math.pow(2, (semitone - 9) / 12); // A4 = 440Hz
                    console.log(`♪ ${note} → semitone ${semitone} → ${freq.toFixed(2)} Hz`);
                    return freq;
                });
                
                console.log('All frequencies being played:', frequencies.map(f => f.toFixed(2) + ' Hz'));
                playFrequencies(frequencies, 1.5); // Play for 1.5 seconds
            } catch (error) {
                console.error('Error playing custom chord:', error);
            }
        }
        
        // Extract root note from chord symbol (e.g., "Cmaj7" -> "C", "F#m" -> "F#", "Bb7" -> "Bb")
        function extractRootNote(chordSymbol) {
            if (!chordSymbol) return null;
            
            // Match note name (A-G) with optional accidental (# or b or ♯ or ♭)
            const match = chordSymbol.match(/^([A-G][#b♯♭]?)/);
            return match ? match[1] : null;
        }
        
        // New function to play chord from symbol
        function playChordFromSymbol(chordSymbol, rootNote) {
            if (!audioContext || !rootNote) return;
            
            try {
                // Parse the chord symbol to determine notes
                const chordNotes = parseChordSymbol(chordSymbol, rootNote);
                const frequencies = chordNotes.map(note => {
                    const semitone = noteToSemitone(note);
                    return 440 * Math.pow(2, (semitone - 9) / 12);
                });
                
                playFrequencies(frequencies, 1.5);
                console.log('Playing chord:', chordSymbol, 'notes:', chordNotes, 'frequencies:', frequencies);
            } catch (error) {
                console.error('Error playing chord symbol:', error);
            }
        }
        
        // Helper function to parse chord symbols into notes
        function parseChordSymbol(chordSymbol, rootNote) {
            console.log('=== PARSING CHORD SYMBOL ===');
            console.log('Chord symbol:', chordSymbol, 'Root note:', rootNote);
            
            // For slash chords, extract the upper structure and bass note
            if (chordSymbol.includes('/')) {
                const [upperChord, bassNote] = chordSymbol.split('/');
                console.log('Slash chord detected - Upper:', upperChord, 'Bass:', bassNote);
                
                // Generate the upper chord notes
                const upperChordNotes = generateChordNotesFromSymbol(upperChord, rootNote);
                console.log('Upper chord notes:', upperChordNotes);
                
                // Add bass note if it's not already in the chord
                const finalNotes = upperChordNotes.includes(bassNote) ? 
                    upperChordNotes : 
                    [bassNote, ...upperChordNotes];
                    
                console.log('Final slash chord notes:', finalNotes);
                return finalNotes;
            }
            
            // For regular chords, generate the actual chord notes from the symbol
            return generateChordNotesFromSymbol(chordSymbol, rootNote);
        }
        
        // Generate actual chord notes from chord symbol
        function generateChordNotesFromSymbol(chordSymbol, rootNote) {
            console.log('=== CHORD GENERATION ===');
            console.log('Generating notes for chord symbol:', chordSymbol, 'with root:', rootNote);
            
            if (!rootNote) {
                console.log('No root note, using custom notes:', customChordNotes);
                return [...customChordNotes];
            }
            
            // Remove the root note from the symbol to get the chord type
            const chordType = chordSymbol.replace(rootNote, '');
            console.log('Extracted chord type:', chordType);
            
            // Find the matching template
            const template = Object.values(CHORD_TEMPLATES).find(t => t.symbol === chordType);
            if (!template) {
                console.log('No template found for chord type:', chordType, 'using custom notes');
                return [...customChordNotes];
            }
            
            console.log('Found template:', template);
            console.log('Template intervals:', template.intervals);
            
            // Generate the chord notes using the template intervals
            const rootSemitone = noteToSemitone(rootNote);
            console.log('Root semitone:', rootSemitone);
            
            const chordNotes = template.intervals.map((interval, index) => {
                const noteSemitone = (rootSemitone + interval) % 12;
                
                // Use enharmonic spelling that matches the key/scale context
                const notes = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
                const noteName = notes[noteSemitone];
                console.log(`Interval ${interval} → semitone ${noteSemitone} → note ${noteName}`);
                return noteName;
            });
            
            console.log('Generated chord notes for', chordSymbol, ':', chordNotes);
            return chordNotes;
        }
        
        // Enhanced audio playback function
        function playFrequencies(frequencies, duration = 1.5) {
            if (!audioContext) return;
            
            try {
                const oscillators = [];
                const gainNode = audioContext.createGain();
                
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0.1 / frequencies.length, audioContext.currentTime); // Adjust volume based on chord size
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                frequencies.forEach(freq => {
                    const oscillator = audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine';
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                    oscillators.push(oscillator);
                });
                
                return new Promise(resolve => {
                    setTimeout(resolve, duration * 1000);
                });
            } catch (error) {
                console.error('Error playing frequencies:', error);
            }
        }
        
        function addCustomChordToProgression() {
            if (customChordNotes.length < 3) return;
            
            const selectedIndex = selectedMeasureIndex;
            if (selectedIndex === null) {
                // Auto-select next empty measure
                const emptyIndex = chordProgression.findIndex(chord => chord === null);
                if (emptyIndex !== -1) {
                    selectedMeasureIndex = emptyIndex;
                } else {
                    alert('No measure selected and progression is full');
                    return;
                }
            }
            
            // Generate chord name from custom chord
            const chordName = generateChordName(customChordNotes, customChordRoot);
            
            // Add to progression
            chordProgression[selectedMeasureIndex] = chordName;
            
            // Update display
            updateStaff();
            
            // AUTO-ADVANCE: Move to next measure after adding chord
            autoAdvanceToNextMeasure();
            
            // Clear custom chord
            clearCustomChord();
            
            updateFretboard();
        }

        function generateChordName(notes, root) {
            if (!root) root = notes[0];
            
            // Basic chord recognition logic
            const sortedNotes = [...notes].sort();
            const intervals = calculateIntervals(sortedNotes, root);
            
            // Simple chord naming based on intervals
            if (intervals.includes('M3') && intervals.includes('P5')) {
                return root; // Major triad
            } else if (intervals.includes('m3') && intervals.includes('P5')) {
                return root + 'm'; // Minor triad
            } else if (intervals.includes('M3') && intervals.includes('A5')) {
                return root + 'aug'; // Augmented
            } else if (intervals.includes('m3') && intervals.includes('d5')) {
                return root + 'dim'; // Diminished
            } else {
                // Default to showing notes
                return sortedNotes.join('/');
            }
        }

        function calculateIntervals(notes, root) {
            const noteValues = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };
            
            const rootValue = noteValues[root];
            const intervals = [];
            
            notes.forEach(note => {
                const noteValue = noteValues[note];
                let interval = (noteValue - rootValue + 12) % 12;
                
                switch(interval) {
                    case 0: intervals.push('R'); break;
                    case 1: intervals.push('m2'); break;
                    case 2: intervals.push('M2'); break;
                    case 3: intervals.push('m3'); break;
                    case 4: intervals.push('M3'); break;
                    case 5: intervals.push('P4'); break;
                    case 6: intervals.push('TT'); break;
                    case 7: intervals.push('P5'); break;
                    case 8: intervals.push('m6'); break;
                    case 9: intervals.push('M6'); break;
                    case 10: intervals.push('m7'); break;
                    case 11: intervals.push('M7'); break;
                }
            });
            
            return intervals;
        }

        function clearCustomChord() {
            customChordNotes = [];
            customChordRoot = null;
            customChordClickCount = {};
            customChordPositions = []; // Clear position-based highlighting
            selectedChord = null; // Clear selected chord to return fretboard to scale view
            updateCustomChordControls();
            updateChordAnalysis(); // Make sure analysis window updates
            updateFretboard(); // Update fretboard to show just scale notes
        }

        function generateCustomChordName() {
            if (customChordNotes.length === 0) return '';
            
            // Simple naming: just list the notes with root first
            const orderedNotes = [customChordRoot, ...customChordNotes.filter(n => n !== customChordRoot)];
            return orderedNotes.join('');
        }

        function autoAdvanceToNextMeasure() {
            if (progressionActive && selectedMeasureIndex !== null) {
                const nextMeasureIndex = selectedMeasureIndex + 1;
                if (nextMeasureIndex < progressionMeasures.length) {
                    // Move to next measure
                    selectedMeasureIndex = nextMeasureIndex;
                    highlightSelectedMeasure(nextMeasureIndex);
                } else {
                    // If at the end, cycle back to the beginning
                    selectedMeasureIndex = 0;
                    highlightSelectedMeasure(0);
                }
            }
        }

        function addCustomChord(measureIndex = null) {
            if (customChordNotes.length < 3) return;
            
            // Create custom chord object
            const customChord = {
                symbol: generateCustomChordName(),
                notes: [...customChordNotes],
                root: customChordRoot,
                isCustom: true,
                degrees: calculateScaleDegrees(customChordNotes)
            };
            
            // Determine which measure to add to
            const targetMeasure = measureIndex !== null ? measureIndex : selectedMeasureIndex;
            
            // Add to progression
            if (targetMeasure < progressionMeasures.length) {
                progressionMeasures[targetMeasure] = {
                    ...progressionMeasures[targetMeasure],
                    chord: customChord
                };
                updateProgressionChart();
                
                // If we used the current measure, advance it (only during active progression)
                if (measureIndex === null && progressionActive) {
                    selectedMeasureIndex = (selectedMeasureIndex + 1) % progressionMeasures.length;
                    highlightSelectedMeasure();
                }
                
                // Update fretboard to show the new custom chord
                updateFretboard(customChord.notes);
            }
            
            // Clear selection
            clearCustomChord();
        }

        function calculateScaleDegrees(notes) {
            const keyData = getCurrentKeyData();
            if (!keyData || !keyData.scale) return notes.map(() => '?');
            
            return notes.map(note => {
                const noteIndex = keyData.scale.findIndex(scaleNote => 
                    noteToSemitone(scaleNote) === noteToSemitone(note)
                );
                return noteIndex !== -1 ? (noteIndex + 1).toString() : '?';
            });
        }

        function selectChord(chordIndex) {
            let chords = [];
            
            // Direct custom chord state clearing for immediate effect
            customChordNotes = [];
            customChordRoot = null;
            customChordClickCount = {};
            
            // Get appropriate chord set based on mode
            switch(chordMode) {
                case 'triads':
                case 'sevenths':
                    // Use unified key data function
                    const keyData = getCurrentKeyData();
                    chords = chordMode === 'triads' ? (keyData.triads || []) : (keyData.sevenths || []);
                    break;
                case 'secondary':
                    chords = generateSecondaryDominants(selectedKey);
                    break;
                case 'diminished':
                    chords = generateDiminishedPassing(selectedKey);
                    break;
            }

            // ALWAYS select the chord for fretboard visualization (don't toggle off)
            selectedChord = chords[chordIndex];
            
            // Play the selected chord
            if (chords[chordIndex] && chords[chordIndex].notes) {
                playChordFromNotes(chords[chordIndex].notes);
            }
            
            // Update UI after state changes
            updateCustomChordControls();
            updateChordAnalysis();

            // Clear any staff measure selection when selecting from chord buttons
            document.querySelectorAll('.measure-staff').forEach(measure => {
                measure.classList.remove('selected-measure');
            });

            // Update fretboard and key info
            updateKeyInfo();
            updateFretboard();
            
            // If progression is active, ALSO add chord to current measure
            if (progressionActive && progressionMeasures.length > 0) {
                console.log('=== ROMAN NUMERAL CHORD IN PROGRESSION ===');
                console.log('selectedMeasureIndex:', selectedMeasureIndex);
                console.log('progressionMeasures.length:', progressionMeasures.length);
                
                // Use selectedMeasureIndex for consistency with custom chord system
                const measureIndex = selectedMeasureIndex !== null ? selectedMeasureIndex : 0;
                console.log('Using measure index:', measureIndex);
                
                if (measureIndex < progressionMeasures.length) {
                    console.log('🎯 SUBDIVISION WORKFLOW START');
                    // Create a copy of the chord with mode and index information
                    const chordCopy = {
                        ...chords[chordIndex],
                        sourceMode: chordMode,
                        sourceIndex: chordIndex
                    };
                    
                    const currentMeasure = progressionMeasures[measureIndex];
                    console.log('📏 Current measure:', currentMeasure);
                    
                    const currentSubdivision = document.getElementById('measureSubdivision').value;
                    console.log('🎵 Current subdivision dropdown value:', currentSubdivision);
                    
                    // Get time signature to calculate beats
                    const timeSignature = currentMeasure.timeSignature || '4/4';
                    const [numerator, denominator] = timeSignature.split('/').map(Number);
                    const beatsPerMeasure = (numerator / denominator) * 4;
                    console.log(`⏱️  Time signature: ${timeSignature}, Beats per measure: ${beatsPerMeasure}`);
                    
                    const subdivisionDurations = {
                        'whole': 4, 'half': 2, 'dotted-half': 3,
                        'quarter': 1, 'dotted-quarter': 1.5,
                        'eighth': 0.5, 'dotted-eighth': 0.75
                    };
                    
                    // Initialize chords array if first chord in measure
                    if (!currentMeasure.chords) {
                        console.log('🆕 Initializing chords array for first chord in measure');
                        currentMeasure.chords = [];
                    } else {
                        console.log(`📊 Existing chords in measure: ${currentMeasure.chords.length}`);
                    }
                    
                    // Check if measure is already complete
                    let usedBeats = 0;
                    currentMeasure.chords.forEach(slot => {
                        if (slot.chord) {
                            const slotBeats = subdivisionDurations[slot.duration];
                            console.log(`   - ${slot.chord.symbol} (${slot.duration}): ${slotBeats} beats`);
                            usedBeats += slotBeats;
                        }
                    });
                    
                    const remainingBeats = beatsPerMeasure - usedBeats;
                    const subdivisionBeats = subdivisionDurations[currentSubdivision];
                    console.log(`📊 Used: ${usedBeats} beats, Remaining: ${remainingBeats} beats, Trying to add: ${subdivisionBeats} beats`);
                    
                    // If measure is complete (no remaining beats), clear it and start fresh
                    if (remainingBeats === 0 || usedBeats >= beatsPerMeasure) {
                        console.log('🔄 Measure is complete - clearing and starting fresh with new subdivision');
                        currentMeasure.chords = [];
                        usedBeats = 0;
                    }
                    
                    // Recalculate remaining after potential clear
                    const newRemainingBeats = beatsPerMeasure - usedBeats;
                    

                    // Helper to add a chord slot with roman numeral
                    function addChordSlotWithRoman(chordObj, duration) {
                        const romanNumeral = generateRomanNumeralForChord(chordObj, selectedKey, measureIndex);
                        currentMeasure.chords.push({
                            chord: chordObj,
                            duration: duration,
                            romanNumeral: romanNumeral
                        });
                    }

                    if (subdivisionBeats > newRemainingBeats) {
                        console.warn(`⚠️ Subdivision ${currentSubdivision} (${subdivisionBeats} beats) exceeds remaining space (${newRemainingBeats} beats)`);
                        // Auto-adjust to fit
                        const fitSubdivision = calculateRemainingDuration(measureIndex);
                        console.log(`🔧 Auto-adjusting to: ${fitSubdivision}`);
                        document.getElementById('measureSubdivision').value = fitSubdivision;
                        addChordSlotWithRoman(chordCopy, fitSubdivision);
                    } else {
                        // Add chord with current subdivision
                        console.log(`✅ Adding ${chordCopy.symbol} with ${currentSubdivision} (${subdivisionBeats} beats)`);
                        addChordSlotWithRoman(chordCopy, currentSubdivision);
                    }
                    
                    // Calculate new remaining duration and update dropdown
                    const newRemainingDuration = calculateRemainingDuration(measureIndex);
                    console.log(`🔄 Updating dropdown to next subdivision: ${newRemainingDuration}`);
                    document.getElementById('measureSubdivision').value = newRemainingDuration;
                    console.log(`✅ Added ${chordCopy.symbol} (${currentSubdivision}), next subdivision: ${newRemainingDuration}`);
                    
                    // Check if measure is complete
                    let totalBeats = 0;
                    currentMeasure.chords.forEach(slot => {
                        if (slot.chord) totalBeats += subdivisionDurations[slot.duration];
                    });
                    console.log(`📊 Total beats in measure: ${totalBeats}/${beatsPerMeasure}`);
                    
                    if (totalBeats >= beatsPerMeasure) {
                        console.log(`🎉 Measure ${measureIndex} complete! Auto-advancing...`);
                        // Measure complete - auto-advance to next measure
                        setTimeout(() => {
                            if (measureIndex + 1 < progressionMeasures.length) {
                                console.log(`➡️  Advancing to measure ${measureIndex + 1}`);
                                selectMeasure(measureIndex + 1);
                                // Reset subdivision to whole note for new measure
                                document.getElementById('measureSubdivision').value = 'whole';
                                console.log(`🔄 Reset subdivision to 'whole' for new measure`);
                            }
                        }, 100);
                    } else {
                        console.log(`⏳ Measure not complete yet (${totalBeats}/${beatsPerMeasure} beats)`);
                    }
                    
                    // Ensure selectedMeasureIndex is set for consistency
                    selectedMeasureIndex = measureIndex;
                    
                    updateProgressionChart();
                    
                    const checkChord0a = document.getElementById('chord-0');
                    console.log(`🟢 AFTER updateProgressionChart (CALL #3): chord-0=${checkChord0a ? 'EXISTS' : 'NULL'}`);
                    
                    // Show cadence options for the newly added chord (with error handling)
                    try {
                        showCadenceOptions(chordCopy.symbol, selectedKey);
                    } catch (error) {
                        console.warn('Error showing cadence options:', error);
                    }
                    
                    const checkChord0b = document.getElementById('chord-0');
                    console.log(`🟢 AFTER showCadenceOptions: chord-0=${checkChord0b ? 'EXISTS' : 'NULL'}`);
                    
                    // Note: Auto-advance is now handled by subdivision logic above
                    // Only advances when measure is complete (totalBeats >= beatsPerMeasure)
                    
                    updateActiveChordButton(chords[chordIndex]);
                    
                    const checkChord0c = document.getElementById('chord-0');
                    console.log(`🟢 AFTER updateActiveChordButton: chord-0=${checkChord0c ? 'EXISTS' : 'NULL'}`);
                    console.log(`🟢 END of selectChord - NOW waiting 100ms for setTimeout to fire...`);
                }
            }
        }
        
        function updateFretboard() {
            const instrument = instruments[selectedInstrument];
            
            // Get current scale data (either from musicalKeys or generated)
            const keyData = getCurrentKeyData();
            
            const container = document.getElementById('fretboard');
            
            if (!keyData) return;
            
            const maxFrets = instrument.frets;
            
            // Set CSS custom properties for grid layout
            document.documentElement.style.setProperty('--fret-count', maxFrets);
            document.documentElement.style.setProperty('--string-count', instrument.strings.length);
            
            let html = '<div class="fretboard-grid">';
            
            // String configuration
            const stringOrder = [...Object.values(currentTuning)];
            if (selectedInstrument === 'guitar' || selectedInstrument === 'bass' || selectedInstrument === 'ukulele' || selectedInstrument === 'violin') {
                stringOrder.reverse(); // High to low for visual display
            }
            
            // Create grid: each string gets its own row, each fret gets its own column
            stringOrder.forEach((openString, stringIndex) => {
                // String label (first column)
                html += `<div class="string-label" style="grid-row: ${stringIndex + 1}; grid-column: 1;">${openString}</div>`;
                
                // Fret cells for this string
                for (let fret = 0; fret <= maxFrets; fret++) {
                    const semitone = (noteToSemitone(openString) + fret) % 12;
                    let note = semitoneToNote(semitone, selectedKey || 'C'); // Default to C for note naming in chromatic mode
                    
                    let noteClass = '';
                    let showNote = false;
                    
                    // Check if this specific position is selected in custom chord mode (single-note lighting)
                    const isCustomPosition = customChordPositions.some(pos => 
                        pos.string === stringIndex && pos.fret === fret
                    );
                    
                    // Color priority hierarchy: Custom chord notes > Chord root > Chord tones > Key center > Scale notes
                    if (isCustomPosition) {
                        // Custom chord note highlighting at specific position (highest priority)
                        if (note === customChordRoot) {
                            noteClass = 'custom-root';
                        } else {
                            noteClass = 'custom-selected';
                        }
                        showNote = true;
                    } else if (selectedChord && isChordRoot(note, selectedChord)) {
                        // Chord root (orange) when a chord is selected - highlights all octaves
                        const correctChordNoteName = getCorrectChordNoteName(semitone, selectedChord);
                        if (correctChordNoteName) {
                            note = correctChordNoteName;
                        }
                        noteClass = 'chord-root';
                        showNote = true;
                    } else if (selectedChord && isChordTone(note, selectedChord)) {
                        // Chord tones (blue) when a chord is selected - highlights all octaves
                        const correctChordNoteName = getCorrectChordNoteName(semitone, selectedChord);
                        if (correctChordNoteName) {
                            note = correctChordNoteName;
                        }
                        noteClass = 'chord';
                        showNote = true;
                    } else if (!selectedChord && customChordNotes.length === 0 && selectedScale !== 'chromatic' && isRootNote(note, selectedKey)) {
                        // Key center (red-orange) - only show when no chord is selected, no custom chord notes, and not in chromatic mode
                        noteClass = 'root';
                        showNote = true;
                    } else if (isNoteInScale(note, keyData.scale)) {
                        // Scale notes (light blue) - always show
                        noteClass = 'scale';
                        showNote = true;
                    }
                    
                    const gridColumn = fret + 2; // +2 because column 1 is string label, fret 0 is column 2
                    
                    // Add nut-line class for fret 0 (nut)
                    let nutLineClass = '';
                    if (fret === 0) {
                        nutLineClass = 'nut-line';
                    }
                    
                    // Add subtle background shading for traditional fret positions
                    let fretPositionClass = '';
                    if (fret === 12) {
                        fretPositionClass = 'fret-12'; // Special darker shading for 12th fret
                    } else if ([3, 5, 7, 9, 15, 17, 19].includes(fret)) {
                        fretPositionClass = 'fret-position'; // Regular shading for other positions
                    }
                    
                    html += `<div class="fret-cell ${fretPositionClass} ${nutLineClass}" style="grid-row: ${stringIndex + 1}; grid-column: ${gridColumn};">`;
                    if (showNote) {
                        // Add custom chord creation classes and click handlers
                        let customClasses = '';
                        let clickHandler = '';
                        
                        if (showNote) {
                            // Make all visible notes clickable for chord building (scale, chord, root)
                            customClasses += ' clickable';
                            clickHandler = ` onclick="selectCustomChordNote('${note}', ${stringIndex}, ${fret}, event)"`;
                        }
                        
                        html += `<div class="note-dot ${noteClass}${customClasses}"${clickHandler}>${note}</div>`;
                    }
                    html += '</div>';
                }
            });
            
            html += '</div>'; // Close fretboard-grid
            
            // Add spacing element to replace removed fret markers
            html += '<div style="height: 35px;"></div>';
            
            container.innerHTML = html;
            
            // Apply position zoom if active - do this immediately without timeout
            if (isPositionZoomed && currentPosition) {
                const position = POSITIONS[currentPosition];
                applyPositionZoom(position.frets);
            }
            
            // Draw arpeggio lines after fretboard is updated (with small delay for DOM to settle)
            setTimeout(() => {
                drawArpeggioLines();
            }, 150);
        }

        // Position Functions
        function generatePositionButtons() {
            const container = document.getElementById('positionButtons');
            const instrument = instruments[selectedInstrument];
            
            container.innerHTML = '';
            
            // Show positions that make sense for the instrument
            // For guitars: show positions up to 17 if the instrument has enough frets
            // For other instruments: show fewer positions based on fret count
            let maxPosition;
            if (selectedInstrument === 'guitar' && instrument.frets >= 22) {
                maxPosition = 17; // Show all 17 positions for 22+ fret guitars
            } else if (selectedInstrument === 'guitar' && instrument.frets >= 20) {
                maxPosition = 15; // Show up to position XV for 20+ fret guitars
            } else {
                maxPosition = Math.floor(instrument.frets / 2); // Original logic for other instruments
            }
            
            Object.entries(POSITIONS).forEach(([key, position]) => {
                const positionNumber = Object.keys(POSITIONS).indexOf(key) + 1;
                
                if (positionNumber <= maxPosition) {
                    const button = document.createElement('button');
                    button.className = 'position-btn';
                    button.id = `position-${key}`;
                    button.textContent = position.label;
                    button.title = `Position ${position.label} (frets ${position.frets[0]}-${position.frets[position.frets.length-1]})`;
                    button.onclick = () => zoomToPosition(key);
                    
                    container.appendChild(button);
                }
            });
            
            // Show position controls
            document.getElementById('positionControls').style.display = 'flex';
        }

        function zoomToPosition(positionKey) {
            // Clean up any accidental green styling
            cleanupGreenStyling();
            
            const position = POSITIONS[positionKey];
            if (!position) return;
            
            currentPosition = positionKey;
            isPositionZoomed = true;
            
            // Update button states
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `position-${positionKey}`);
            });
            
            // Apply zoom to fretboard directly - don't call updateFretboard()
            applyPositionZoom(position.frets);
        }

        function applyPositionZoom(fretRange) {
            const fretboard = document.getElementById('fretboard');
            const zoomContainer = document.getElementById('fretboardZoomContainer');
            const fretboardGrid = fretboard.querySelector('.fretboard-grid');
            
            if (!fretboardGrid) return;
            
            // Add zoom classes
            zoomContainer.classList.add('zoomed');
            fretboardGrid.classList.add('zoomed');
            
            const minFret = Math.min(...fretRange);
            const maxFret = Math.max(...fretRange);
            const contextRange = 0; // Show only the position frets without context
            
            console.log(`Position zoom: showing frets ${minFret} to ${maxFret} (range: [${fretRange.join(', ')}])`);
            
            // Determine if open strings should be visible (only for lower positions)
            const showOpenStrings = minFret <= 3; // Only show open strings for positions that naturally include them
            
            // Calculate center position for scrolling
            const centerFret = Math.floor((minFret + maxFret) / 2);
            
            // Show all frets but with different opacity levels
            const allFretCells = fretboardGrid.querySelectorAll('.fret-cell');
            allFretCells.forEach(cell => {
                // Parse both grid-column and grid-area formats
                let fretNumber = null;
                const style = cell.getAttribute('style');
                
                // Try grid-area first (newer format)
                const gridAreaMatch = style.match(/grid-area:\s*(\d+)\s*\/\s*(\d+)/);
                if (gridAreaMatch) {
                    fretNumber = parseInt(gridAreaMatch[2]) - 2; // Column - 2 for string labels
                } else {
                    // Fallback to grid-column (older format)
                    const gridColumnMatch = style.match(/grid-column:\s*(\d+)/);
                    if (gridColumnMatch) {
                        fretNumber = parseInt(gridColumnMatch[1]) - 2;
                    }
                }
                
                if (fretNumber !== null) {
                    if (fretNumber === 0) {
                        // Open strings - only show if position naturally includes them
                        if (showOpenStrings) {
                            cell.style.opacity = '1';
                            cell.style.display = '';
                        } else {
                            cell.style.opacity = '0.1';
                            cell.style.display = '';
                        }
                        cell.classList.remove('position-target', 'context-fret');
                    } else if (fretNumber >= minFret && fretNumber <= maxFret) {
                        // Target position - full opacity with highlight
                        cell.style.opacity = '1';
                        cell.style.display = '';
                        cell.classList.add('position-target');
                        cell.classList.remove('context-fret');
                    } else if (fretNumber >= (minFret - contextRange) && fretNumber <= (maxFret + contextRange)) {
                        // Context frets - reduced opacity
                        cell.style.opacity = '0.3';
                        cell.style.display = '';
                        cell.classList.add('context-fret');
                        cell.classList.remove('position-target');
                    } else {
                        // Far frets - gradient opacity based on distance from position
                        const distanceFromPosition = Math.min(
                            Math.abs(fretNumber - minFret),
                            Math.abs(fretNumber - maxFret)
                        );
                        
                        // Gradient: closer frets more visible, fade to 0.1 by distance 3+
                        let opacity;
                        if (distanceFromPosition <= contextRange + 1) {
                            opacity = 0.25; // 1 fret beyond context
                        } else if (distanceFromPosition <= contextRange + 2) {
                            opacity = 0.18; // 2 frets beyond context
                        } else {
                            opacity = 0.1; // 3+ frets beyond context
                        }
                        
                        cell.style.opacity = opacity.toString();
                        cell.style.display = '';
                        cell.classList.remove('position-target', 'context-fret');
                    }
                } // Close the if (fretNumber !== null) block
            });
            
            // Scroll to center the position
            setTimeout(() => {
                const targetFret = Math.floor((minFret + maxFret) / 2);
                
                // Find a target element in the position range
                let targetElement = null;
                for (let fret = minFret; fret <= maxFret && !targetElement; fret++) {
                    targetElement = fretboardGrid.querySelector(`[style*="grid-column: ${fret + 2}"]`);
                }
                
                if (targetElement && zoomContainer.scrollTo) {
                    const containerWidth = zoomContainer.offsetWidth;
                    const elementWidth = targetElement.offsetWidth;
                    const targetLeft = targetElement.offsetLeft;
                    
                    // Calculate scroll position to center the position
                    const scrollPosition = Math.max(0, targetLeft - (containerWidth / 2) + (elementWidth / 2));
                    
                    zoomContainer.scrollTo({
                        left: scrollPosition,
                        behavior: 'smooth'
                    });
                } else if (zoomContainer.scrollLeft !== undefined) {
                    // Fallback: calculate approximate scroll position
                    const fretWidth = 50; // Approximate fret width
                    const scrollPosition = Math.max(0, (targetFret * fretWidth) - (zoomContainer.offsetWidth / 2));
                    zoomContainer.scrollLeft = scrollPosition;
                }
            }, 150); // Slightly longer delay to ensure DOM is updated
            
            // Redraw arpeggio lines for the new position
            setTimeout(() => {
                drawArpeggioLines();
            }, 200); // Draw arpeggio lines after scroll animation
        }

        // Arpeggio line functions
        function drawArpeggioLines() {
            // Only draw arpeggio lines in position mode and if enabled
            if (!isPositionZoomed || !arpeggioLinesEnabled) {
                return;
            }
            
            // Clear existing arpeggio lines
            clearArpeggioLines();
            
            // Get chord notes to connect
            let chordNotes = [];
            
            // Check if we have a selected preset chord
            if (selectedChord && selectedChord.notes) {
                chordNotes = selectedChord.notes;
            }
            // Check if we have custom chord notes
            else if (customChordNotes && customChordNotes.length > 0) {
                chordNotes = customChordNotes;
            }
            
            if (chordNotes.length < 2) {
                console.log('Not enough chord notes:', chordNotes.length);
                return; // Need at least 2 notes to draw lines
            }
            
            // Get all note positions on the fretboard that match chord notes
            const notePositions = getChordNotePositions(chordNotes);
            console.log('Found note positions:', notePositions.length);
            
            if (notePositions.length < 2) {
                console.log('Not enough visible note positions:', notePositions.length);
                return;
            }
            
            // Sort positions from low string to high string (6th to 1st)
            const sortedPositions = sortNotePositionsByString(notePositions);
            console.log('Sorted positions:', sortedPositions);
            
            // Create arpeggio lines connecting the positions
            createArpeggioSVG(sortedPositions);
        }
        
        function getChordNotePositions(chordNotes) {
            const positions = [];
            const fretboardGrid = document.querySelector('.fretboard-grid');
            if (!fretboardGrid) return positions;
            
            // Get current position range
            const currentPositionRange = currentPosition ? POSITIONS[currentPosition].frets : null;
            console.log('Current position range:', currentPositionRange);
            
            // If we have custom chord positions (single-note lighting), use only those specific positions
            if (customChordPositions && customChordPositions.length > 0) {
                console.log('Using custom chord positions for arpeggio lines:', customChordPositions);
                
                customChordPositions.forEach(pos => {
                    // Find the cell at this position
                    const cells = fretboardGrid.querySelectorAll('.fret-cell');
                    cells.forEach(cell => {
                        const style = cell.getAttribute('style');
                        const gridAreaMatch = style.match(/grid-area:\s*(\d+)\s*\/\s*(\d+)/);
                        
                        if (gridAreaMatch) {
                            const stringIndex = parseInt(gridAreaMatch[1]) - 1;
                            const fretNumber = parseInt(gridAreaMatch[2]) - 2;
                            
                            if (stringIndex === pos.string && fretNumber === pos.fret) {
                                const dot = cell.querySelector('.note-dot');
                                if (dot) {
                                    const pitch = calculateNotePitch(pos.note, stringIndex, fretNumber);
                                    positions.push({
                                        element: dot,
                                        cell: cell,
                                        stringIndex: stringIndex,
                                        fretNumber: fretNumber,
                                        noteName: pos.note,
                                        pitch: pitch,
                                        x: null,
                                        y: null
                                    });
                                }
                            }
                        }
                    });
                });
                
                console.log('Final positions from custom chord positions:', positions);
                return positions;
            }
            
            // Otherwise, use all note dots that match chord notes (octave highlighting)
            const noteDots = fretboardGrid.querySelectorAll('.note-dot');
            console.log('Total note dots found:', noteDots.length);
            
            noteDots.forEach((dot, index) => {
                const noteName = dot.textContent.trim();
                
                // Check if this note is in our chord
                if (chordNotes.includes(noteName)) {
                    const cell = dot.closest('.fret-cell');
                    if (!cell) return;
                    
                    // Extract position information from the cell
                    const style = cell.getAttribute('style');
                    const gridAreaMatch = style.match(/grid-area:\s*(\d+)\s*\/\s*(\d+)/);
                    
                    if (gridAreaMatch) {
                        const stringIndex = parseInt(gridAreaMatch[1]) - 1;
                        const fretNumber = parseInt(gridAreaMatch[2]) - 2; // Adjust for string labels
                        
                        // Only include notes that are in the current position range
                        if (currentPositionRange && !currentPositionRange.includes(fretNumber)) {
                            console.log(`Skipping ${noteName} at fret ${fretNumber} - not in position range`);
                            return;
                        }
                        
                        // Only include notes that are actually visible (not too faded)
                        const opacity = parseFloat(cell.style.opacity || '1');
                        if (opacity < 0.5) {
                            console.log(`Skipping ${noteName} at fret ${fretNumber} - too faded (opacity: ${opacity})`);
                            return;
                        }
                        
                        console.log(`Including ${noteName} at string=${stringIndex}, fret=${fretNumber}`);
                        
                        // Calculate pitch (for sorting)
                        const pitch = calculateNotePitch(noteName, stringIndex, fretNumber);
                        
                        positions.push({
                            element: dot,
                            cell: cell,
                            stringIndex: stringIndex,
                            fretNumber: fretNumber,
                            noteName: noteName,
                            pitch: pitch,
                            x: null, // Will be calculated later relative to fretboard
                            y: null  // Will be calculated later relative to fretboard
                        });
                    }
                }
            });
            
            console.log('Final positions array:', positions);
            return positions;
        }
        
        function calculateNotePitch(noteName, stringIndex, fretNumber) {
            // Get the instrument's tuning
            const instrument = instruments[selectedInstrument];
            const stringOrder = [...Object.values(currentTuning)];
            
            // Get the open string note for this string
            const openStringNote = stringOrder[stringIndex];
            if (!openStringNote) return 0;
            
            // Calculate the absolute semitone value from C0
            const openStringSemitone = noteToSemitone(openStringNote);
            
            // We need to add the appropriate octave offset based on standard guitar tuning
            // For guitar: String 0 (6th string) = lowest, String 5 (1st string) = highest
            let octaveOffset = 0;
            if (selectedInstrument === 'guitar') {
                // Standard guitar tuning octaves (string 0 = 6th string = lowest)
                const guitarOctaves = [2, 2, 3, 3, 3, 4]; // E2, A2, D3, G3, B3, E4
                octaveOffset = (guitarOctaves[stringIndex] || 3) * 12;
            } else if (selectedInstrument === 'bass') {
                // Standard bass tuning octaves  
                const bassOctaves = [1, 1, 2, 2]; // E1, A1, D2, G2
                octaveOffset = (bassOctaves[stringIndex] || 2) * 12;
            } else {
                // Default octaves for other instruments
                octaveOffset = (3 + stringIndex) * 12; // Progressive octaves
            }
            
            // Calculate final pitch: base semitone + octave + fret
            const finalPitch = (openStringSemitone % 12) + octaveOffset + fretNumber;
            
            console.log(`Pitch calc: ${noteName} on string ${stringIndex} (${openStringNote}) fret ${fretNumber} = semitone ${finalPitch}`);
            
            return finalPitch;
        }
        
        function sortNotePositionsByString(positions) {
            // Sort by string index in reverse order (highest index first = 6th string first)
            // Due to stringOrder.reverse(), stringIndex 5 = 6th string (bottom), stringIndex 0 = 1st string (top)
            // We want arpeggio to go from 6th string to 1st string (bottom to top visually)
            return positions.sort((a, b) => {
                // Primary sort: by string index in reverse order (higher index = lower string = earlier in arpeggio)
                if (a.stringIndex !== b.stringIndex) {
                    return b.stringIndex - a.stringIndex;
                }
                // Secondary sort: by fret position if on same string
                return a.fretNumber - b.fretNumber;
            });
        }
        
        function createArpeggioSVG(sortedPositions) {
            console.log('createArpeggioSVG called with positions:', sortedPositions);
            const fretboardGrid = document.querySelector('.fretboard-grid');
            if (!fretboardGrid) {
                console.log('No fretboard grid found');
                return;
            }
            
            // Remove any existing arpeggio container
            clearArpeggioLines();
            
            // Get fretboard bounds for relative positioning
            const fretboardRect = fretboardGrid.getBoundingClientRect();
            
            // Calculate positions relative to fretboard
            sortedPositions.forEach(position => {
                const cellRect = position.cell.getBoundingClientRect();
                position.x = cellRect.left - fretboardRect.left + cellRect.width / 2;
                position.y = cellRect.top - fretboardRect.top + cellRect.height / 2;
            });
            
            // Create SVG container
            const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgContainer.classList.add('arpeggio-container');
            svgContainer.setAttribute('viewBox', `0 0 ${fretboardRect.width} ${fretboardRect.height}`);
            svgContainer.style.width = '100%';
            svgContainer.style.height = '100%';
            console.log('Created SVG container with viewBox:', `0 0 ${fretboardRect.width} ${fretboardRect.height}`);
            
            // Create path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('arpeggio-line');
            
            // Build the path data with straight lines
            let pathData = '';
            
            sortedPositions.forEach((position, index) => {
                const x = position.x;
                const y = position.y;
                console.log(`Position ${index}: x=${x}, y=${y}`);
                
                if (index === 0) {
                    pathData += `M ${x} ${y}`;
                } else {
                    // Create straight lines to the next point
                    pathData += ` L ${x} ${y}`;
                }
            });
            
            console.log('Path data:', pathData);
            path.setAttribute('d', pathData);
            
            // Ensure the line is black
            path.style.stroke = '#000000';
            path.style.strokeWidth = '3';
            path.style.fill = 'none';
            
            svgContainer.appendChild(path);
            
            // Add the SVG to the fretboard
            fretboardGrid.appendChild(svgContainer);
            console.log('Added SVG to fretboard');
            
            // Add subtle animation
            const pathLength = path.getTotalLength();
            path.style.strokeDasharray = pathLength;
            path.style.strokeDashoffset = pathLength;
            path.style.animation = 'drawArpeggio 0.8s ease-in-out forwards';
            console.log('Applied animation, path length:', pathLength);
        }
        
        function clearArpeggioLines() {
            const fretboardGrid = document.querySelector('.fretboard-grid');
            if (!fretboardGrid) return;
            
            const existingArpeggios = fretboardGrid.querySelectorAll('.arpeggio-container');
            existingArpeggios.forEach(arpeggio => arpeggio.remove());
        }

        function toggleArpeggioLines() {
            arpeggioLinesEnabled = !arpeggioLinesEnabled;
            const toggleBtn = document.getElementById('arpeggioToggleBtn');
            
            if (arpeggioLinesEnabled) {
                toggleBtn.textContent = 'Hide Arpeggio';
                // Redraw arpeggio lines if in position mode
                if (isPositionZoomed) {
                    drawArpeggioLines();
                }
            } else {
                toggleBtn.textContent = 'Show Arpeggio';
                // Clear existing arpeggio lines
                clearArpeggioLines();
            }
            
            console.log('Arpeggio lines enabled:', arpeggioLinesEnabled);
        }

        // Function to actively clean up any accidental green styling
        function cleanupGreenStyling() {
            document.querySelectorAll('*').forEach(element => {
                if (element.style.background && 
                    (element.style.background.includes('90EE90') || 
                     element.style.background.includes('#90EE90') || 
                     element.style.background.includes('rgb(144, 238, 144)')) &&
                    !element.classList.contains('chord-button')) {
                    element.style.background = '';
                }
            });
        }

        function resetZoom() {
            currentPosition = null;
            isPositionZoomed = false;
            
            const zoomContainer = document.getElementById('fretboardZoomContainer');
            const fretboardGrid = document.querySelector('.fretboard-grid');
            
            // Clear arpeggio lines when exiting position mode
            clearArpeggioLines();
            
            // Remove zoom classes
            if (zoomContainer) zoomContainer.classList.remove('zoomed');
            if (fretboardGrid) fretboardGrid.classList.remove('zoomed');
            
            // Clear button states
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show all elements and remove position classes
            const allElements = document.querySelectorAll('.fret-cell, .fret-marker');
            allElements.forEach(element => {
                element.style.display = '';
                element.style.opacity = '';
                element.classList.remove('hidden-position', 'position-target');
            });
            
            // Scroll back to start
            if (zoomContainer && zoomContainer.scrollTo) {
                zoomContainer.scrollTo({ left: 0, behavior: 'smooth' });
            }
            
            updateFretboard();
        }

        // Helper function to sync compatibility layer
        function syncProgressionMeasures() {
            const currentSection = currentSong.sections[currentSong.currentSectionIndex];

            // Expand measures based on repeat count (deep copy to avoid reference issues)
            const repeatCount = currentSection.repeat || 1;
            progressionMeasures = [];

            for (let i = 0; i < repeatCount; i++) {
                // Deep copy each measure to preserve chord objects with notes array
                const measuresCopy = currentSection.measures.map(m => {
                    const measureCopy = {
                        chord: m.chord ? {
                            symbol: m.chord.symbol,
                            root: m.chord.root,
                            notes: m.chord.notes ? [...m.chord.notes] : [],
                            isCustom: m.chord.isCustom || false
                        } : null,
                        localKey: m.localKey,
                        timeSignature: m.timeSignature
                    };
                    // --- NEW: Copy chords array for new format ---
                    if (m.chords && Array.isArray(m.chords)) {
                        measureCopy.chords = m.chords.map(chordSlot => ({
                            chord: chordSlot.chord || null,
                            symbol: chordSlot.symbol || '',
                            duration: chordSlot.duration || 'whole',
                            romanNumeral: chordSlot.romanNumeral || ''
                        }));
                    }
                    return measureCopy;
                });
                progressionMeasures.push(...measuresCopy);
            }

            progressionKey = currentSection.key;
            console.log('📊 syncProgressionMeasures: Loaded', progressionMeasures.length, 'measures for section', currentSong.currentSectionIndex);
        }

        // Section Management Functions
        // Update song title display in staff header
        function updateSongTitleDisplay() {
            const titleElement = document.getElementById('currentSongTitle');
            if (titleElement && currentSong && currentSong.title) {
                const artist = currentSong.artist || 'Unknown Artist';
                titleElement.textContent = `${currentSong.title} - ${artist}`;
            } else if (titleElement) {
                titleElement.textContent = '';
            }
        }

        function renderSectionTabs() {
            const tabsContainer = document.getElementById('sectionTabsContainer');
            const tabsElement = document.getElementById('sectionTabs');
            
            if (!progressionActive) {
                tabsContainer.classList.remove('active');
                return;
            }
            
            tabsContainer.classList.add('active');
            tabsElement.innerHTML = '';
            
            // Render each section tab
            currentSong.sections.forEach((section, index) => {
                const tab = document.createElement('div');
                tab.className = 'section-tab' + (index === currentSong.currentSectionIndex ? ' active' : '');
                
                // Tab content
                const tabContent = document.createElement('span');
                tabContent.className = 'section-tab-content';
                
                // Section name (editable)
                const nameSpan = document.createElement('span');
                nameSpan.className = 'section-tab-name';
                nameSpan.textContent = section.name;
                nameSpan.onclick = (e) => {
                    e.stopPropagation();
                    startEditingSectionName(index, nameSpan);
                };
                
                // Section info
                const infoSpan = document.createElement('span');
                infoSpan.className = 'section-tab-info';
                infoSpan.textContent = `${section.bars} bars, ${section.key}`;
                
                tabContent.appendChild(nameSpan);
                tabContent.appendChild(infoSpan);
                
                tab.appendChild(tabContent);
                
                // Close button
                const closeBtn = document.createElement('span');
                closeBtn.className = 'section-tab-close';
                closeBtn.innerHTML = '×';
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteSection(index);
                };
                
                tab.appendChild(closeBtn);
                
                // Click to switch sections
                tab.onclick = () => switchToSection(index);
                
                // Right-click for context menu
                tab.oncontextmenu = (e) => {
                    e.preventDefault();
                    showSectionContextMenu(e, index);
                };
                
                tabsElement.appendChild(tab);
            });
            
            // Update dynamic sizing after rendering
            setTimeout(updateTabSizing, 0);
        }

        let contextMenuTarget = -1;

        function showSectionContextMenu(event, sectionIndex) {
            // Remove any existing context menu
            const existingMenu = document.querySelector('.section-tab-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            contextMenuTarget = sectionIndex;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.className = 'section-tab-menu';
            menu.innerHTML = `
                <div class="menu-item" onclick="editSection(${sectionIndex}); hideContextMenu();">Edit Section</div>
                <div class="menu-item" onclick="duplicateSection(${sectionIndex}); hideContextMenu();">Duplicate Section</div>
                <div class="menu-item menu-item-danger" onclick="deleteSection(${sectionIndex}); hideContextMenu();">Delete Section</div>
            `;
            
            // Position menu at click location
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            document.body.appendChild(menu);
            
            // Close menu on outside click
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu);
            }, 0);
        }

        function hideContextMenu() {
            const menu = document.querySelector('.section-tab-menu');
            if (menu) {
                menu.remove();
            }
            document.removeEventListener('click', hideContextMenu);
            contextMenuTarget = -1;
        }

        /**
         * Dynamic tab sizing system
         */
        function updateTabSizing() {
            const container = document.getElementById('sectionTabsContainer');
            if (!container || !container.classList.contains('active')) return;
            
            const tabs = container.querySelectorAll('.section-tab');
            const addBtn = container.querySelector('.add-section-btn');
            
            if (tabs.length === 0) return;
            
            const containerWidth = container.offsetWidth;
            const addBtnWidth = addBtn ? 50 : 0;
            const gap = 4;
            const totalGaps = tabs.length * gap;
            const padding = 20;
            
            // Calculate available space per tab
            const availableWidth = containerWidth - addBtnWidth - totalGaps - padding;
            const avgTabWidth = availableWidth / tabs.length;
            
            // Determine and apply display mode
            let mode = 'comfortable';
            if (avgTabWidth > 150) {
                mode = 'spacious';
            } else if (avgTabWidth > 90) {
                mode = 'comfortable';
            } else {
                mode = 'compact';
            }
            
            setTabDisplayMode(mode);
        }

        /**
         * Set display mode for all tabs
         */
        function setTabDisplayMode(mode) {
            const tabs = document.querySelectorAll('.section-tab');
            
            tabs.forEach((tab, index) => {
                // Remove all mode classes
                tab.classList.remove('mode-compact', 'mode-comfortable', 'mode-spacious');
                
                // Add appropriate mode class
                tab.classList.add(`mode-${mode}`);
                
                // Get section data
                const section = currentSong.sections[index];
                if (!section) return;
                
                const nameEl = tab.querySelector('.section-tab-name');
                if (!nameEl) return;
                
                // Abbreviate names if in compact mode
                if (mode === 'compact') {
                    nameEl.textContent = abbreviateSectionName(section.name, 8);
                } else {
                    nameEl.textContent = section.name;
                }
            });
        }

        /**
         * Abbreviate section names for compact display
         */
        function abbreviateSectionName(name, maxLength) {
            const abbreviations = {
                'Intro': 'Intro',
                'Introduction': 'Intro',
                'Verse': 'V',
                'Chorus': 'C',
                'Bridge': 'B',
                'Outro': 'Out',
                'Interlude': 'Int',
                'Solo': 'Solo',
                'Pre-Chorus': 'PreC',
                'Verse 2': 'V2',
                'Chorus 2': 'C2'
            };
            
            // Use abbreviation if available and needed
            if (name.length > maxLength && abbreviations[name]) {
                return abbreviations[name];
            }
            
            // Otherwise truncate with ellipsis
            if (name.length > maxLength) {
                return name.substring(0, maxLength - 1) + '…';
            }
            
            return name;
        }

        /**
         * Start inline editing of section name
         */
        function startEditingSectionName(sectionIndex, nameElement) {
            const section = currentSong.sections[sectionIndex];
            const originalName = section.name;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'section-tab-name-input';
            input.value = originalName;
            
            // Replace name span with input
            nameElement.style.display = 'none';
            nameElement.parentNode.insertBefore(input, nameElement);
            
            // Focus and select text
            input.focus();
            input.select();
            
            // Save on blur or Enter
            const saveEdit = () => {
                const newName = input.value.trim();
                
                if (newName && newName !== originalName) {
                    section.name = newName;
                    nameElement.textContent = newName;
                }
                
                // Restore name span
                input.remove();
                nameElement.style.display = '';
                
                // Update display with new mode if needed
                updateTabSizing();
            };
            
            // Save on Enter
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    // Cancel - restore original
                    input.value = originalName;
                    saveEdit();
                }
            });
            
            // Save on blur (click outside)
            input.addEventListener('blur', saveEdit);
            
            // Prevent tab switching when clicking input
            input.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }

        /**
         * Initialize dynamic tab sizing
         */
        function initializeDynamicTabs() {
            updateTabSizing();
            
            // Re-calculate on window resize with debouncing
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(updateTabSizing, 150);
            });
        }

        // Initialize on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDynamicTabs);
        } else {
            initializeDynamicTabs();
        }

        function switchToSection(sectionIndex) {
            if (sectionIndex < 0 || sectionIndex >= currentSong.sections.length) return;
            
            // DON'T save progressionMeasures back - it contains expanded repeats
            // The original section.measures should remain unchanged
            
            // Switch to new section
            currentSong.currentSectionIndex = sectionIndex;
            syncProgressionMeasures();
            
            // Update UI
            renderSectionTabs();
            regenerateStaffForCurrentSection();
            selectMeasure(0); // Select first measure of new section
        }

        function addNewSection() {
            const newSectionId = 'section-' + (currentSong.sections.length + 1);
            const currentSection = currentSong.sections[currentSong.currentSectionIndex];
            
            // Better default section names
            const sectionNameSuggestions = [
                'Intro',
                'Verse',
                'Chorus',
                'Bridge',
                'Verse 2',
                'Chorus 2',
                'Solo',
                'Pre-Chorus',
                'Outro',
                'Interlude'
            ];
            
            const sectionCount = currentSong.sections.length;
            const defaultName = sectionNameSuggestions[sectionCount] || `Section ${sectionCount + 1}`;
            
            const newSection = {
                id: newSectionId,
                name: defaultName,
                bars: currentSection.bars,
                key: currentSection.key, // Inherit key from current section
                timeSignature: currentSection.timeSignature,
                repeat: false,
                measures: new Array(currentSection.bars).fill(null).map(() => ({
                    chord: null,
                    localKey: currentSection.key,
                    timeSignature: currentSection.timeSignature
                }))
            };
            
            currentSong.sections.push(newSection);
            renderSectionTabs();
            // updateTabSizing is called by renderSectionTabs
        }

        function regenerateStaffForCurrentSection() {
            const currentSection = currentSong.sections[currentSong.currentSectionIndex];
            const repeatCount = currentSection.repeat || 1;
            const totalBars = currentSection.bars * repeatCount;
            generateStaffMeasures(totalBars, currentSection.timeSignature);
            updateProgressionChart();
        }

        let editingSectionIndex = -1;

        function editSection(sectionIndex) {
            editingSectionIndex = sectionIndex;
            const section = currentSong.sections[sectionIndex];
            
            // Populate modal with section data
            document.getElementById('sectionName').value = section.name;
            document.getElementById('sectionBars').value = section.bars;
            document.getElementById('sectionKey').value = section.key;
            document.getElementById('sectionTimeSignature').value = section.timeSignature;
            
            // Show modal
            document.getElementById('sectionEditModal').style.display = 'flex';
        }

        function closeSectionEditModal() {
            document.getElementById('sectionEditModal').style.display = 'none';
            editingSectionIndex = -1;
        }

        // Add ESC key support for modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('sectionEditModal');
                if (modal && modal.style.display === 'flex') {
                    closeSectionEditModal();
                }
                hideContextMenu();
            }
        });

        function saveSectionEdit() {
            if (editingSectionIndex < 0) return;
            
            const section = currentSong.sections[editingSectionIndex];
            const newName = document.getElementById('sectionName').value.trim();
            const newBars = parseInt(document.getElementById('sectionBars').value);
            const newKey = document.getElementById('sectionKey').value;
            const newTimeSignature = document.getElementById('sectionTimeSignature').value;
            
            // Validation
            if (!newName) {
                alert('Please enter a section name.');
                return;
            }
            if (newBars < 1 || newBars > 64) {
                alert('Number of bars must be between 1 and 64.');
                return;
            }
            
            // Update section properties
            section.name = newName;
            section.key = newKey;
            section.timeSignature = newTimeSignature;
            
            // Handle bar count change
            if (newBars !== section.bars) {
                const oldMeasures = section.measures;
                section.measures = new Array(newBars).fill(null).map((_, index) => {
                    // Keep existing measures if available
                    if (oldMeasures[index]) {
                        return {
                            chord: oldMeasures[index].chord,
                            localKey: newKey,
                            timeSignature: newTimeSignature
                        };
                    } else {
                        // Create new empty measure
                        return {
                            chord: null,
                            localKey: newKey,
                            timeSignature: newTimeSignature
                        };
                    }
                });
                section.bars = newBars;
                
                // If editing current section, regenerate staff
                if (editingSectionIndex === currentSong.currentSectionIndex) {
                    syncProgressionMeasures();
                    regenerateStaffForCurrentSection();
                }
            } else {
                // Just update key/time signature for all measures
                section.measures.forEach(measure => {
                    measure.localKey = newKey;
                    measure.timeSignature = newTimeSignature;
                });
                
                if (editingSectionIndex === currentSong.currentSectionIndex) {
                    syncProgressionMeasures();
                    updateProgressionChart();
                }
            }
            
            renderSectionTabs();
            closeSectionEditModal();
            // updateTabSizing is called by renderSectionTabs
        }

        function deleteSection(sectionIndex) {
            // Prevent deleting last section
            if (currentSong.sections.length <= 1) {
                alert('Cannot delete the last section.');
                return;
            }
            
            const section = currentSong.sections[sectionIndex];
            if (!confirm(`Delete section "${section.name}"? This cannot be undone.`)) {
                return;
            }
            
            // Remove section
            currentSong.sections.splice(sectionIndex, 1);
            
            // If we deleted the current section, switch to nearest section
            if (sectionIndex === currentSong.currentSectionIndex) {
                currentSong.currentSectionIndex = Math.max(0, sectionIndex - 1);
                syncProgressionMeasures();
                regenerateStaffForCurrentSection();
            } else if (sectionIndex < currentSong.currentSectionIndex) {
                // Adjust current index if we deleted a section before it
                currentSong.currentSectionIndex--;
            }
            
            renderSectionTabs();
            // updateTabSizing is called by renderSectionTabs
        }

        function duplicateSection(sectionIndex) {
            const sourceSection = currentSong.sections[sectionIndex];
            
            // Deep copy the section
            const newSection = {
                id: 'section-' + Date.now(),
                name: sourceSection.name + ' (copy)',
                bars: sourceSection.bars,
                key: sourceSection.key,
                timeSignature: sourceSection.timeSignature,
                repeat: sourceSection.repeat || false,
                measures: sourceSection.measures.map(measure => ({
                    chord: measure.chord ? { ...measure.chord } : null,
                    localKey: measure.localKey,
                    timeSignature: measure.timeSignature
                }))
            };
            
            // Insert after source section
            currentSong.sections.splice(sectionIndex + 1, 0, newSection);
            
            // Switch to new section
            currentSong.currentSectionIndex = sectionIndex + 1;
            syncProgressionMeasures();
            
            renderSectionTabs();
            regenerateStaffForCurrentSection();
        }

        // Chord Progression Functions
        function createProgression() {
            console.log('=== CREATE PROGRESSION CALLED ===');
            try {
                const keySelect = document.getElementById('progressionKey');
                const measureSelect = document.getElementById('measureCount');
                const timeSelect = document.getElementById('timeSignature');
                
                console.log('selectedKey at start:', selectedKey);
                console.log('progressionKey dropdown value:', document.getElementById('progressionKey').value);
                
                // If a key is selected on Circle of Fifths, use that; otherwise use dropdown value
                if (selectedKey) {
                    progressionKey = selectedKey;
                    keySelect.value = selectedKey; // Sync dropdown with Circle of Fifths
                    console.log(`Using Circle of Fifths key: ${selectedKey}, synced dropdown`);
                } else {
                    progressionKey = keySelect.value;
                    console.log(`No Circle key selected, using dropdown value: ${progressionKey}`);
                }
                
                const measureCount = parseInt(measureSelect.value);
                const timeSignature = timeSelect.value;
            
            // Initialize current section with empty measures
            const currentSection = currentSong.sections[currentSong.currentSectionIndex];
            const oldMeasures = currentSection.measures;
            
            currentSection.measures = new Array(measureCount).fill(null).map((_, index) => {
                // If this measure index existed before, keep its key
                if (oldMeasures[index]) {
                    return {
                        chord: null,
                        localKey: oldMeasures[index].localKey,
                        timeSignature: timeSignature
                    };
                }
                // For new measures, inherit key from previous measure
                const prevMeasure = oldMeasures[index - 1];
                const inheritedKey = prevMeasure ? prevMeasure.localKey : progressionKey;
                
                return {
                    chord: null,
                    localKey: inheritedKey,
                    timeSignature: timeSignature
                };
            });
            
            // Update section metadata
            currentSection.bars = measureCount;
            currentSection.key = progressionKey;
            currentSection.timeSignature = timeSignature;
            
            // Update compatibility layer
            progressionMeasures = currentSection.measures;
            
            // Set progressionActive to true FIRST
            progressionActive = true;
            
            // Auto-select measure 1 (index 0) so user can immediately start inputting chords
            selectedMeasureIndex = 0;
            
            // NOW set up event listeners for the dropdowns (only once per session)
            if (!keySelect.dataset.listenersAdded) {
                keySelect.dataset.listenersAdded = 'true';
                timeSelect.dataset.listenersAdded = 'true';
                
                keySelect.addEventListener('change', function(e) {
                    // Check progressionActive at time of change
                    if (progressionActive && selectedMeasureIndex !== null) {
                        const newKey = e.target.value;
                        progressionMeasures[selectedMeasureIndex].localKey = newKey;
                        console.log(`Changed measure ${selectedMeasureIndex} localKey to ${newKey}`);
                        
                        // Propagate key change to all subsequent measures that haven't been explicitly changed
                        for (let i = selectedMeasureIndex + 1; i < progressionMeasures.length; i++) {
                            if (progressionMeasures[i]) {
                                progressionMeasures[i].localKey = newKey;
                                console.log(`Propagated key ${newKey} to measure ${i}`);
                            }
                        }
                        
                        // Update the key display to show the new local key
                        selectedKey = newKey;
                        selectedScale = newKey.endsWith('m') ? 'minor' : 'major';
                        console.log('Updated selectedKey to:', selectedKey, 'selectedScale to:', selectedScale);
                        
                        // Mark that user has explicitly selected a key
                        window.userSelectedKey = true;
                        
                        // Update UI to reflect the new key
                        updateKeyInfo();
                        updateFretboard();
                        updateSelectedButtons();
                        updateProgressionChart();
                    }
                    // If progression not active, this just sets the initial key for next progression
                });
                
                timeSelect.addEventListener('change', function(e) {
                    // Check progressionActive at time of change
                    if (progressionActive && selectedMeasureIndex !== null) {
                        const newTime = e.target.value;
                        progressionMeasures[selectedMeasureIndex].timeSignature = newTime;
                        console.log(`Changed measure ${selectedMeasureIndex} timeSignature to ${newTime}`);
                        updateProgressionChart();
                    }
                    // If progression not active, this just sets the initial time for next progression
                });
            }
            
            // Update UI
            const staffContainer = document.getElementById('staffContainer');
            staffContainer.classList.add('active');
            document.querySelector('.play-progression-btn').disabled = true;
            
            // Show and render section tabs
            renderSectionTabs();
            
            // Generate staff measures
            generateStaffMeasures(measureCount, timeSignature);
            
            // Auto-select the first measure and update key display
            setTimeout(() => {
                window.userSelectedKey = false; // Reset flag for new progression
                selectMeasure(0); // This will update the key display to the measure's localKey
            }, 100); // Small delay to ensure DOM is ready
            
            console.log(`After progression creation: progressionKey=${progressionKey}, selectedKey=${selectedKey}`);
            console.log(`Dropdown value is now: ${document.getElementById('progressionKey').value}`);
            
            // Update chord buttons to show progression key's chords if needed
            // Only call selectKey if the global selectedKey is different from progressionKey
            if (progressionKey !== selectedKey) {
                console.log(`Syncing selectedKey from ${selectedKey} to progressionKey ${progressionKey}`);
                selectKey(progressionKey, true); // Force to avoid toggle behavior
                console.log(`After selectKey, dropdown value: ${document.getElementById('progressionKey').value}`);
            }
            
            // IMPORTANT: Ensure dropdown stays at progressionKey after all operations
            setTimeout(() => {
                const keySelect = document.getElementById('progressionKey');
                keySelect.value = progressionKey;
                console.log(`Final dropdown sync to progressionKey: ${progressionKey}`);
            }, 150); // Run after other UI updates
            
            } catch (error) {
                console.error('Error in createProgression:', error);
                alert('Error creating progression: ' + error.message);
            }
        }

        function generateStaffMeasures(measureCount, timeSignature) {
            console.log('🔥🔥🔥 generateStaffMeasures CALLED - This DESTROYS all elements!');
            console.trace('Call stack:');
            const staffWrapper = document.getElementById('staffWrapper');
            if (!staffWrapper) {
                console.error('❌ staffWrapper element not found!');
                return;
            }
            staffWrapper.innerHTML = '';
            
            const measuresPerRow = 4;
            const systemCount = Math.ceil(measureCount / measuresPerRow);
            
            const [numerator, denominator] = timeSignature.split('/');
            
            for (let systemIndex = 0; systemIndex < systemCount; systemIndex++) {
                
                const system = document.createElement('div');
                system.className = 'staff-system';
                system.id = `system-${systemIndex}`;
                
                // Add time sig only to first system (no key signature)
                if (systemIndex === 0) {
                    system.innerHTML = `
                        <div class="staff-header">
                            <div class="time-signature" id="timeSignatureDisplay">
                                <div>${numerator}</div>
                                <div>${denominator}</div>
                            </div>
                        </div>
                        <div class="measures-row" id="measures-row-${systemIndex}"></div>
                    `;
                } else {
                    system.innerHTML = `
                        <div class="measures-row" id="measures-row-${systemIndex}"></div>
                    `;
                }
                
                staffWrapper.appendChild(system);
                
                // Generate measures for this system
                const measuresRow = document.getElementById(`measures-row-${systemIndex}`);
                const startMeasure = systemIndex * measuresPerRow;
                const endMeasure = Math.min(startMeasure + measuresPerRow, measureCount);
                const measuresInThisRow = endMeasure - startMeasure;
                
                // Generate measure overlays for this system
                for (let i = 0; i < measuresInThisRow; i++) {
                    const measureIndex = startMeasure + i;
                    const measure = document.createElement('div');
                    measure.className = 'measure-staff';
                    measure.id = `staff-measure-${measureIndex}`;
                    
                    // Don't create chord/roman elements here - let updateProgressionChart create them dynamically
                    // This prevents the placeholder "—" from appearing and allows dynamic styling
                    
                    measure.onclick = () => selectMeasure(measureIndex);
                    measuresRow.appendChild(measure);
                    console.log(`✅ Created measure ${measureIndex} (chord/roman elements will be created dynamically)`);
                }
            }
            console.log('✅ generateStaffMeasures complete - created', measureCount, 'measures');
        }
        
        function displayKeySignature(key) {
            const keySignature = KEY_SIGNATURES[key] || KEY_SIGNATURES['C'];
            const keySignatureEl = document.getElementById('keySignatureDisplay');
            if (keySignatureEl) {
                keySignatureEl.textContent = keySignature.display;
            }
        }

        /**
         * Add pivot chord notation to a specific measure
         */
        function addPivotChordNotation(measureIndex, oldKey, newKey, oldAnalysis, newAnalysis) {
            const measureEl = document.getElementById(`staff-measure-${measureIndex}`);
            if (!measureEl) return;
            
            // Add class to give extra space
            measureEl.classList.add('has-pivot');
            
            // Create connector line from Roman numeral to box
            const connector = document.createElement('div');
            connector.className = 'pivot-connector';
            measureEl.appendChild(connector);
            
            // Create the pivot box
            const pivotBox = document.createElement('div');
            pivotBox.className = 'pivot-chord-box';
            
            // Build the content with dual analysis
            pivotBox.innerHTML = `
                <div class="pivot-analyses">
                    <div class="pivot-key-label">(${oldKey}:)</div>
                    <div class="pivot-original">${oldAnalysis}</div>
                    <div class="pivot-separator"></div>
                    <div class="pivot-key-label">(${newKey}:)</div>
                    <div class="pivot-new">${newAnalysis}</div>
                </div>
            `;
            
            measureEl.appendChild(pivotBox);
        }

        /**
         * Remove pivot chord notation from a measure
         */
        function removePivotNotation(measureIndex) {
            const measureEl = document.getElementById(`staff-measure-${measureIndex}`);
            if (!measureEl) return;
            
            measureEl.classList.remove('has-pivot');
            measureEl.querySelectorAll('.pivot-chord-box, .pivot-connector').forEach(el => el.remove());
            
            if (progressionMeasures[measureIndex]) {
                progressionMeasures[measureIndex].isPivot = false;
                delete progressionMeasures[measureIndex].pivotData;
            }
        }

        /**
         * Detect and mark pivot chords automatically when keys change
         */
        function detectAndMarkPivotChords() {
            progressionMeasures.forEach((measure, index) => {
                const prevMeasure = progressionMeasures[index - 1];
                
                // Check if key changed
                if (prevMeasure && measure && measure.localKey && measure.localKey !== prevMeasure.localKey) {
                    const chord = measure.chord;
                    if (!chord) return;
                    
                    // Analyze chord in BOTH keys
                    const oldKey = prevMeasure.localKey || progressionKey;
                    const newKey = measure.localKey;
                    
                    const oldAnalysis = generateRomanNumeralForChord(chord, oldKey, index);
                    const newAnalysis = generateRomanNumeralForChord(chord, newKey, index);
                    
                    // If chord functions in both keys, it's a pivot
                    if (oldAnalysis && newAnalysis) {
                        // Mark as pivot
                        measure.isPivot = true;
                        measure.pivotData = {
                            oldKey: oldKey,
                            newKey: newKey,
                            oldAnalysis: oldAnalysis,
                            newAnalysis: newAnalysis
                        };
                    }
                }
            });
        }

        /**
         * Get rhythm notation symbol for subdivision
         */
        function getRhythmNotation(subdivision) {
            const rhythmSymbols = {
                'whole': '𝅝',           // Whole note (U+1D15D)
                'half': '𝅗𝅥',           // Half note (U+1D15E) 
                'dotted-half': '𝅗𝅥.',   // Dotted half note
                'quarter': '𝅘𝅥',        // Quarter note (U+1D15F)
                'dotted-quarter': '𝅘𝅥.', // Dotted quarter note
                'eighth': '♪',           // Eighth note (U+266A)
                'dotted-eighth': '♪.'    // Dotted eighth note
            };
            return rhythmSymbols[subdivision] || '𝅝';
        }
        
        function updateProgressionChart() {
            console.log('========================================');
            console.log('📊 [updateProgressionChart] FULL DIAGNOSTIC');
            console.log('========================================');
            console.log('📊 progressionMeasures:', progressionMeasures);
            console.log('📊 progressionMeasures.length:', progressionMeasures.length);
            
            // Detailed measure inspection
            if (progressionMeasures.length > 0) {
                console.log('📊 Inspecting first 3 measures in detail:');
                for (let i = 0; i < Math.min(3, progressionMeasures.length); i++) {
                    const m = progressionMeasures[i];
                    console.log(`📊 Measure ${i}:`, {
                        hasChord: !!m.chord,
                        hasChords: !!m.chords,
                        chordsLength: m.chords?.length,
                        chordSymbol: m.chord?.symbol,
                        firstChordSlot: m.chords?.[0],
                        fullMeasure: JSON.stringify(m, null, 2)
                    });
                }
            }
            
            const playBtn = document.querySelector('.play-progression-btn');
            if (!progressionMeasures || !progressionMeasures.length) {
                if (playBtn) {
                    playBtn.disabled = true;
                    playBtn.textContent = 'Play';
                }
                console.error('❌ No progression data');
                return;
            }
            
            // Enable play button if all measures are valid (no nulls)
            if (playBtn) {
                const allValid = progressionMeasures.every(m => m && (m.chord || (m.chords && m.chords.length > 0)));
                playBtn.disabled = !allValid;
                playBtn.textContent = 'Play';
            }
            
            const totalMeasures = progressionMeasures.length;
            console.log(`📊 Updating ${totalMeasures} measures`);
            
            progressionMeasures.forEach((measure, index) => {
                console.log(`📊 Processing measure ${index}:`, measure);
                
                const measureEl = document.getElementById(`staff-measure-${index}`);
                if (!measureEl) {
                    console.error(`❌ Measure element not found for index ${index}`);
                    return;
                }
                
                console.log(`✅ Found measure element for index ${index}`);

                // --- Chord Element ---
                let chordEl = document.getElementById(`chord-${index}`);
                if (!chordEl) {
                    console.log(`Creating chord element for measure ${index}`);
                    chordEl = document.createElement('div');
                    chordEl.id = `chord-${index}`;
                    chordEl.className = 'chord-symbol';
                    measureEl.appendChild(chordEl);
                } else {
                    console.log(`Chord element already exists for measure ${index}`);
                }
                
                // --- Roman Element ---
                let romanEl = document.getElementById(`roman-${index}`);
                if (!romanEl) {
                    console.log(`Creating roman element for measure ${index}`);
                    romanEl = document.createElement('div');
                    romanEl.id = `roman-${index}`;
                    romanEl.className = 'roman-numeral';
                    measureEl.appendChild(romanEl);
                } else {
                    console.log(`Roman element already exists for measure ${index}`);
                }
                
                // --- Rhythm Element ---
                let rhythmEl = document.getElementById(`rhythm-${index}`);
                if (!rhythmEl) {
                    console.log(`Creating rhythm element for measure ${index}`);
                    rhythmEl = document.createElement('div');
                    rhythmEl.id = `rhythm-${index}`;
                    rhythmEl.className = 'rhythm-symbols';
                    measureEl.appendChild(rhythmEl);
                } else {
                    console.log(`Rhythm element already exists for measure ${index}`);
                }

                // Get measure key for roman numeral calculation
                const measureKey = measure.localKey || selectedKey || 'C';
                console.log(`📊 Measure ${index} key: ${measureKey}`);

                // Check what kind of data we have
                console.log(`📊 Measure ${index} has chord:`, !!measure.chord);
                console.log(`📊 Measure ${index} has chords array:`, !!measure.chords);
                
                // Subdivision mode
                if (measure.chords && Array.isArray(measure.chords) && measure.chords.length > 0) {
                    console.log(`📊 Measure ${index} using subdivision mode with ${measure.chords.length} chord slots`);
                    let rhythmDisplay = '';
                    let chordDisplay = '';
                    let romanDisplay = '';
                    
                    measure.chords.forEach((slot, slotIndex) => {
                        console.log(`  📊 Slot ${slotIndex}:`, slot);
                        // Rhythm symbol
                        rhythmDisplay += `<span style="margin-right:8px">${getRhythmNotation(slot.duration)}</span>`;
                        // Chord name: use slot.symbol if slot.chord is missing
                        const chordSymbol = slot.chord ? slot.chord.symbol : slot.symbol || '—';
                        console.log(`  📊 Chord symbol: ${chordSymbol}`);
                        chordDisplay += `<span style="margin-right:8px">${chordSymbol}</span>`;
                        // Roman numeral - calculate if missing
                        let romanNum = slot.romanNumeral;
                        if (!romanNum && slot.chord) {
                            romanNum = generateRomanNumeralForChord(slot.chord, measureKey, index);
                            slot.romanNumeral = romanNum; // Cache it
                        }
                        console.log(`  📊 Roman numeral: ${romanNum}`);
                        romanDisplay += `<span style="margin-right:8px">${romanNum || ''}</span>`;
                    });
                    
                    console.log(`📊 Setting rhythmEl.innerHTML:`, rhythmDisplay);
                    console.log(`📊 Setting chordEl.innerHTML:`, chordDisplay);
                    console.log(`📊 Setting romanEl.innerHTML:`, romanDisplay);
                    
                    rhythmEl.innerHTML = rhythmDisplay;
                    chordEl.innerHTML = chordDisplay;
                    romanEl.innerHTML = romanDisplay;
                } else if (measure.chord && measure.chord.symbol) {
                    // Traditional mode
                    console.log(`📊 Measure ${index} using traditional mode with chord: ${measure.chord.symbol}`);
                    chordEl.innerHTML = `<span class="chord-name">${measure.chord.symbol}</span>`;
                    // Calculate roman numeral if missing
                    if (!measure.romanNumeral) {
                        measure.romanNumeral = generateRomanNumeralForChord(measure.chord, measureKey, index);
                    }
                    console.log(`📊 Roman numeral: ${measure.romanNumeral}`);
                    romanEl.textContent = measure.romanNumeral || '';
                    rhythmEl.innerHTML = '';
                } else {
                    console.log(`📊 Measure ${index} has no chord data, displaying placeholder`);
                    chordEl.innerHTML = '—';
                    romanEl.textContent = '';
                    rhythmEl.innerHTML = '';
                }
                
                console.log(`✅ Finished processing measure ${index}`);
            });
            
            console.log('✅ [updateProgressionChart] Complete\n');
        }
        
        /**
         * Get display name for key (strip trailing 'm' and format nicely)
         */
        function getKeyDisplayName(key) {
            if (!key) return '';
            // Return key as-is but make it cleaner
            return key.replace(/m$/, ' minor').replace(/([A-G][#♯b♭]?)$/, '$1 major');
        }

        /**
         * Calculate what a tonicized key is as a roman numeral relative to the main key
         * E.g., D major in the key of C major = II
         * E.g., Eb major in the key of C major = ♭III
         */
        function getKeyAsRomanNumeral(tonicizedKey, mainKey) {
            // Remove 'm' from keys to get root notes
            const tonicRoot = tonicizedKey.replace(/m$/, '');
            const mainRoot = mainKey.replace(/m$/, '');
            const isTonicMinor = tonicizedKey.endsWith('m');
            
            // Define chromatic scale for interval calculation
            const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const enharmonics = {
                'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
                'C♯': 'C#', 'D♯': 'D#', 'F♯': 'F#', 'G♯': 'G#', 'A♯': 'A#',
                'D♭': 'C#', 'E♭': 'D#', 'G♭': 'F#', 'A♭': 'G#', 'B♭': 'A#'
            };
            
            // Normalize keys
            const normalizedTonic = enharmonics[tonicRoot] || tonicRoot;
            const normalizedMain = enharmonics[mainRoot] || mainRoot;
            
            // Find semitone distance
            const tonicIndex = chromaticScale.indexOf(normalizedTonic);
            const mainIndex = chromaticScale.indexOf(normalizedMain);
            const semitones = (tonicIndex - mainIndex + 12) % 12;
            
            // Map semitones to scale degrees and accidentals
            const degreeMap = {
                0: { degree: 'I', isFlat: false, isSharp: false },
                1: { degree: 'II', isFlat: true, isSharp: false },  // ♭II
                2: { degree: 'II', isFlat: false, isSharp: false },
                3: { degree: 'III', isFlat: true, isSharp: false }, // ♭III
                4: { degree: 'III', isFlat: false, isSharp: false },
                5: { degree: 'IV', isFlat: false, isSharp: false },
                6: { degree: 'V', isFlat: true, isSharp: false },   // ♭V or #IV
                7: { degree: 'V', isFlat: false, isSharp: false },
                8: { degree: 'VI', isFlat: true, isSharp: false },  // ♭VI
                9: { degree: 'VI', isFlat: false, isSharp: false },
                10: { degree: 'VII', isFlat: true, isSharp: false }, // ♭VII
                11: { degree: 'VII', isFlat: false, isSharp: false }
            };
            
            const info = degreeMap[semitones];
            let roman = info.degree;
            
            // Use lowercase for minor keys
            if (isTonicMinor) {
                roman = roman.toLowerCase();
            }
            
            // Add flat/sharp accidentals
            if (info.isFlat) {
                roman = '♭' + roman;
            } else if (info.isSharp) {
                roman = '♯' + roman;
            }
            
            return roman;
        }

        function generateRomanNumeralForChord(chord, key, index) {
            console.log('🎵 generateRomanNumeralForChord START - chord:', chord?.symbol, 'key:', key, 'index:', index);
            
            // If chord has preserved mode information, use it
            if (chord.sourceMode && chord.sourceIndex !== undefined) {
                const baseNumeral = generateRomanNumeral(chord.sourceIndex, chord.sourceMode, key);
                const figuredBass = detectFiguredBass(chord);
                return baseNumeral + figuredBass;
            }
            
            // Get the current key's chord data 
            const keyData = getCurrentKeyData();
            if (!keyData) return 'I';
            
            const isMinor = key.includes('m');
            console.log('🎶 generateRomanNumeralForChord - chord:', chord.symbol, 'key:', key, 'index:', index);
            
            // Get the appropriate chord array based on current mode
            let chords = [];
            switch(chordMode) {
                case 'triads':
                    chords = keyData.triads || [];
                    break;
                case 'sevenths':
                    chords = keyData.sevenths || [];
                    break;
                case 'secondary':
                    chords = generateSecondaryDominants(key);
                    break;
                case 'diminished':
                    chords = generateDiminishedPassing(key);
                    break;
            }
            
            // Find the position of this chord in the diatonic progression
            const chordPosition = chords.findIndex(c => c && c.symbol === chord.symbol);
            
            if (chordPosition === -1) {
                // Fallback: try to calculate based on chord root vs key
                console.log('⚠️ generateRomanNumeralForChord - Chord not in diatonic progression, falling back');
                console.log('⚠️ Chord:', chord.symbol, 'Key:', key, 'Available chords:', chords.map(c => c?.symbol));
                const baseNumeral = calculateRomanNumeralFromRoot(chord, key);
                const figuredBass = detectFiguredBass(chord);
                return baseNumeral + figuredBass;
            }
            
            // Detect figured bass for inversions
            const figuredBass = detectFiguredBass(chord);
            
            // Use diatonic position for roman numerals
            if (chordMode === 'secondary') {
                // For secondary dominants, always use V7/target format with proper HTML superscripts
                if (chord.target) {
                    return `V<sup>7</sup>/${chord.target}` + figuredBass;
                }
                // Fallback - shouldn't normally reach here
                return 'V<sup>7</sup>' + figuredBass;
            } else if (chordMode === 'diminished') {
                // For diminished passing chords, use the stored roman numeral
                if (chord.roman) {
                    return chord.roman + figuredBass;
                }
                return '°<sup>7</sup>' + figuredBass;
            } else {
                // Standard diatonic roman numerals with proper superscripts
                if (isMinor) {
                    const minorRomanNumerals = ['i', 'ii°', 'III', 'iv', 'v', 'VI', 'VII'];
                    const numeral = minorRomanNumerals[chordPosition] || 'i';
                    if (chordMode === 'sevenths') {
                        // Use triangle for maj7, compact
                        const isMajor7 = chord.symbol && (chord.symbol.includes('maj7') || chord.symbol.includes('M7'));
                        const seventh = isMajor7 ? '<sup>△</sup>' : '<sup>7</sup>';
                        return numeral + seventh + figuredBass;
                    }
                    return numeral + figuredBass;
                } else {
                    const majorRomanNumerals = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'];
                    const numeral = majorRomanNumerals[chordPosition] || 'I';
                    if (chordMode === 'sevenths') {
                        // Check if this is a major seventh chord (maj7 in symbol)
                        const isMajor7 = chord.symbol && chord.symbol.includes('maj7');
                        const seventh = isMajor7 ? '<sup>△7</sup>' : '<sup>7</sup>';
                        return numeral + seventh + figuredBass;
                    }
                    return numeral + figuredBass;
                }
            }
        }
        
        /**
         * Detect figured bass notation based on chord inversion
         * Returns HTML with proper superscript/subscript symbols for academic notation
         */
        function detectFiguredBass(chord) {
            if (!chord || !chord.symbol || !chord.notes || chord.notes.length === 0) {
                return '';
            }
            
            // Get the root note from the chord symbol
            const rootMatch = chord.symbol.match(/^([A-G][#♯b♭]?)/);
            if (!rootMatch) return '';
            
            const root = rootMatch[1];
            
            // Find the root in the notes array (ignore octave numbers)
            const bassNote = chord.notes[0].replace(/\d+/g, ''); // First note is bass
            const rootNote = root;
            
            // Check if chord is inverted (bass note != root)
            const isBassRoot = noteToSemitone(bassNote) % 12 === noteToSemitone(rootNote) % 12;
            
            if (isBassRoot) {
                // Root position - no figured bass needed
                return '';
            }
            
            // Determine chord type
            const isSeventh = chord.symbol.includes('7') || chord.symbol.includes('maj7') || 
                             chord.symbol.includes('M7') || chord.symbol.includes('Δ');
            const isNinth = chord.symbol.includes('9');
            
            // For inversions, find which chord tone is in bass
            const chordTones = chord.notes.map(n => noteToSemitone(n.replace(/\d+/g, '')) % 12);
            const rootSemitone = noteToSemitone(rootNote) % 12;
            const bassSemitone = noteToSemitone(bassNote) % 12;
            
            // Calculate interval from root to bass
            let interval = (bassSemitone - rootSemitone + 12) % 12;
            
            // Seventh chords - use proper HTML superscripts/subscripts
            if (isSeventh) {
                if (interval === 4 || interval === 3) {
                    // Third in bass = first inversion
                    return '<sup>6</sup><sub>5</sub>';
                } else if (interval === 7 || interval === 8) {
                    // Fifth in bass = second inversion
                    return '<sup>4</sup><sub>3</sub>';
                } else if (interval === 10 || interval === 11) {
                    // Seventh in bass = third inversion
                    return '<sup>4</sup><sub>2</sub>';
                }
            }
            
            // Triads (or other chords)
            if (interval === 4 || interval === 3) {
                // Third in bass = first inversion
                return '<sup>6</sup>';
            } else if (interval === 7 || interval === 8) {
                // Fifth in bass = second inversion
                return '<sup>6</sup><sub>4</sub>';
            }
            
            return '';
        }
        
        function calculateRomanNumeralFromRoot(chord, key) {
            console.log('🎼 calculateRomanNumeralFromRoot - chord:', chord?.symbol, 'key:', key);
            
            // Fallback method for calculating roman numerals
            // Safety check: ensure chord has a symbol
            if (!chord || !chord.symbol) {
                console.warn('⚠️ calculateRomanNumeralFromRoot called with invalid chord:', chord);
                return 'I';
            }
            
            const isKeyMinor = key.includes('m');
            const keyRoot = key.replace('m', '').split('/')[0];
            // Extract root note including sharps (#) and flats (♭, b)
            let chordRoot = chord.symbol.match(/^[A-G][#♯b♭]?/)?.[0] || chord.symbol.charAt(0);
            
            console.log('🎼 Chord root:', chordRoot, 'Key root:', keyRoot, 'Is minor key:', isKeyMinor);
            
            // Detect chord quality
            const isDominantSeventh = /^[A-G][#♯b♭]?7$/.test(chord.symbol); // X7 pattern
            const isMajorSeventh = chord.symbol.includes('maj7') || chord.symbol.includes('M7') || chord.symbol.includes('Δ7');
            const isMinorChord = chord.symbol.includes('m') && !chord.symbol.includes('maj');
            const isDiminished = chord.symbol.includes('°') || chord.symbol.includes('dim');
            const isAugmented = chord.symbol.includes('+') || chord.symbol.includes('aug');
            
            // Scale degrees mapping
            console.log('🎼 Getting key data for key:', key);
            const keyData = getCurrentKeyData();
            console.log('🎼 Key data result:', keyData ? 'found' : 'NOT FOUND');
            
            if (!keyData || !keyData.scale) {
                console.error('❌ No key data or scale found for key:', key);
                return 'I';
            }
            
            console.log('🎼 Scale:', keyData.scale);
            
            const scalePosition = keyData.scale.findIndex(note => {
                return noteToSemitone(note) === noteToSemitone(chordRoot);
            });
            
            // If chord root is not in the scale, calculate chromatic roman numeral
            if (scalePosition === -1) {
                console.log('🎼 Chord root not in scale - calculating chromatic numeral');
                const chordSemitone = noteToSemitone(chordRoot);
                const keySemitone = noteToSemitone(keyRoot);
                let interval = (chordSemitone - keySemitone + 12) % 12;
                
                console.log('🎼 Chord semitone:', chordSemitone, 'Key semitone:', keySemitone, 'Interval:', interval);
                
                // Map semitone intervals to roman numerals with accidentals
                const chromaticNumerals = {
                    0: 'I',     // Root
                    1: 'bII',   // Flat 2 (Neapolitan)
                    2: 'II',    // Major 2
                    3: 'bIII',  // Flat 3 (minor third)
                    4: 'III',   // Major 3
                    5: 'IV',    // Perfect 4
                    6: isKeyMinor ? 'V' : 'bV',  // Tritone (b5 in major, natural 5 in minor)
                    7: 'V',     // Perfect 5
                    8: 'bVI',   // Flat 6
                    9: 'VI',    // Major 6
                    10: 'bVII', // Flat 7
                    11: 'VII'   // Major 7
                };
                
                let baseNumeral = chromaticNumerals[interval] || 'I';
                
                // Adjust case based on chord quality
                if (isMinorChord && !baseNumeral.includes('b')) {
                    baseNumeral = baseNumeral.toLowerCase();
                } else if (isDiminished) {
                    baseNumeral = baseNumeral.toLowerCase() + '°';
                }
                
                console.log('🎼 Chromatic numeral:', baseNumeral);
                return baseNumeral;
            }
            
            if (isKeyMinor) {
                const minorRomanNumerals = ['i', 'ii°', 'III', 'iv', 'v', 'VI', 'VII'];
                let baseNumeral = minorRomanNumerals[scalePosition] || 'i';
                
                // Override based on chord quality
                if (isDominantSeventh || isMajorSeventh || isAugmented) {
                    baseNumeral = baseNumeral.toUpperCase().replace('°', '');
                } else if (isMinorChord) {
                    baseNumeral = baseNumeral.toLowerCase().replace('°', '');
                } else if (isDiminished) {
                    baseNumeral = baseNumeral.toLowerCase();
                    if (!baseNumeral.includes('°')) baseNumeral += '°';
                }
                
                return baseNumeral;
            } else {
                // For major keys
                const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
                let numeral = romanNumerals[scalePosition];
                
                // Safety check: if numeral is undefined (scale position out of bounds), return chord root
                if (!numeral) return chordRoot;
                
                // Adjust case and symbols based on chord quality
                if (isDominantSeventh || isMajorSeventh || isAugmented) {
                    numeral = numeral.toUpperCase(); // Major quality
                } else if (isMinorChord) {
                    numeral = numeral.toLowerCase(); // Minor quality
                } else if (isDiminished) {
                    numeral = numeral.toLowerCase() + '°'; // Diminished
                } else {
                    // Diatonic defaults for major key
                    const majorDefaults = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'];
                    numeral = majorDefaults[scalePosition] || 'I';
                }
                
                return numeral;
            }
        }

        function selectMeasure(measureIndex) {
            selectedMeasureIndex = measureIndex; // Track selected measure for custom chord building
            
            console.log('🔵 selectMeasure START - chord-0:', document.getElementById('chord-0') ? 'EXISTS' : 'NULL');
            
            const measure = progressionMeasures[measureIndex];
            
            // Always update the key display to match the selected measure's local key
            if (measure && measure.localKey) {
                console.log('=== SELECT MEASURE: Syncing to measure localKey:', measure.localKey);
                
                console.log('🔵 After getting measure - chord-0:', document.getElementById('chord-0') ? 'EXISTS' : 'NULL');
                
                // Update the selectedKey to the measure's localKey
                // This will update Circle of Fifths, key info, Roman numerals, etc.
                selectedKey = measure.localKey;
                // Use 'major' for major keys, 'minor' for minor keys (not 'ionian'/'natural_minor')
                selectedScale = measure.localKey.endsWith('m') ? 'minor' : 'major';
                console.log('Set selectedKey to:', selectedKey, 'selectedScale to:', selectedScale);
                
                console.log('🔵 After setting selectedKey - chord-0:', document.getElementById('chord-0') ? 'EXISTS' : 'NULL');
                
                // Update all UI to reflect the local key
                console.log('Calling updateKeyInfo...');
                updateKeyInfo();
                console.log('🔵 After updateKeyInfo - chord-0:', document.getElementById('chord-0') ? 'EXISTS' : 'NULL');
                console.log('Calling updateSelectedButtons...');
                updateSelectedButtons();
                
                // Sync progression window dropdowns with selected measure
                const keySelect = document.getElementById('progressionKey');
                const timeSelect = document.getElementById('timeSignature');
                const subdivisionSelect = document.getElementById('measureSubdivision');
                
                if (keySelect) {
                    keySelect.value = measure.localKey;
                    console.log('Synced progressionKey dropdown to:', measure.localKey);
                }
                if (timeSelect && measure.timeSignature) {
                    timeSelect.value = measure.timeSignature;
                    console.log('Synced timeSignature dropdown to:', measure.timeSignature);
                }
                if (subdivisionSelect && measure.subdivision) {
                    subdivisionSelect.value = measure.subdivision;
                    console.log('Synced subdivision dropdown to:', measure.subdivision);
                } else if (subdivisionSelect) {
                    subdivisionSelect.value = 'whole'; // Default
                }
            }
            
            highlightSelectedMeasure();
            
            // DEBUG: Check if elements exist before calling updateProgressionChart
            const testChord0 = document.getElementById('chord-0');
            const testRoman0 = document.getElementById('roman-0');
            console.log(`🚨 BEFORE updateProgressionChart in selectMeasure: chord-0=${testChord0 ? 'EXISTS' : 'NULL'}, roman-0=${testRoman0 ? 'EXISTS' : 'NULL'}`);
            
            updateProgressionChart();
            
            // Display the chord on the fretboard if measure has a chord
            const measure2 = progressionMeasures[measureIndex];
            const chord = measure2 ? measure2.chord : null;
            if (chord) {
                selectedChord = chord;
                console.log('🎸 selectMeasure: Setting selectedChord:', chord.symbol, 'with notes:', chord.notes);
                console.log('Calling updateFretboard with chord notes...');
                updateFretboard(chord.notes);
            } else {
                console.log('Calling updateFretboard without specific chord...');
                updateFretboard();
            }
        }

        function selectChordFromStaff(measureIndex) {
            // Get the chord from the progression measures
            const measure = progressionMeasures[measureIndex];
            const chord = measure ? measure.chord : null;
            if (chord) {
                // Set this as the selected chord for fretboard highlighting
                selectedChord = chord;
                console.log('Selected chord from staff:', chord.isCustom ? 'Custom chord' : chord.symbol, chord.notes);
                
                // Update the fretboard to show this chord
                updateFretboard(chord.notes);
                
                // Also update the key info to reflect the selection
                updateKeyInfo();
                
                // Add visual feedback to show which measure is selected
                highlightSelectedMeasure(measureIndex);
            }
        }

        function highlightSelectedMeasure(measureIndex) {
            // Remove highlight from all measures
            document.querySelectorAll('.measure-staff').forEach((measure, idx) => {
                measure.classList.remove('selected-measure');
            });
            
            // Highlight the selected measure
            const selectedMeasure = document.getElementById(`staff-measure-${measureIndex}`);
            if (selectedMeasure) {
                selectedMeasure.classList.add('selected-measure');
            }
        }

        function deselectMeasure() {
            // Restore the original progression key
            if (window.originalProgressionKey) {
                selectedKey = window.originalProgressionKey;
                selectedScale = window.originalProgressionScale || (window.originalProgressionKey.endsWith('m') ? 'minor' : 'major');
                delete window.originalProgressionKey;
                delete window.originalProgressionScale;
                
                // Update UI to reflect the restoration
                updateKeyInfo();
                updateFretboard();
                updateSelectedButtons();
            }
            
            // Clear selected measure
            selectedMeasureIndex = null;
            
            // Remove all measure highlights
            document.querySelectorAll('.measure-staff').forEach(measure => {
                measure.classList.remove('selected-measure');
            });
        }

        function updateActiveChordButton(chord) {
            // Simplified chord button feedback - no green highlighting to prevent floating boxes
            document.querySelectorAll('.chord-button').forEach(btn => {
                btn.style.background = '';
                btn.style.color = '';
                
                // Simple border highlight instead of background color
                if (btn.textContent.includes(chord.symbol) && btn.classList.contains('chord-button')) {
                    btn.style.border = '2px solid #4CAF50';
                    setTimeout(() => {
                        btn.style.border = '';
                    }, 500);
                }
            });
        }

        function clearProgression() {
            progressionActive = false;
            progressionMeasures = [];
            selectedMeasureIndex = null;
            isPlaying = false;
            
            // Clear the user selected key flag
            delete window.userSelectedKey;
            
            // Restore the original progression key if we were viewing a local key
            if (window.originalProgressionKey) {
                selectedKey = window.originalProgressionKey;
                selectedScale = window.originalProgressionScale || (window.originalProgressionKey.endsWith('m') ? 'minor' : 'major');
                delete window.originalProgressionKey;
                delete window.originalProgressionScale;
                updateSelectedButtons();
            }
            
            document.getElementById('staffContainer').classList.remove('active');
            document.querySelector('.play-progression-btn').disabled = true;
            document.querySelector('.play-progression-btn').textContent = 'Play';
            document.getElementById('countInDisplay').style.display = 'none';
            document.getElementById('beatIndicator').style.display = 'none';
            
            // Hide cadence options
            document.getElementById('cadenceControls').style.display = 'none';
            
            // Clear any chord highlighting
            selectedChord = null;
            updateKeyInfo();
            updateFretboard();
        }

        async function playProgression() {
            if (!progressionMeasures.length || progressionMeasures.some(chord => chord === null)) {
                return;
            }
            
            if (isPlaying) {
                stopProgression();
                return;
            }
            
            // Check if playing all sections (Song mode) or current section only
            const playAllSections = document.getElementById('playAllSections').checked;
            isPlaying = true;
            document.querySelector('.play-progression-btn').textContent = 'Stop';
            
            try {
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Diagnostic: log audio context state
                console.log('AudioContext state before playback:', audioContext.state);
                // Force unlock/resume audio context
                if (!isMobileAudioUnlocked) {
                    unlockMobileAudio();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log('AudioContext resumed. State:', audioContext.state);
                }
                // Test: play a short beep to confirm audio
                try {
                    const testOsc = audioContext.createOscillator();
                    const testGain = audioContext.createGain();
                    testOsc.connect(testGain);
                    testGain.connect(audioContext.destination);
                    testOsc.frequency.setValueAtTime(440, audioContext.currentTime);
                    testOsc.type = 'sine';
                    testGain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    testGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    testOsc.start(audioContext.currentTime);
                    testOsc.stop(audioContext.currentTime + 0.2);
                } catch (err) {
                    console.warn('Test beep failed:', err);
                }
                
                // Count-in
                await performCountIn();
                
                if (playAllSections) {
                    // Play all sections sequentially with auto-switching
                    await playAllSectionsSequentially();
                } else {
                    // Play current section only, looping
                    do {
                        await playProgressionOnce();
                    } while (isPlaying);
                }
                
            } catch (error) {
                console.error('Audio playback error:', error);
            } finally {
                stopProgression();
            }
        }

        async function playAllSectionsSequentially() {
            const startingSectionIndex = currentSong.currentSectionIndex;
            
            // Play from current section to end
            for (let i = startingSectionIndex; i < currentSong.sections.length && isPlaying; i++) {
                await playSectionByIndexWithSwitch(i);
            }
            
            // Play remaining sections from start if we didn't start at 0
            if (startingSectionIndex > 0 && isPlaying) {
                for (let i = 0; i < startingSectionIndex && isPlaying; i++) {
                    await playSectionByIndexWithSwitch(i);
                }
            }
        }

        async function playSectionByIndexWithSwitch(sectionIndex) {
            const section = currentSong.sections[sectionIndex];
            if (!section) return;
            
            // Switch to this section visually
            if (sectionIndex !== currentSong.currentSectionIndex) {
                switchToSection(sectionIndex);
                // Small delay to let UI update
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Play the section once
            await playProgressionOnce();
        }

        async function performCountIn() {
            const countDisplay = document.getElementById('countInDisplay');
            const tempo = parseInt(document.getElementById('tempo').value) || 120;
            const beatDuration = (60 / tempo) * 1000; // milliseconds
            
            // Get the actual time signature for count-in
            const timeSignature = document.getElementById('timeSignature').value;
            const [beatsPerMeasure] = timeSignature.split('/').map(Number);
            
            countInActive = true;
            countDisplay.style.display = 'block';
            
            for (let count = beatsPerMeasure; count >= 1 && isPlaying; count--) {
                countDisplay.textContent = count;
                countDisplay.style.animation = 'none';
                // Force reflow
                countDisplay.offsetHeight;
                countDisplay.style.animation = 'countPulse 1s ease-out';
                
                // Play enhanced metronome click
                playMetronomeClick(count === 1); // Accent on beat 1
                
                // Wait for beat duration on every beat, including the last one
                await new Promise(resolve => setTimeout(resolve, beatDuration));
            }
            
            countDisplay.style.display = 'none';
            countInActive = false;
        }

        function playMetronomeClick(isAccent = false) {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Higher pitch for accent, lower for regular beats
                oscillator.frequency.setValueAtTime(isAccent ? 1200 : 800, audioContext.currentTime);
                oscillator.type = 'square';
                
                // Louder for accent
                const volume = isAccent ? 0.3 : 0.15;
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {
                console.error('Metronome click error:', error);
            }
        }

        async function playProgressionOnce() {
            const tempo = parseInt(document.getElementById('tempo').value) || 120;
            const beatDuration = (60 / tempo) * 1000; // milliseconds per beat
            const timeSignature = document.getElementById('timeSignature').value;
            const [beatsPerMeasure] = timeSignature.split('/').map(Number);
            const measureDuration = beatDuration * beatsPerMeasure;

            for (let i = 0; i < progressionMeasures.length && isPlaying; i++) {
                const measure = progressionMeasures[i];
                const measureEl = document.getElementById(`staff-measure-${i}`);

                // Highlight current measure
                document.querySelectorAll('.measure-staff').forEach((m, index) => {
                    m.style.background = index === i ? 'rgba(255, 255, 0, 0.1)' : '';
                });

                // Use measure's timeSignature if available, fallback to global
                const localBeatsPerMeasure = measure && measure.timeSignature
                    ? parseInt(measure.timeSignature.split('/')[0])
                    : beatsPerMeasure;
                const localMeasureDuration = beatDuration * localBeatsPerMeasure;

                // Prepare chord slots for syncopated measures
                let chordSlots = [];
                if (measure && measure.chords && Array.isArray(measure.chords) && measure.chords.length > 0) {
                    const subdivisionDurations = {
                        'whole': 4,
                        'half': 2,
                        'dotted-half': 3,
                        'quarter': 1,
                        'dotted-quarter': 1.5,
                        'eighth': 0.5,
                        'dotted-eighth': 0.75
                    };
                    let slotStart = 0;
                    for (const slot of measure.chords) {
                        chordSlots.push({
                            chord: slot.chord || slot.symbol,
                            startBeat: slotStart,
                            durationBeats: subdivisionDurations[slot.duration] || 4
                        });
                        slotStart += subdivisionDurations[slot.duration] || 4;
                    }
                } else if (measure.chord) {
                    chordSlots.push({
                        chord: measure.chord,
                        startBeat: 0,
                        durationBeats: localBeatsPerMeasure
                    });
                }

                // Schedule all chords at their exact fractional startBeat
                let chordTimers = [];
                for (const slot of chordSlots) {
                    if (slot.startBeat < localBeatsPerMeasure && isPlaying) {
                        const chordTime = slot.startBeat * beatDuration;
                        chordTimers.push(setTimeout(() => {
                            if (!isPlaying) return;
                            // Ensure selectedChord and playChordSound both get an object
                            let chordObj;
                            if (typeof slot.chord === 'string') {
                                chordObj = { symbol: slot.chord };
                            } else {
                                chordObj = slot.chord;
                            }
                            selectedChord = chordObj;
                            updateFretboard();
                            playChordSound(chordObj, (beatDuration * slot.durationBeats) / 1000);
                        }, chordTime));
                    }
                }

                // Play metronome clicks at each integer beat
                for (let beat = 0; beat < localBeatsPerMeasure && isPlaying; beat++) {
                    playMetronomeClick(beat === 0);
                    await new Promise(resolve => setTimeout(resolve, beatDuration));
                }

                // Clear chord timers (in case measure ends early)
                chordTimers.forEach(timer => clearTimeout(timer));
            }
        }

        function playClickSound() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.type = 'square';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {
                console.error('Click sound error:', error);
            }
        }

        function stopProgression() {
            isPlaying = false;
            const playBtn = document.querySelector('.play-progression-btn');
            if (playBtn) {
                playBtn.textContent = 'Play';
            }
            
            // Clear measure highlighting
            document.querySelectorAll('.measure-staff').forEach(m => {
                if (m && m.style) {
                    m.style.background = '';
                }
            });
            
            // Hide count display and beat indicator
            const countDisplay = document.getElementById('countInDisplay');
            const beatIndicator = document.getElementById('beatIndicator');
            if (countDisplay) countDisplay.style.display = 'none';
            if (beatIndicator) beatIndicator.style.display = 'none';
            
            // Keep chord chart and fretboard as they were - don't clear chord highlighting
        }

        async function playChordSound(chord, duration) {
            if (!audioContext || !chord) return;
            
            console.log('=== PROGRESSION PLAYBACK ===');
            console.log('Chord being played:', chord);
            console.log('Chord symbol:', chord.symbol);
            console.log('Chord notes:', chord.notes);
            console.log('Is custom chord:', chord.isCustom);
            
            // If chord has no notes, generate them from the symbol and current key
            let notesToPlay = chord.notes;
            if (!notesToPlay || notesToPlay.length === 0) {
                console.log('🎵 Generating notes from chord symbol:', chord.symbol);
                notesToPlay = generateChordNotesFromSymbol(chord.symbol);
                console.log('🎵 Generated notes:', notesToPlay);
            }
            
            if (!notesToPlay || notesToPlay.length === 0) {
                console.warn('No notes to play for chord:', chord);
                return;
            }
            
            try {
                // Simple synthesized chord using Web Audio API
                const frequencies = getChordFrequencies(notesToPlay);
                console.log('[AUDIO] playChordSound called');
                console.log('[AUDIO] Notes to play:', notesToPlay);
                console.log('[AUDIO] Frequencies:', frequencies);
                console.log('[AUDIO] Duration:', duration);
                const oscillators = [];
                const gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                // Set gain higher for audibility during testing
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                console.log('[AUDIO] GainNode initial value:', gainNode.gain.value);
                frequencies.forEach((freq, idx) => {
                    const oscillator = audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine';
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                    oscillators.push(oscillator);
                    console.log(`[AUDIO] Oscillator ${idx}: freq=${freq}, type=sine, start=${audioContext.currentTime}, stop=${audioContext.currentTime + duration}`);
                });
                return new Promise(resolve => {
                    setTimeout(resolve, duration * 1000);
                });
            } catch (error) {
                console.error('Chord sound generation error:', error);
            }
        }
        
        // Generate chord notes from chord symbol (for library songs)
        function generateChordNotesFromSymbol(symbol) {
            if (!symbol || symbol === 'N.C.') return [];
            // Parse chord symbol to get root and quality
            const rootMatch = symbol.match(/^([A-G][#♯b♭]?)/);
            if (!rootMatch) return [];
            const root = rootMatch[1];
            const quality = symbol.substring(root.length);
            // Get semitones for intervals based on chord quality
            const intervals = getChordIntervals(quality);
            // Convert root to semitone
            const rootSemitone = noteToSemitone(root);

            // Use sharps for sharp keys/roots, flats for flat keys/roots
            // List of keys/roots that prefer sharps
            const sharpRoots = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];
            // List of roots that prefer flats
            const flatRoots = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
            // Normalize root for comparison
            const normRoot = root.replace('♯', '#').replace('♭', 'b');
            let useSharps = sharpRoots.includes(normRoot);
            if (flatRoots.includes(normRoot)) useSharps = false;

            const noteNamesSharps = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
            const noteNamesFlats  = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];
            const noteNames = useSharps ? noteNamesSharps : noteNamesFlats;

            // For 13th chords, immediately return only root, 3rd, 5th, 7th, 13th before any other logic
            if (/13/.test(quality)) {
                let rootNote = noteNames[rootSemitone % 12];
                let thirdNote = noteNames[(rootSemitone + 4) % 12];
                let fifthNote = noteNames[(rootSemitone + 7) % 12];
                // 7th: dominant (10) or major (11)
                let seventhNote = noteNames[(rootSemitone + (intervals.includes(11) ? 11 : 10)) % 12];
                let thirteenthNote = noteNames[(rootSemitone + 21) % 12];
                return [rootNote, thirdNote, fifthNote, seventhNote, thirteenthNote];
            }

            let notes = intervals.map(interval => {
                const noteSemitone = (rootSemitone + interval) % 12;
                return noteNames[noteSemitone];
            });

            // If it's a 7th chord or extension (and not 13th, handled above), apply 5-note max rule
            const is7thChord = /7/.test(quality);
            if (is7thChord) {
                // Find root, 3rd, 7th
                const rootNote = notes[0];
                const thirdNote = notes[1];
                // 5th is usually index 2
                const fifthNote = notes[2];
                // Find the 7th by interval (should be 10 or 11 semitones from root)
                let seventhIdx = -1;
                for (let i = 0; i < intervals.length; i++) {
                    if (intervals[i] === 10 || intervals[i] === 11) {
                        seventhIdx = i;
                        break;
                    }
                }
                const seventhNote = seventhIdx !== -1 ? notes[seventhIdx] : notes[3];

                // Gather explicit extensions (anything above 7th, e.g., 9th, 11th, #11, b9, etc.)
                let extensionNotes = [];
                for (let i = 0; i < intervals.length; i++) {
                    if (intervals[i] > 11) {
                        extensionNotes.push(notes[i]);
                    }
                    // Also include altered extensions (e.g., #11, b9, #9, b13, #5, b5)
                    if ([13, 14, 15, 16, 17, 18, 20, 21].includes(intervals[i])) {
                        if (!extensionNotes.includes(notes[i])) extensionNotes.push(notes[i]);
                    }
                }

                // Compose final notes: always root, 3rd, 7th
                let finalNotes = [rootNote, thirdNote, seventhNote];
                // Add up to 2 extensions, prioritizing explicit extensions
                if (extensionNotes.length > 0) {
                    finalNotes = finalNotes.concat(extensionNotes.slice(0, 2));
                } else if (fifthNote) {
                    // If no extension, add 5th
                    finalNotes.push(fifthNote);
                }
                // Remove duplicates and undefined, strictly limit to 5 notes
                notes = Array.from(new Set(finalNotes)).filter(Boolean).slice(0, 5);
            }
            
            return notes;
        }
        
        // Get intervals for chord quality
        function getChordIntervals(quality) {
            const patterns = {
                '': [0, 4, 7],              // Major
                'm': [0, 3, 7],             // Minor
                '7': [0, 4, 7, 10],         // Dominant 7th
                'maj7': [0, 4, 7, 11],      // Major 7th
                'M7': [0, 4, 7, 11],        // Major 7th
                'm7': [0, 3, 7, 10],        // Minor 7th
                'dim': [0, 3, 6],           // Diminished
                'dim7': [0, 3, 6, 9],       // Diminished 7th
                'm7b5': [0, 3, 6, 10],      // Half-diminished
                'aug': [0, 4, 8],           // Augmented
                'sus2': [0, 2, 7],          // Suspended 2
                'sus4': [0, 5, 7],          // Suspended 4
                '6': [0, 4, 7, 9],          // Major 6th
                'm6': [0, 3, 7, 9],         // Minor 6th
                '9': [0, 4, 7, 10, 14],     // Dominant 9th
                'maj9': [0, 4, 7, 11, 14],  // Major 9th
                'm9': [0, 3, 7, 10, 14],    // Minor 9th
                '13': [0, 4, 7, 10, 14, 17, 21],      // Dominant 13th
                'maj13': [0, 4, 7, 11, 14, 17, 21],   // Major 13th
                'm13': [0, 3, 7, 10, 14, 17, 21],     // Minor 13th
                '7b9': [0, 4, 7, 10, 13],             // Dominant 7b9
                '7#9': [0, 4, 7, 10, 15],             // Dominant 7#9
                '7#11': [0, 4, 7, 10, 14, 18],        // Dominant 7#11
                '7b13': [0, 4, 7, 10, 20],            // Dominant 7b13
                '7#5': [0, 4, 8, 10],                 // Dominant 7#5
                '7b5': [0, 4, 6, 10],                 // Dominant 7b5
                '5': [0, 7],                // Power chord
                'add9': [0, 4, 7, 14]       // Add 9
            };
            return patterns[quality] || patterns[''];  // Default to major
        }

        function getChordFrequencies(noteNames) {
            // Complete note to frequency mapping with all enharmonic equivalents (middle octave C4)
            const noteFrequencies = {
                // All enharmonic equivalents for complete coverage
                'C': 261.63, 'B♯': 261.63, 'B#': 261.63,
                'C♯': 277.18, 'C#': 277.18, 'D♭': 277.18, 'Db': 277.18,
                'D': 293.66, 
                'D♯': 311.13, 'D#': 311.13, 'E♭': 311.13, 'Eb': 311.13,
                'E': 329.63, 'F♭': 329.63, 'Fb': 329.63,
                'F': 349.23, 'E♯': 349.23, 'E#': 349.23,
                'F♯': 369.99, 'F#': 369.99, 'G♭': 369.99, 'Gb': 369.99,
                'G': 392.00, 
                'G♯': 415.30, 'G#': 415.30, 'A♭': 415.30, 'Ab': 415.30,
                'A': 440.00, 
                'A♯': 466.16, 'A#': 466.16, 'B♭': 466.16, 'Bb': 466.16,
                'B': 493.88, 'C♭': 493.88, 'Cb': 493.88
            };
            
            console.log('Playing chord notes:', noteNames);
            
            // Map notes to frequencies
            // Play up to 7 notes for extended/jazz chords
            let frequencies = noteNames.slice(0, 7).map(note => {
                const freq = noteFrequencies[note];
                if (!freq) {
                    console.warn(`No frequency found for note: ${note}, using A440`);
                    return 440;
                }
                return freq;
            });
            
            // Sort ascending and adjust octaves to create proper voicing
            // Start with frequencies in ascending order
            frequencies.sort((a, b) => a - b);
            
            // If the root (first note) ended up higher than other notes after sorting,
            // drop it an octave
            const rootFreq = noteFrequencies[noteNames[0]];
            const sortedRootIndex = frequencies.indexOf(rootFreq);
            
            // If root isn't the lowest note, drop it an octave
            if (sortedRootIndex > 0) {
                frequencies[sortedRootIndex] = rootFreq / 2;
                // Re-sort after octave adjustment
                frequencies.sort((a, b) => a - b);
            }
            
            console.log('Playing frequencies:', frequencies);
            return frequencies;
        }

        // Start periodic cleanup of green styling to prevent floating boxes
        setInterval(cleanupGreenStyling, 1000);

        // Initialize the app when page loads
        window.addEventListener('load', init);

        // Add font loading detection
        document.fonts.ready.then(() => {
            console.log('Music fonts loaded');
            // Re-render staff if needed
            if (progressionActive) {
                generateStaffMeasures(progressionMeasures.length, document.getElementById('timeSignature').value);
            }
        });

        // Song Category Modal Integration
    const SONG_LIBRARY_URL = 'library-builder/output/curated-library-rhythmic.json';
    let SONG_LIBRARY = [];
    let currentGenre = null;
    let songCategoryModalOpen = false;
    let modalInitialized = false;
    
    // Enhanced logging
    console.log('🎵 [MODAL] Song Category Modal system initializing...');
    console.log('🎵 [MODAL] Library URL:', SONG_LIBRARY_URL);
    const GENRES = {
        'Classic Rock': { color: '#e91e63', icon: '🎸' },
        'Pop': { color: '#9c27b0', icon: '🎤' },
        'Jazz': { color: '#3f51b5', icon: '🎺' },
        'Blues': { color: '#2196f3', icon: '🎵' },
        'Folk': { color: '#4caf50', icon: '🪕' },
        'Country': { color: '#ff9800', icon: '🤠' },
        'R&B': { color: '#f44336', icon: '🎹' },
        'Teaching': { color: '#607d8b', icon: '📚' },
        'Hymn': { color: '#795548', icon: '⛪' },
        'Children': { color: '#ff5722', icon: '🧸' },
        'Traditional': { color: '#009688', icon: '🎭' }
    };
    
    function populateSongDropdown() {
        const dropdown = document.getElementById('songDropdown');
        if (!dropdown) return;
        // Remove all except first
        while (dropdown.options.length > 1) dropdown.remove(1);
        SONG_LIBRARY.forEach((song, idx) => {
            const option = document.createElement('option');
            option.value = idx;
            option.textContent = `${song.title} — ${song.artist}`;
            dropdown.appendChild(option);
        });
    }
    function getSongsByGenre(genre) {
        return SONG_LIBRARY.filter(song => song.genre === genre);
    }
    function openSongCategoryModal(genre) {
        console.log('[Modal] Opening modal for genre:', genre);
        currentGenre = genre;
        songCategoryModalOpen = true;
        document.getElementById('songCategoryModalOverlay').style.display = 'flex';
        document.getElementById('songCategoryModalTitle').textContent = `${genre} Songs`;
        document.getElementById('songCategoryModalGenre').textContent = genre;
        document.getElementById('songCategoryModalGenre').style.background = GENRES[genre]?.color || '#4CAF50';
        document.getElementById('songCategoryModalLoading').style.display = 'block';
        document.getElementById('songCategoryModalEmpty').style.display = 'none';
        document.getElementById('songCategoryModalList').innerHTML = '';
        setTimeout(() => displaySongsInModal(genre), 200);
    }
    function closeSongCategoryModal() {
        console.log('[Modal] Closing modal');
        songCategoryModalOpen = false;
        document.getElementById('songCategoryModalOverlay').style.display = 'none';
        currentGenre = null;
    }
    function displaySongsInModal(genre) {
        const songs = getSongsByGenre(genre);
        document.getElementById('songCategoryModalLoading').style.display = 'none';
        if (songs.length === 0) {
            document.getElementById('songCategoryModalEmpty').style.display = 'block';
            document.getElementById('songCategoryModalCount').textContent = '0 songs';
            console.log('[Modal] No songs found for genre:', genre);
            return;
        }
        document.getElementById('songCategoryModalEmpty').style.display = 'none';
        document.getElementById('songCategoryModalCount').textContent = `${songs.length} song${songs.length !== 1 ? 's' : ''}`;
        const list = document.getElementById('songCategoryModalList');
        list.innerHTML = '';
        songs.forEach((song, idx) => {
            const card = document.createElement('div');
            card.className = 'song-card-modal';
            card.innerHTML = `
                <div class="song-info-modal">
                    <div class="song-title-modal">${song.title}</div>
                    <div class="song-details-modal">
                        <div class="song-detail-modal"><span>👤</span><span>${song.artist}</span></div>
                        <div class="song-detail-modal"><span>🎹</span><span>Key: ${song.key} ${song.mode}</span></div>
                        <div class="song-detail-modal"><span>⏱️</span><span>${song.tempo} BPM</span></div>
                        <div class="song-detail-modal"><span>📄</span><span>${song.sections?.length || 0} section${(song.sections?.length !== 1) ? 's' : ''}</span></div>
                    </div>
                </div>
                <div class="song-actions-modal">
                    <button class="btn-modal btn-modal-primary" data-idx="${idx}">Select ✓</button>
                </div>
            `;
            card.querySelector('.btn-modal-primary').onclick = () => {
                closeSongCategoryModal();
                if (typeof loadSongIntoVisualizer === 'function') {
                    console.log('[Modal] Loading song into visualizer:', song.title);
                    loadSongIntoVisualizer(song);
                } else {
                    alert('Song selected: ' + song.title);
                }
            };
            list.appendChild(card);
        });
        console.log('[Modal] Displayed', songs.length, 'songs for genre', genre);
    }
    // Initialize modal system
    function initializeModalSystem() {
        if (modalInitialized) {
            console.log('🎵 [MODAL] Already initialized, skipping...');
            return;
        }
        
        console.log('🎵 [MODAL] ========================================');
        console.log('🎵 [MODAL] Initializing modal system...');
        console.log('🎵 [MODAL] ========================================');
        
        const dropdown = document.getElementById('songDropdown');
        if (!dropdown) return;
        dropdown.addEventListener('change', function(e) {
            const idx = e.target.value;
            if (idx !== "" && SONG_LIBRARY[idx]) {
                loadSongIntoVisualizer(SONG_LIBRARY[idx]);
            }
        });
        
        // Load song library
        console.log('🎵 [MODAL] Fetching library from:', SONG_LIBRARY_URL);
        fetch(SONG_LIBRARY_URL)
            .then(r => r.json())
            .then(data => {
                SONG_LIBRARY = Array.isArray(data) ? data : [];
                populateSongDropdown();
            });
        
        // Setup modal close handlers
        const closeBtn = document.getElementById('songCategoryModalClose');
        const cancelBtn = document.getElementById('songCategoryModalCancel');
        const overlay = document.getElementById('songCategoryModalOverlay');
        
        if (closeBtn) {
            closeBtn.onclick = closeSongCategoryModal;
            console.log('🎵 [MODAL] ✅ Close button handler attached');
        }
        if (cancelBtn) {
            cancelBtn.onclick = closeSongCategoryModal;
            console.log('🎵 [MODAL] ✅ Cancel button handler attached');
        }
        if (overlay) {
            overlay.onclick = (e) => {
                if (e.target === overlay) closeSongCategoryModal();
            };
            console.log('🎵 [MODAL] ✅ Overlay click handler attached');
        }
        
        // ESC key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && songCategoryModalOpen) {
                closeSongCategoryModal();
            }
        });
        console.log('🎵 [MODAL] ✅ ESC key handler attached');
    }
    
    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeModalSystem);
        console.log('🎵 [MODAL] Will initialize on DOMContentLoaded');
    } else {
        // DOM already loaded
        console.log('🎵 [MODAL] DOM already loaded, initializing now');
        initializeModalSystem();
    }
    </script>
</body>
<script>

// --- Genre Modal Logic ---
function populateGenres() {
    const dropdown = document.getElementById('genreDropdown');
    if (!window.SONG_LIBRARY || !window.SONG_LIBRARY.length) {
        console.warn('SONG_LIBRARY not found or empty!');
        return;
    }
    const genres = [...new Set(window.SONG_LIBRARY.map(song => song.genre))].sort();
    genres.forEach(genre => {
        const option = document.createElement('option');
        option.value = genre;
        option.textContent = genre;
        dropdown.appendChild(option);
    });
}

document.getElementById('genreDropdown').addEventListener('change', function() {
    const genre = this.value;
    if (genre) openGenreModal(genre);
});

function openGenreModal(genre) {
    const songs = window.SONG_LIBRARY.filter(song => song.genre === genre);
    document.getElementById('modalGenre').textContent = `${genre} (${songs.length})`;
    const container = document.getElementById('modalSongs');
    container.innerHTML = '';
    songs.forEach(song => {
        const div = document.createElement('div');
        div.className = 'song-item';
        div.style = 'padding:15px;margin-bottom:10px;background:#f9f9f9;border:2px solid #ddd;border-radius:8px;cursor:pointer;transition:all 0.2s;';
        div.innerHTML = `
            <div class=\"song-title\" style=\"font-size:18px;font-weight:bold;margin-bottom:5px;\">${song.title}</div>
            <div class=\"song-info\" style=\"font-size:14px;color:#666;\">
                ${song.artist} • ${song.key} ${song.mode || ''} • ${song.tempo || ''} BPM
            </div>
        `;
        div.onclick = function() {
            console.log('🎵 Song clicked:', song);
            if (typeof window.loadThisSong === 'function') {
                window.loadThisSong(song);
            } else {
                console.warn('window.loadThisSong is not a function');
            }
            closeModal();
        };
        container.appendChild(div);
    });
    document.getElementById('genreModal').style.display = 'flex';
    document.getElementById('genreModal').style.alignItems = 'center';
    document.getElementById('genreModal').style.justifyContent = 'center';
}

function closeModal() {
    document.getElementById('genreModal').style.display = 'none';
}

document.getElementById('genreModal').addEventListener('click', function(e) {
    if (e.target === this) closeModal();
});
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') closeModal();
});

// Ensure currentProgression is defined globally
window.currentProgression = {};
window.loadThisSong = function(song) {
    console.log('✅ [loadThisSong] Loading song:', song);
    try {
        currentSong = song;
        // Diagnostic: Log sections and measures
        if (Array.isArray(currentSong.sections)) {
            console.log(`[loadThisSong] Song has ${currentSong.sections.length} sections.`);
            currentSong.sections.forEach((section, idx) => {
                console.log(`[loadThisSong] Section ${idx}:`, section.name, 'bars:', section.bars, 'measures:', section.measures?.length);
            });
        }
        // Ensure currentSectionIndex is valid
        if (typeof currentSong.currentSectionIndex !== 'number' ||
            !Array.isArray(currentSong.sections) ||
            currentSong.currentSectionIndex < 0 ||
            currentSong.currentSectionIndex >= currentSong.sections.length) {
            currentSong.currentSectionIndex = 0;
        }
        // Ensure repeat is a valid number for each section
        currentSong.sections.forEach(section => {
            if (typeof section.repeat !== 'number' || section.repeat < 1) {
                section.repeat = 1;
            }
        });
        progressionActive = true;
        renderSectionTabs();
        updateSongTitleDisplay();
        currentProgression.key = song.key;
        currentProgression.mode = song.mode;
        selectKey(song.key, song.mode === 'minor');
        syncProgressionMeasures(0);
        // Get measure count and time signature for staff generation
        const currentSection = currentSong.sections[currentSong.currentSectionIndex];
        progressionMeasures = currentSection.measures;
        // Diagnostic: Log measure and chord slot structure for debugging
        console.log('🟡 [DIAG] First 3 measures:', progressionMeasures.slice(0, 3));
        if (progressionMeasures[0] && progressionMeasures[0].chords) {
            console.log('🟡 [DIAG] Measure 0 chords:', progressionMeasures[0].chords);
        }
        progressionActive = true;
        // Show the staff container and enable play button
        const staffContainer = document.getElementById('staffContainer');
        if (staffContainer) staffContainer.classList.add('active');
        const playBtn = document.querySelector('.play-progression-btn');
        if (playBtn) playBtn.disabled = false;
        const measureCount = Array.isArray(currentSection.measures) ? currentSection.measures.length * (currentSection.repeat || 1) : 0;
        const timeSignature = currentSection.timeSignature || '4/4';
        generateStaffMeasures(measureCount, timeSignature);
        updateProgressionChart();
        selectMeasure(0);
        console.log('✅ Song loaded successfully!');
    } catch (err) {
        console.error('❌ Error loading song:', err);
    }
};


// --- Load SONG_LIBRARY from JSON and populate genres ---
function loadSongLibraryAndGenres() {
    // Try to fetch the JSON file (adjust path if needed)
    fetch('library-builder/output/curated-library-rhythmic.json')
        .then(res => {
            if (!res.ok) throw new Error('Failed to fetch song library JSON');
            return res.json();
        })
        .then(data => {
            window.SONG_LIBRARY = data;
            console.log('✅ SONG_LIBRARY loaded:', window.SONG_LIBRARY);
            if (!Array.isArray(window.SONG_LIBRARY) || window.SONG_LIBRARY.length === 0) {
                console.warn('SONG_LIBRARY is empty or not an array');
            } else {
                console.log('First song:', window.SONG_LIBRARY[0]);
                console.log('Genres:', window.SONG_LIBRARY.map(s => s.genre));
            }
            populateGenres();
        })
        .catch(err => {
            console.error('Error loading SONG_LIBRARY:', err);
        });
}

// Call this on DOMContentLoaded
window.addEventListener('DOMContentLoaded', loadSongLibraryAndGenres);
</script>
</body>
</html>
